function animateScrollTo(t) {
    "use strict";
    var e = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1],
        i = {
            speed: 500,
            minDuration: 250,
            maxDuration: 3e3,
            cancelOnUserAction: !0
        },
        n = {};
    Object.keys(i).forEach(function(t) {
        n[t] = e[t] ? e[t] : i[t]
    });
    var r = window.scrollY || document.documentElement.scrollTop,
        s = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;
    t > s && (t = s);
    var o = t - r;
    if (0 !== o) {
        var a = Math.abs(Math.round(o / 1e3 * n.speed));
        a < n.minDuration ? a = n.minDuration : a > n.maxDuration && (a = n.maxDuration);
        var h = Date.now(),
            u = null,
            l = null;
        n.cancelOnUserAction ? (l = function(t) {
            cancelAnimationFrame(u)
        }, window.addEventListener("keydown", l)) : (l = function(t) {
            t.preventDefault()
        }, window.addEventListener("scroll", l)), window.addEventListener("wheel", l), window.addEventListener("touchstart", l);
        var c = function e() {
            var i = Date.now() - h,
                s = i / a - 1,
                c = s * s * s + 1,
                d = Math.round(r + o * c);
            i < a && d !== t ? (window.scrollTo(0, d), u = requestAnimationFrame(e)) : (window.scrollTo(0, t), cancelAnimationFrame(u), window.removeEventListener("wheel", l), window.removeEventListener("touchstart", l), n.cancelOnUserAction ? window.removeEventListener("keydown", l) : window.removeEventListener("scroll", l))
        };
        u = requestAnimationFrame(c)
    }
}! function(t) {
    "use strict";

    function e(t) {
        return new RegExp("(^|\\s+)" + t + "(\\s+|$)")
    }

    function i(t, e) {
        (n(t, e) ? s : r)(t, e)
    }
    var n, r, s;
    "classList" in document.documentElement ? (n = function(t, e) {
        return t.classList.contains(e)
    }, r = function(t, e) {
        t.classList.add(e)
    }, s = function(t, e) {
        t.classList.remove(e)
    }) : (n = function(t, i) {
        return e(i).test(t.className)
    }, r = function(t, e) {
        n(t, e) || (t.className = t.className + " " + e)
    }, s = function(t, i) {
        t.className = t.className.replace(e(i), " ")
    });
    var o = {
        hasClass: n,
        addClass: r,
        removeClass: s,
        toggleClass: i,
        has: n,
        add: r,
        remove: s,
        toggle: i
    };
    "function" == typeof define && define.amd ? define(o) : "object" == typeof exports ? module.exports = o : t.classie = o
}(window),
function() {
    "use strict";

    function t(n) {
        if (!n) throw new Error("No options passed to Waypoint constructor");
        if (!n.element) throw new Error("No element option passed to Waypoint constructor");
        if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + e, this.options = t.Adapter.extend({}, t.defaults, n), this.element = this.options.element, this.adapter = new t.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, e += 1
    }
    var e = 0,
        i = {};
    t.prototype.queueTrigger = function(t) {
        this.group.queueTrigger(this, t)
    }, t.prototype.trigger = function(t) {
        this.enabled && this.callback && this.callback.apply(this, t)
    }, t.prototype.destroy = function() {
        this.context.remove(this), this.group.remove(this), delete i[this.key]
    }, t.prototype.disable = function() {
        return this.enabled = !1, this
    }, t.prototype.enable = function() {
        return this.context.refresh(), this.enabled = !0, this
    }, t.prototype.next = function() {
        return this.group.next(this)
    }, t.prototype.previous = function() {
        return this.group.previous(this)
    }, t.invokeAll = function(t) {
        var e = [];
        for (var n in i) e.push(i[n]);
        for (var r = 0, s = e.length; r < s; r++) e[r][t]()
    }, t.destroyAll = function() {
        t.invokeAll("destroy")
    }, t.disableAll = function() {
        t.invokeAll("disable")
    }, t.enableAll = function() {
        t.Context.refreshAll();
        for (var e in i) i[e].enabled = !0;
        return this
    }, t.refreshAll = function() {
        t.Context.refreshAll()
    }, t.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight
    }, t.viewportWidth = function() {
        return document.documentElement.clientWidth
    }, t.adapters = [], t.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, t.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }, window.Waypoint = t
}(),
function() {
    "use strict";

    function t(t) {
        window.setTimeout(t, 1e3 / 60)
    }

    function e(t) {
        this.element = t, this.Adapter = r.Adapter, this.adapter = new this.Adapter(t), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, t.waypointContextKey = this.key, n[t.waypointContextKey] = this, i += 1, r.windowContext || (r.windowContext = !0, r.windowContext = new e(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
    }
    var i = 0,
        n = {},
        r = window.Waypoint,
        s = window.onload;
    e.prototype.add = function(t) {
        var e = t.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[e][t.key] = t, this.refresh()
    }, e.prototype.checkEmpty = function() {
        var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            e = this.Adapter.isEmptyObject(this.waypoints.vertical),
            i = this.element == this.element.window;
        t && e && !i && (this.adapter.off(".waypoints"), delete n[this.key])
    }, e.prototype.createThrottledResizeHandler = function() {
        function t() {
            e.handleResize(), e.didResize = !1
        }
        var e = this;
        this.adapter.on("resize.waypoints", function() {
            e.didResize || (e.didResize = !0, r.requestAnimationFrame(t))
        })
    }, e.prototype.createThrottledScrollHandler = function() {
        function t() {
            e.handleScroll(), e.didScroll = !1
        }
        var e = this;
        this.adapter.on("scroll.waypoints", function() {
            e.didScroll && !r.isTouch || (e.didScroll = !0, r.requestAnimationFrame(t))
        })
    }, e.prototype.handleResize = function() {
        r.Context.refreshAll()
    }, e.prototype.handleScroll = function() {
        var t = {},
            e = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
        for (var i in e) {
            var n = e[i],
                r = n.newScroll > n.oldScroll,
                s = r ? n.forward : n.backward;
            for (var o in this.waypoints[i]) {
                var a = this.waypoints[i][o];
                if (null !== a.triggerPoint) {
                    var h = n.oldScroll < a.triggerPoint,
                        u = n.newScroll >= a.triggerPoint,
                        l = h && u,
                        c = !h && !u;
                    (l || c) && (a.queueTrigger(s), t[a.group.id] = a.group)
                }
            }
        }
        for (var d in t) t[d].flushTriggers();
        this.oldScroll = {
            x: e.horizontal.newScroll,
            y: e.vertical.newScroll
        }
    }, e.prototype.innerHeight = function() {
        return this.element == this.element.window ? r.viewportHeight() : this.adapter.innerHeight()
    }, e.prototype.remove = function(t) {
        delete this.waypoints[t.axis][t.key], this.checkEmpty()
    }, e.prototype.innerWidth = function() {
        return this.element == this.element.window ? r.viewportWidth() : this.adapter.innerWidth()
    }, e.prototype.destroy = function() {
        var t = [];
        for (var e in this.waypoints)
            for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
        for (var n = 0, r = t.length; n < r; n++) t[n].destroy()
    }, e.prototype.refresh = function() {
        var t, e = this.element == this.element.window,
            i = e ? void 0 : this.adapter.offset(),
            n = {};
        this.handleScroll(), t = {
            horizontal: {
                contextOffset: e ? 0 : i.left,
                contextScroll: e ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: e ? 0 : i.top,
                contextScroll: e ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        };
        for (var s in t) {
            var o = t[s];
            for (var a in this.waypoints[s]) {
                var h, u, l, c, d, f = this.waypoints[s][a],
                    g = f.options.offset,
                    p = f.triggerPoint,
                    v = 0,
                    _ = null == p;
                f.element !== f.element.window && (v = f.adapter.offset()[o.offsetProp]), "function" == typeof g ? g = g.apply(f) : "string" == typeof g && (g = parseFloat(g), f.options.offset.indexOf("%") > -1 && (g = Math.ceil(o.contextDimension * g / 100))), h = o.contextScroll - o.contextOffset, f.triggerPoint = Math.floor(v + h - g), u = p < o.oldScroll, l = f.triggerPoint >= o.oldScroll, c = u && l, d = !u && !l, !_ && c ? (f.queueTrigger(o.backward), n[f.group.id] = f.group) : !_ && d ? (f.queueTrigger(o.forward), n[f.group.id] = f.group) : _ && o.oldScroll >= f.triggerPoint && (f.queueTrigger(o.forward), n[f.group.id] = f.group)
            }
        }
        return r.requestAnimationFrame(function() {
            for (var t in n) n[t].flushTriggers()
        }), this
    }, e.findOrCreateByElement = function(t) {
        return e.findByElement(t) || new e(t)
    }, e.refreshAll = function() {
        for (var t in n) n[t].refresh()
    }, e.findByElement = function(t) {
        return n[t.waypointContextKey]
    }, window.onload = function() {
        s && s(), e.refreshAll()
    }, r.requestAnimationFrame = function(e) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t).call(window, e)
    }, r.Context = e
}(),
function() {
    "use strict";

    function t(t, e) {
        return t.triggerPoint - e.triggerPoint
    }

    function e(t, e) {
        return e.triggerPoint - t.triggerPoint
    }

    function i(t) {
        this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this
    }
    var n = {
            vertical: {},
            horizontal: {}
        },
        r = window.Waypoint;
    i.prototype.add = function(t) {
        this.waypoints.push(t)
    }, i.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }, i.prototype.flushTriggers = function() {
        for (var i in this.triggerQueues) {
            var n = this.triggerQueues[i],
                r = "up" === i || "left" === i;
            n.sort(r ? e : t);
            for (var s = 0, o = n.length; s < o; s += 1) {
                var a = n[s];
                (a.options.continuous || s === n.length - 1) && a.trigger([i])
            }
        }
        this.clearTriggerQueues()
    }, i.prototype.next = function(e) {
        this.waypoints.sort(t);
        var i = r.Adapter.inArray(e, this.waypoints);
        return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1]
    }, i.prototype.previous = function(e) {
        this.waypoints.sort(t);
        var i = r.Adapter.inArray(e, this.waypoints);
        return i ? this.waypoints[i - 1] : null
    }, i.prototype.queueTrigger = function(t, e) {
        this.triggerQueues[e].push(t)
    }, i.prototype.remove = function(t) {
        var e = r.Adapter.inArray(t, this.waypoints);
        e > -1 && this.waypoints.splice(e, 1)
    }, i.prototype.first = function() {
        return this.waypoints[0]
    }, i.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1]
    }, i.findOrCreate = function(t) {
        return n[t.axis][t.name] || new i(t)
    }, r.Group = i
}(),
function() {
    "use strict";

    function t(t) {
        return t === t.window
    }

    function e(e) {
        return t(e) ? e : e.defaultView
    }

    function i(t) {
        this.element = t, this.handlers = {}
    }
    var n = window.Waypoint;
    i.prototype.innerHeight = function() {
        return t(this.element) ? this.element.innerHeight : this.element.clientHeight
    }, i.prototype.innerWidth = function() {
        return t(this.element) ? this.element.innerWidth : this.element.clientWidth
    }, i.prototype.off = function(t, e) {
        function i(t, e, i) {
            for (var n = 0, r = e.length - 1; n < r; n++) {
                var s = e[n];
                i && i !== s || t.removeEventListener(s)
            }
        }
        var n = t.split("."),
            r = n[0],
            s = n[1],
            o = this.element;
        if (s && this.handlers[s] && r) i(o, this.handlers[s][r], e), this.handlers[s][r] = [];
        else if (r)
            for (var a in this.handlers) i(o, this.handlers[a][r] || [], e), this.handlers[a][r] = [];
        else if (s && this.handlers[s]) {
            for (var h in this.handlers[s]) i(o, this.handlers[s][h], e);
            this.handlers[s] = {}
        }
    }, i.prototype.offset = function() {
        if (!this.element.ownerDocument) return null;
        var t = this.element.ownerDocument.documentElement,
            i = e(this.element.ownerDocument),
            n = {
                top: 0,
                left: 0
            };
        return this.element.getBoundingClientRect && (n = this.element.getBoundingClientRect()), {
            top: n.top + i.pageYOffset - t.clientTop,
            left: n.left + i.pageXOffset - t.clientLeft
        }
    }, i.prototype.on = function(t, e) {
        var i = t.split("."),
            n = i[0],
            r = i[1] || "__default",
            s = this.handlers[r] = this.handlers[r] || {};
        (s[n] = s[n] || []).push(e), this.element.addEventListener(n, e)
    }, i.prototype.outerHeight = function(e) {
        var i, n = this.innerHeight();
        return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginTop, 10), n += parseInt(i.marginBottom, 10)), n
    }, i.prototype.outerWidth = function(e) {
        var i, n = this.innerWidth();
        return e && !t(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginLeft, 10), n += parseInt(i.marginRight, 10)), n
    }, i.prototype.scrollLeft = function() {
        var t = e(this.element);
        return t ? t.pageXOffset : this.element.scrollLeft
    }, i.prototype.scrollTop = function() {
        var t = e(this.element);
        return t ? t.pageYOffset : this.element.scrollTop
    }, i.extend = function() {
        for (var t = Array.prototype.slice.call(arguments), e = 1, i = t.length; e < i; e++) ! function(t, e) {
            if ("object" == typeof t && "object" == typeof e)
                for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        }(t[0], t[e]);
        return t[0]
    }, i.inArray = function(t, e, i) {
        return null == e ? -1 : e.indexOf(t, i)
    }, i.isEmptyObject = function(t) {
        for (var e in t) return !1;
        return !0
    }, n.adapters.push({
        name: "noframework",
        Adapter: i
    }), n.Adapter = i
}();
var paper = function(t, e) {
    t = t || require("./node/self.js");
    var i = t.window,
        n = t.document,
        r = new function() {
            function t(t, e, r, s, o) {
                function u(n, u) {
                    "string" == typeof(u = u || (u = a(e, n)) && (u.get ? u : u.value)) && "#" === u[0] && (u = t[u.substring(1)] || u);
                    var c, d = "function" == typeof u,
                        f = u,
                        g = o || d && !u.base ? u && u.get ? n in t : t[n] : null;
                    o && g || (d && g && (u.base = g), d && !1 !== s && (c = n.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (l[c[3].toLowerCase() + c[4]] = c[2]), f && !d && f.get && "function" == typeof f.get && i.isPlainObject(f) || (f = {
                        value: f,
                        writable: !0
                    }), (a(t, n) || {
                        configurable: !0
                    }).configurable && (f.configurable = !0, f.enumerable = null != r ? r : !c), h(t, n, f))
                }
                var l = {};
                if (e) {
                    for (var c in e) e.hasOwnProperty(c) && !n.test(c) && u(c);
                    for (var c in l) {
                        var d = l[c],
                            f = t["set" + d],
                            g = t["get" + d] || f && t["is" + d];
                        !g || !0 !== s && 0 !== g.length || u(c, {
                            get: g,
                            set: f
                        })
                    }
                }
                return t
            }

            function i() {
                for (var t = 0, e = arguments.length; t < e; t++) {
                    var i = arguments[t];
                    i && c(this, i)
                }
                return this
            }
            var n = /^(statics|enumerable|beans|preserve)$/,
                r = [],
                s = r.slice,
                o = Object.create,
                a = Object.getOwnPropertyDescriptor,
                h = Object.defineProperty,
                u = r.forEach || function(t, e) {
                    for (var i = 0, n = this.length; i < n; i++) t.call(e, this[i], i, this)
                },
                l = function(t, e) {
                    for (var i in this) this.hasOwnProperty(i) && t.call(e, this[i], i, this)
                },
                c = Object.assign || function(t) {
                    for (var e = 1, i = arguments.length; e < i; e++) {
                        var n = arguments[e];
                        for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r])
                    }
                    return t
                },
                d = function(t, e, i) {
                    if (t) {
                        var n = a(t, "length");
                        (n && "number" == typeof n.value ? u : l).call(t, e, i = i || t)
                    }
                    return i
                };
            return t(i, {
                inject: function(e) {
                    if (e) {
                        var i = !0 === e.statics ? e : e.statics,
                            n = e.beans,
                            r = e.preserve;
                        i !== e && t(this.prototype, e, e.enumerable, n, r), t(this, i, null, n, r)
                    }
                    for (var s = 1, o = arguments.length; s < o; s++) this.inject(arguments[s]);
                    return this
                },
                extend: function() {
                    for (var e, i, n, r = this, s = 0, a = arguments.length; s < a && (!e || !i); s++) n = arguments[s], e = e || n.initialize, i = i || n.prototype;
                    return e = e || function() {
                        r.apply(this, arguments)
                    }, i = e.prototype = i || o(this.prototype), h(i, "constructor", {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }), t(e, this), arguments.length && this.inject.apply(e, arguments), e.base = r, e
                }
            }).inject({
                enumerable: !1,
                initialize: i,
                set: i,
                inject: function() {
                    for (var e = 0, i = arguments.length; e < i; e++) {
                        var n = arguments[e];
                        n && t(this, n, n.enumerable, n.beans, n.preserve)
                    }
                    return this
                },
                extend: function() {
                    var t = o(this);
                    return t.inject.apply(t, arguments)
                },
                each: function(t, e) {
                    return d(this, t, e)
                },
                clone: function() {
                    return new this.constructor(this)
                },
                statics: {
                    set: c,
                    each: d,
                    create: o,
                    define: h,
                    describe: a,
                    clone: function(t) {
                        return c(new t.constructor, t)
                    },
                    isPlainObject: function(t) {
                        var e = null != t && t.constructor;
                        return e && (e === Object || e === i || "Object" === e.name)
                    },
                    pick: function(t, i) {
                        return t !== e ? t : i
                    },
                    slice: function(t, e, i) {
                        return s.call(t, e, i)
                    }
                }
            })
        };
    "undefined" != typeof module && (module.exports = r), r.inject({
        enumerable: !1,
        toString: function() {
            return null != this._id ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + r.each(this, function(t, e) {
                if (!/^_/.test(e)) {
                    var i = typeof t;
                    this.push(e + ": " + ("number" === i ? h.instance.number(t) : "string" === i ? "'" + t + "'" : t))
                }
            }, []).join(", ") + " }"
        },
        getClassName: function() {
            return this._class || ""
        },
        importJSON: function(t) {
            return r.importJSON(t, this)
        },
        exportJSON: function(t) {
            return r.exportJSON(this, t)
        },
        toJSON: function() {
            return r.serialize(this)
        },
        set: function(t, e) {
            return t && r.filter(this, t, e, this._prioritize), this
        }
    }, {
        beans: !1,
        statics: {
            exports: {},
            extend: function t() {
                var e = t.base.apply(this, arguments),
                    i = e.prototype._class;
                return i && !r.exports[i] && (r.exports[i] = e), e
            },
            equals: function(t, e) {
                if (t === e) return !0;
                if (t && t.equals) return t.equals(e);
                if (e && e.equals) return e.equals(t);
                if (t && e && "object" == typeof t && "object" == typeof e) {
                    if (Array.isArray(t) && Array.isArray(e)) {
                        var i = t.length;
                        if (i !== e.length) return !1;
                        for (; i--;)
                            if (!r.equals(t[i], e[i])) return !1
                    } else {
                        var n = Object.keys(t),
                            i = n.length;
                        if (i !== Object.keys(e).length) return !1;
                        for (; i--;) {
                            var s = n[i];
                            if (!e.hasOwnProperty(s) || !r.equals(t[s], e[s])) return !1
                        }
                    }
                    return !0
                }
                return !1
            },
            read: function(t, i, n, s) {
                if (this === r) {
                    var o = this.peek(t, i);
                    return t.__index++, o
                }
                var a = this.prototype,
                    h = a._readIndex,
                    u = i || h && t.__index || 0,
                    l = t.length,
                    c = t[u];
                if (s = s || l - u, c instanceof this || n && n.readNull && null == c && s <= 1) return h && (t.__index = u + 1), c && n && n.clone ? c.clone() : c;
                if (c = r.create(a), h && (c.__read = !0), c = c.initialize.apply(c, u > 0 || u + s < l ? r.slice(t, u, u + s) : t) || c, h) {
                    t.__index = u + c.__read;
                    var d = c.__filtered;
                    d && (t.__filtered = d, c.__filtered = e), c.__read = e
                }
                return c
            },
            peek: function(t, e) {
                return t[t.__index = e || t.__index || 0]
            },
            remain: function(t) {
                return t.length - (t.__index || 0)
            },
            readList: function(t, e, i, n) {
                for (var r, s = [], o = e || 0, a = n ? o + n : t.length, h = o; h < a; h++) s.push(Array.isArray(r = t[h]) ? this.read(r, 0, i) : this.read(t, h, i, 1));
                return s
            },
            readNamed: function(t, i, n, s, o) {
                var a = this.getNamed(t, i),
                    h = a !== e;
                if (h) {
                    var u = t.__filtered;
                    u || (u = t.__filtered = r.create(t[0]), u.__unfiltered = t[0]), u[i] = e
                }
                var l = h ? [a] : t;
                return this.read(l, n, s, o)
            },
            getNamed: function(t, i) {
                var n = t[0];
                if (t._hasObject === e && (t._hasObject = 1 === t.length && r.isPlainObject(n)), t._hasObject) return i ? n[i] : t.__filtered || n
            },
            hasNamed: function(t, e) {
                return !!this.getNamed(t, e)
            },
            filter: function(t, i, n, r) {
                function s(r) {
                    if (!(n && r in n || o && r in o)) {
                        var s = i[r];
                        s !== e && (t[r] = s)
                    }
                }
                var o;
                if (r) {
                    for (var a, h = {}, u = 0, l = r.length; u < l; u++)(a = r[u]) in i && (s(a), h[a] = !0);
                    o = h
                }
                return Object.keys(i.__unfiltered || i).forEach(s), t
            },
            isPlainValue: function(t, e) {
                return r.isPlainObject(t) || Array.isArray(t) || e && "string" == typeof t
            },
            serialize: function(t, e, i, n) {
                e = e || {};
                var s, o = !n;
                if (o && (e.formatter = new h(e.precision), n = {
                        length: 0,
                        definitions: {},
                        references: {},
                        add: function(t, e) {
                            var i = "#" + t._id,
                                n = this.references[i];
                            if (!n) {
                                this.length++;
                                var r = e.call(t),
                                    s = t._class;
                                s && r[0] !== s && r.unshift(s), this.definitions[i] = r, n = this.references[i] = [i]
                            }
                            return n
                        }
                    }), t && t._serialize) {
                    s = t._serialize(e, n);
                    var a = t._class;
                    !a || t._compactSerialize || !o && i || s[0] === a || s.unshift(a)
                } else if (Array.isArray(t)) {
                    s = [];
                    for (var u = 0, l = t.length; u < l; u++) s[u] = r.serialize(t[u], e, i, n)
                } else if (r.isPlainObject(t)) {
                    s = {};
                    for (var c = Object.keys(t), u = 0, l = c.length; u < l; u++) {
                        var d = c[u];
                        s[d] = r.serialize(t[d], e, i, n)
                    }
                } else s = "number" == typeof t ? e.formatter.number(t, e.precision) : t;
                return o && n.length > 0 ? [
                    ["dictionary", n.definitions], s
                ] : s
            },
            deserialize: function(t, e, i, n, s) {
                var o = t,
                    a = !i,
                    h = a && t && t.length && "dictionary" === t[0][0];
                if (i = i || {}, Array.isArray(t)) {
                    var u = t[0],
                        l = "dictionary" === u;
                    if (1 == t.length && /^#/.test(u)) return i.dictionary[u];
                    u = r.exports[u], o = [];
                    for (var c = u ? 1 : 0, d = t.length; c < d; c++) o.push(r.deserialize(t[c], e, i, l, h));
                    if (u) {
                        var f = o;
                        e ? o = e(u, f, a || s) : (o = r.create(u.prototype), u.apply(o, f))
                    }
                } else if (r.isPlainObject(t)) {
                    o = {}, n && (i.dictionary = o);
                    for (var g in t) o[g] = r.deserialize(t[g], e, i)
                }
                return h ? o[1] : o
            },
            exportJSON: function(t, e) {
                var i = r.serialize(t, e);
                return e && 0 == e.asString ? i : JSON.stringify(i)
            },
            importJSON: function(t, e) {
                return r.deserialize("string" == typeof t ? JSON.parse(t) : t, function(t, i, n) {
                    var s = n && e && e.constructor === t,
                        o = s ? e : r.create(t.prototype);
                    if (1 === i.length && o instanceof w && (s || !(o instanceof b))) {
                        var a = i[0];
                        r.isPlainObject(a) && (a.insert = !1)
                    }
                    return (s ? o.set : t).apply(o, i), s && (e = null), o
                })
            },
            splice: function(t, i, n, r) {
                var s = i && i.length,
                    o = n === e;
                (n = o ? t.length : n) > t.length && (n = t.length);
                for (var a = 0; a < s; a++) i[a]._index = n + a;
                if (o) return t.push.apply(t, i), [];
                var h = [n, r];
                i && h.push.apply(h, i);
                for (var u = t.splice.apply(t, h), a = 0, l = u.length; a < l; a++) u[a]._index = e;
                for (var a = n + s, l = t.length; a < l; a++) t[a]._index = a;
                return u
            },
            capitalize: function(t) {
                return t.replace(/\b[a-z]/g, function(t) {
                    return t.toUpperCase()
                })
            },
            camelize: function(t) {
                return t.replace(/-(.)/g, function(t, e) {
                    return e.toUpperCase()
                })
            },
            hyphenate: function(t) {
                return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
            }
        }
    });
    var s = {
            on: function(t, e) {
                if ("string" != typeof t) r.each(t, function(t, e) {
                    this.on(e, t)
                }, this);
                else {
                    var i = this._eventTypes,
                        n = i && i[t],
                        s = this._callbacks = this._callbacks || {};
                    s = s[t] = s[t] || [], -1 === s.indexOf(e) && (s.push(e), n && n.install && 1 === s.length && n.install.call(this, t))
                }
                return this
            },
            off: function(t, e) {
                if ("string" != typeof t) return void r.each(t, function(t, e) {
                    this.off(e, t)
                }, this);
                var i, n = this._eventTypes,
                    s = n && n[t],
                    o = this._callbacks && this._callbacks[t];
                return o && (!e || -1 !== (i = o.indexOf(e)) && 1 === o.length ? (s && s.uninstall && s.uninstall.call(this, t), delete this._callbacks[t]) : -1 !== i && o.splice(i, 1)), this
            },
            once: function(t, e) {
                return this.on(t, function() {
                    e.apply(this, arguments), this.off(t, e)
                })
            },
            emit: function(t, e) {
                var i = this._callbacks && this._callbacks[t];
                if (!i) return !1;
                var n = r.slice(arguments, 1),
                    s = e && e.target && !e.currentTarget;
                i = i.slice(), s && (e.currentTarget = this);
                for (var o = 0, a = i.length; o < a; o++)
                    if (0 == i[o].apply(this, n)) {
                        e && e.stop && e.stop();
                        break
                    }
                return s && delete e.currentTarget, !0
            },
            responds: function(t) {
                return !(!this._callbacks || !this._callbacks[t])
            },
            attach: "#on",
            detach: "#off",
            fire: "#emit",
            _installEvents: function(t) {
                var e = this._eventTypes,
                    i = this._callbacks,
                    n = t ? "install" : "uninstall";
                if (e)
                    for (var r in i)
                        if (i[r].length > 0) {
                            var s = e[r],
                                o = s && s[n];
                            o && o.call(this, r)
                        }
            },
            statics: {
                inject: function t(e) {
                    var i = e._events;
                    if (i) {
                        var n = {};
                        r.each(i, function(t, i) {
                            var s = "string" == typeof t,
                                o = s ? t : i,
                                a = r.capitalize(o),
                                h = o.substring(2).toLowerCase();
                            n[h] = s ? {} : t, o = "_" + o, e["get" + a] = function() {
                                return this[o]
                            }, e["set" + a] = function(t) {
                                var e = this[o];
                                e && this.off(h, e), t && this.on(h, t), this[o] = t
                            }
                        }), e._eventTypes = n
                    }
                    return t.base.apply(this, arguments)
                }
            }
        },
        o = r.extend({
            _class: "PaperScope",
            initialize: function e() {
                paper = this, this.settings = new r({
                    applyMatrix: !0,
                    insertItems: !0,
                    handleSize: 4,
                    hitTolerance: 0
                }), this.project = null, this.projects = [], this.tools = [], this._id = e._id++, e._scopes[this._id] = this;
                var i = e.prototype;
                if (!this.support) {
                    var n = tt.getContext(1, 1) || {};
                    i.support = {
                        nativeDash: "setLineDash" in n || "mozDash" in n,
                        nativeBlendModes: et.nativeModes
                    }, tt.release(n)
                }
                if (!this.agent) {
                    var s = t.navigator.userAgent.toLowerCase(),
                        o = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(s) || [])[0],
                        a = "darwin" === o ? "mac" : o,
                        h = i.agent = i.browser = {
                            platform: a
                        };
                    a && (h[a] = !0), s.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g, function(t, e, i, n, r) {
                        if (!h.chrome) {
                            var s = "opera" === e ? n : /^(node|trident)$/.test(e) ? r : i;
                            h.version = s, h.versionNumber = parseFloat(s), e = "trident" === e ? "msie" : e, h.name = e, h[e] = !0
                        }
                    }), h.chrome && delete h.webkit, h.atom && delete h.chrome
                }
            },
            version: "0.11.3",
            getView: function() {
                var t = this.project;
                return t && t._view
            },
            getPaper: function() {
                return this
            },
            execute: function(t, e) {
                paper.PaperScript.execute(t, this, e), U.updateFocus()
            },
            install: function(t) {
                var e = this;
                r.each(["project", "view", "tool"], function(i) {
                    r.define(t, i, {
                        configurable: !0,
                        get: function() {
                            return e[i]
                        }
                    })
                });
                for (var i in this) !/^_/.test(i) && this[i] && (t[i] = this[i])
            },
            setup: function(t) {
                return paper = this, this.project = new y(t), this
            },
            createCanvas: function(t, e) {
                return tt.getCanvas(t, e)
            },
            activate: function() {
                paper = this
            },
            clear: function() {
                for (var t = this.projects, e = this.tools, i = t.length - 1; i >= 0; i--) t[i].remove();
                for (var i = e.length - 1; i >= 0; i--) e[i].remove()
            },
            remove: function() {
                this.clear(), delete o._scopes[this._id]
            },
            statics: new function() {
                function t(t) {
                    return t += "Attribute",
                        function(e, i) {
                            return e[t](i) || e[t]("data-paper-" + i)
                        }
                }
                return {
                    _scopes: {},
                    _id: 0,
                    get: function(t) {
                        return this._scopes[t] || null
                    },
                    getAttribute: t("get"),
                    hasAttribute: t("has")
                }
            }
        }),
        a = r.extend(s, {
            initialize: function(t) {
                this._scope = paper, this._index = this._scope[this._list].push(this) - 1, !t && this._scope[this._reference] || this.activate()
            },
            activate: function() {
                if (!this._scope) return !1;
                var t = this._scope[this._reference];
                return t && t !== this && t.emit("deactivate"), this._scope[this._reference] = this, this.emit("activate", t), !0
            },
            isActive: function() {
                return this._scope[this._reference] === this
            },
            remove: function() {
                return null != this._index && (r.splice(this._scope[this._list], null, this._index, 1), this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, !0)
            },
            getView: function() {
                return this._scope.getView()
            }
        }),
        h = r.extend({
            initialize: function(t) {
                this.precision = r.pick(t, 5), this.multiplier = Math.pow(10, this.precision)
            },
            number: function(t) {
                return this.precision < 16 ? Math.round(t * this.multiplier) / this.multiplier : t
            },
            pair: function(t, e, i) {
                return this.number(t) + (i || ",") + this.number(e)
            },
            point: function(t, e) {
                return this.number(t.x) + (e || ",") + this.number(t.y)
            },
            size: function(t, e) {
                return this.number(t.width) + (e || ",") + this.number(t.height)
            },
            rectangle: function(t, e) {
                return this.point(t, e) + (e || ",") + this.size(t, e)
            }
        });
    h.instance = new h;
    var u = new function() {
            function t(t, e, i) {
                return t < e ? e : t > i ? i : t
            }

            function e(t, e, i) {
                function n(t) {
                    var e = 134217729 * t,
                        i = t - e,
                        n = i + e;
                    return [n, t - n]
                }
                var r = e * e - t * i,
                    o = e * e + t * i;
                if (3 * s(r) < o) {
                    var a = n(t),
                        h = n(e),
                        u = n(i),
                        l = e * e,
                        c = h[0] * h[0] - l + 2 * h[0] * h[1] + h[1] * h[1],
                        d = t * i;
                    r = l - d + (c - (a[0] * u[0] - d + a[0] * u[1] + a[1] * u[0] + a[1] * u[1]))
                }
                return r
            }

            function i() {
                var t = Math.max.apply(Math, arguments);
                return t && (t < 1e-8 || t > 1e8) ? a(2, -Math.round(h(t))) : 0
            }
            var n = [
                    [.5773502691896257],
                    [0, .7745966692414834],
                    [.33998104358485626, .8611363115940526],
                    [0, .5384693101056831, .906179845938664],
                    [.2386191860831969, .6612093864662645, .932469514203152],
                    [0, .4058451513773972, .7415311855993945, .9491079123427585],
                    [.1834346424956498, .525532409916329, .7966664774136267, .9602898564975363],
                    [0, .3242534234038089, .6133714327005904, .8360311073266358, .9681602395076261],
                    [.14887433898163122, .4333953941292472, .6794095682990244, .8650633666889845, .9739065285171717],
                    [0, .26954315595234496, .5190961292068118, .7301520055740494, .8870625997680953, .978228658146057],
                    [.1252334085114689, .3678314989981802, .5873179542866175, .7699026741943047, .9041172563704749, .9815606342467192],
                    [0, .2304583159551348, .44849275103644687, .6423493394403402, .8015780907333099, .9175983992229779, .9841830547185881],
                    [.10805494870734367, .31911236892788974, .5152486363581541, .6872929048116855, .827201315069765, .9284348836635735, .9862838086968123],
                    [0, .20119409399743451, .3941513470775634, .5709721726085388, .7244177313601701, .8482065834104272, .937273392400706, .9879925180204854],
                    [.09501250983763744, .2816035507792589, .45801677765722737, .6178762444026438, .755404408355003, .8656312023878318, .9445750230732326, .9894009349916499]
                ],
                r = [
                    [1],
                    [.8888888888888888, .5555555555555556],
                    [.6521451548625461, .34785484513745385],
                    [.5688888888888889, .47862867049936647, .23692688505618908],
                    [.46791393457269104, .3607615730481386, .17132449237917036],
                    [.4179591836734694, .3818300505051189, .27970539148927664, .1294849661688697],
                    [.362683783378362, .31370664587788727, .22238103445337448, .10122853629037626],
                    [.3302393550012598, .31234707704000286, .26061069640293544, .1806481606948574, .08127438836157441],
                    [.29552422471475287, .26926671930999635, .21908636251598204, .1494513491505806, .06667134430868814],
                    [.2729250867779006, .26280454451024665, .23319376459199048, .18629021092773426, .1255803694649046, .05566856711617366],
                    [.24914704581340277, .2334925365383548, .20316742672306592, .16007832854334622, .10693932599531843, .04717533638651183],
                    [.2325515532308739, .22628318026289723, .2078160475368885, .17814598076194574, .13887351021978725, .09212149983772845, .04048400476531588],
                    [.2152638534631578, .2051984637212956, .18553839747793782, .15720316715819355, .12151857068790319, .08015808715976021, .03511946033175186],
                    [.2025782419255613, .19843148532711158, .1861610000155622, .16626920581699392, .13957067792615432, .10715922046717194, .07036604748810812, .03075324199611727],
                    [.1894506104550685, .18260341504492358, .16915651939500254, .14959598881657674, .12462897125553388, .09515851168249279, .062253523938647894, .027152459411754096]
                ],
                s = Math.abs,
                o = Math.sqrt,
                a = Math.pow,
                h = Math.log2 || function(t) {
                    return Math.log(t) * Math.LOG2E
                };
            return {
                EPSILON: 1e-12,
                MACHINE_EPSILON: 1.12e-16,
                CURVETIME_EPSILON: 1e-8,
                GEOMETRIC_EPSILON: 1e-7,
                TRIGONOMETRIC_EPSILON: 1e-8,
                KAPPA: 4 * (o(2) - 1) / 3,
                isZero: function(t) {
                    return t >= -1e-12 && t <= 1e-12
                },
                clamp: t,
                integrate: function(t, e, i, s) {
                    for (var o = n[s - 2], a = r[s - 2], h = .5 * (i - e), u = h + e, l = 0, c = s + 1 >> 1, d = 1 & s ? a[l++] * t(u) : 0; l < c;) {
                        var f = h * o[l];
                        d += a[l++] * (t(u + f) + t(u - f))
                    }
                    return h * d
                },
                findRoot: function(e, i, n, r, o, a, h) {
                    for (var u = 0; u < a; u++) {
                        var l = e(n),
                            c = l / i(n),
                            d = n - c;
                        if (s(c) < h) {
                            n = d;
                            break
                        }
                        l > 0 ? (o = n, n = d <= r ? .5 * (r + o) : d) : (r = n, n = d >= o ? .5 * (r + o) : d)
                    }
                    return t(n, r, o)
                },
                solveQuadratic: function(n, r, a, h, u, l) {
                    var c, d = 1 / 0;
                    if (s(n) < 1e-12) {
                        if (s(r) < 1e-12) return s(a) < 1e-12 ? -1 : 0;
                        c = -a / r
                    } else {
                        r *= -.5;
                        var f = e(n, r, a);
                        if (f && s(f) < 1.12e-16) {
                            var g = i(s(n), s(r), s(a));
                            g && (n *= g, r *= g, a *= g, f = e(n, r, a))
                        }
                        if (f >= -1.12e-16) {
                            var p = f < 0 ? 0 : o(f),
                                v = r + (r < 0 ? -p : p);
                            0 === v ? (c = a / n, d = -c) : (c = v / n, d = a / v)
                        }
                    }
                    var _ = 0,
                        m = null == u,
                        y = u - 1e-12,
                        w = l + 1e-12;
                    return isFinite(c) && (m || c > y && c < w) && (h[_++] = m ? c : t(c, u, l)), d !== c && isFinite(d) && (m || d > y && d < w) && (h[_++] = m ? d : t(d, u, l)), _
                },
                solveCubic: function(e, n, r, h, l, c, d) {
                    function f(t) {
                        g = t;
                        var i = e * g;
                        p = i + n, v = p * g + r, _ = (i + p) * g + v, m = v * g + h
                    }
                    var g, p, v, _, m, y = i(s(e), s(n), s(r), s(h));
                    if (y && (e *= y, n *= y, r *= y, h *= y), s(e) < 1e-12) e = n, p = r, v = h, g = 1 / 0;
                    else if (s(h) < 1e-12) p = n, v = r, g = 0;
                    else {
                        f(-n / e / 3);
                        var w = m / e,
                            x = a(s(w), 1 / 3),
                            b = w < 0 ? -1 : 1,
                            S = -_ / e,
                            C = S > 0 ? 1.324717957244746 * Math.max(x, o(S)) : x,
                            T = g - b * C;
                        if (T !== g) {
                            do {
                                f(T), T = 0 === _ ? g : g - m / _ / (1 + 1.12e-16)
                            } while (b * T > b * g);
                            s(e) * g * g > s(h / g) && (v = -h / g, p = (v - r) / g)
                        }
                    }
                    var E = u.solveQuadratic(e, p, v, l, c, d),
                        z = null == c;
                    return isFinite(g) && (0 === E || E > 0 && g !== l[0] && g !== l[1]) && (z || g > c - 1e-12 && g < d + 1e-12) && (l[E++] = z ? g : t(g, c, d)), E
                }
            }
        },
        l = {
            _id: 1,
            _pools: {},
            get: function(t) {
                if (t) {
                    var e = this._pools[t];
                    return e || (e = this._pools[t] = {
                        _id: 1
                    }), e._id++
                }
                return this._id++
            }
        },
        c = r.extend({
            _class: "Point",
            _readIndex: !0,
            initialize: function(t, e) {
                var i = typeof t,
                    n = this.__read,
                    r = 0;
                if ("number" === i) {
                    var s = "number" == typeof e;
                    this._set(t, s ? e : t), n && (r = s ? 2 : 1)
                } else if ("undefined" === i || null === t) this._set(0, 0), n && (r = null === t ? 1 : 0);
                else {
                    var o = "string" === i ? t.split(/[\s,]+/) || [] : t;
                    r = 1, Array.isArray(o) ? this._set(+o[0], +(o.length > 1 ? o[1] : o[0])) : "x" in o ? this._set(o.x || 0, o.y || 0) : "width" in o ? this._set(o.width || 0, o.height || 0) : "angle" in o ? (this._set(o.length || 0, 0), this.setAngle(o.angle || 0)) : (this._set(0, 0), r = 0)
                }
                return n && (this.__read = r), this
            },
            set: "#initialize",
            _set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            equals: function(t) {
                return this === t || t && (this.x === t.x && this.y === t.y || Array.isArray(t) && this.x === t[0] && this.y === t[1]) || !1
            },
            clone: function() {
                return new c(this.x, this.y)
            },
            toString: function() {
                var t = h.instance;
                return "{ x: " + t.number(this.x) + ", y: " + t.number(this.y) + " }"
            },
            _serialize: function(t) {
                var e = t.formatter;
                return [e.number(this.x), e.number(this.y)]
            },
            getLength: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            setLength: function(t) {
                if (this.isZero()) {
                    var e = this._angle || 0;
                    this._set(Math.cos(e) * t, Math.sin(e) * t)
                } else {
                    var i = t / this.getLength();
                    u.isZero(i) && this.getAngle(), this._set(this.x * i, this.y * i)
                }
            },
            getAngle: function() {
                return 180 * this.getAngleInRadians.apply(this, arguments) / Math.PI
            },
            setAngle: function(t) {
                this.setAngleInRadians.call(this, t * Math.PI / 180)
            },
            getAngleInDegrees: "#getAngle",
            setAngleInDegrees: "#setAngle",
            getAngleInRadians: function() {
                if (arguments.length) {
                    var t = c.read(arguments),
                        e = this.getLength() * t.getLength();
                    if (u.isZero(e)) return NaN;
                    var i = this.dot(t) / e;
                    return Math.acos(i < -1 ? -1 : i > 1 ? 1 : i)
                }
                return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x)
            },
            setAngleInRadians: function(t) {
                if (this._angle = t, !this.isZero()) {
                    var e = this.getLength();
                    this._set(Math.cos(t) * e, Math.sin(t) * e)
                }
            },
            getQuadrant: function() {
                return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3
            }
        }, {
            beans: !1,
            getDirectedAngle: function() {
                var t = c.read(arguments);
                return 180 * Math.atan2(this.cross(t), this.dot(t)) / Math.PI
            },
            getDistance: function() {
                var t = c.read(arguments),
                    e = t.x - this.x,
                    i = t.y - this.y,
                    n = e * e + i * i;
                return r.read(arguments) ? n : Math.sqrt(n)
            },
            normalize: function(t) {
                t === e && (t = 1);
                var i = this.getLength(),
                    n = 0 !== i ? t / i : 0,
                    r = new c(this.x * n, this.y * n);
                return n >= 0 && (r._angle = this._angle), r
            },
            rotate: function(t, e) {
                if (0 === t) return this.clone();
                t = t * Math.PI / 180;
                var i = e ? this.subtract(e) : this,
                    n = Math.sin(t),
                    r = Math.cos(t);
                return i = new c(i.x * r - i.y * n, i.x * n + i.y * r), e ? i.add(e) : i
            },
            transform: function(t) {
                return t ? t._transformPoint(this) : this
            },
            add: function() {
                var t = c.read(arguments);
                return new c(this.x + t.x, this.y + t.y)
            },
            subtract: function() {
                var t = c.read(arguments);
                return new c(this.x - t.x, this.y - t.y)
            },
            multiply: function() {
                var t = c.read(arguments);
                return new c(this.x * t.x, this.y * t.y)
            },
            divide: function() {
                var t = c.read(arguments);
                return new c(this.x / t.x, this.y / t.y)
            },
            modulo: function() {
                var t = c.read(arguments);
                return new c(this.x % t.x, this.y % t.y)
            },
            negate: function() {
                return new c(-this.x, -this.y)
            },
            isInside: function() {
                return p.read(arguments).contains(this)
            },
            isClose: function() {
                var t = c.read(arguments),
                    e = r.read(arguments);
                return this.getDistance(t) <= e
            },
            isCollinear: function() {
                var t = c.read(arguments);
                return c.isCollinear(this.x, this.y, t.x, t.y)
            },
            isColinear: "#isCollinear",
            isOrthogonal: function() {
                var t = c.read(arguments);
                return c.isOrthogonal(this.x, this.y, t.x, t.y)
            },
            isZero: function() {
                var t = u.isZero;
                return t(this.x) && t(this.y)
            },
            isNaN: function() {
                return isNaN(this.x) || isNaN(this.y)
            },
            isInQuadrant: function(t) {
                return this.x * (t > 1 && t < 4 ? -1 : 1) >= 0 && this.y * (t > 2 ? -1 : 1) >= 0
            },
            dot: function() {
                var t = c.read(arguments);
                return this.x * t.x + this.y * t.y
            },
            cross: function() {
                var t = c.read(arguments);
                return this.x * t.y - this.y * t.x
            },
            project: function() {
                var t = c.read(arguments),
                    e = t.isZero() ? 0 : this.dot(t) / t.dot(t);
                return new c(t.x * e, t.y * e)
            },
            statics: {
                min: function() {
                    var t = c.read(arguments),
                        e = c.read(arguments);
                    return new c(Math.min(t.x, e.x), Math.min(t.y, e.y))
                },
                max: function() {
                    var t = c.read(arguments),
                        e = c.read(arguments);
                    return new c(Math.max(t.x, e.x), Math.max(t.y, e.y))
                },
                random: function() {
                    return new c(Math.random(), Math.random())
                },
                isCollinear: function(t, e, i, n) {
                    return Math.abs(t * n - e * i) <= 1e-8 * Math.sqrt((t * t + e * e) * (i * i + n * n))
                },
                isOrthogonal: function(t, e, i, n) {
                    return Math.abs(t * i + e * n) <= 1e-8 * Math.sqrt((t * t + e * e) * (i * i + n * n))
                }
            }
        }, r.each(["round", "ceil", "floor", "abs"], function(t) {
            var e = Math[t];
            this[t] = function() {
                return new c(e(this.x), e(this.y))
            }
        }, {})),
        d = c.extend({
            initialize: function(t, e, i, n) {
                this._x = t, this._y = e, this._owner = i, this._setter = n
            },
            _set: function(t, e, i) {
                return this._x = t, this._y = e, i || this._owner[this._setter](this), this
            },
            getX: function() {
                return this._x
            },
            setX: function(t) {
                this._x = t, this._owner[this._setter](this)
            },
            getY: function() {
                return this._y
            },
            setY: function(t) {
                this._y = t, this._owner[this._setter](this)
            },
            isSelected: function() {
                return !!(this._owner._selection & this._getSelection())
            },
            setSelected: function(t) {
                this._owner.changeSelection(this._getSelection(), t)
            },
            _getSelection: function() {
                return "setPosition" === this._setter ? 4 : 0
            }
        }),
        f = r.extend({
            _class: "Size",
            _readIndex: !0,
            initialize: function(t, e) {
                var i = typeof t,
                    n = this.__read,
                    r = 0;
                if ("number" === i) {
                    var s = "number" == typeof e;
                    this._set(t, s ? e : t), n && (r = s ? 2 : 1)
                } else if ("undefined" === i || null === t) this._set(0, 0), n && (r = null === t ? 1 : 0);
                else {
                    var o = "string" === i ? t.split(/[\s,]+/) || [] : t;
                    r = 1, Array.isArray(o) ? this._set(+o[0], +(o.length > 1 ? o[1] : o[0])) : "width" in o ? this._set(o.width || 0, o.height || 0) : "x" in o ? this._set(o.x || 0, o.y || 0) : (this._set(0, 0), r = 0)
                }
                return n && (this.__read = r), this
            },
            set: "#initialize",
            _set: function(t, e) {
                return this.width = t, this.height = e, this
            },
            equals: function(t) {
                return t === this || t && (this.width === t.width && this.height === t.height || Array.isArray(t) && this.width === t[0] && this.height === t[1]) || !1
            },
            clone: function() {
                return new f(this.width, this.height)
            },
            toString: function() {
                var t = h.instance;
                return "{ width: " + t.number(this.width) + ", height: " + t.number(this.height) + " }"
            },
            _serialize: function(t) {
                var e = t.formatter;
                return [e.number(this.width), e.number(this.height)]
            },
            add: function() {
                var t = f.read(arguments);
                return new f(this.width + t.width, this.height + t.height)
            },
            subtract: function() {
                var t = f.read(arguments);
                return new f(this.width - t.width, this.height - t.height)
            },
            multiply: function() {
                var t = f.read(arguments);
                return new f(this.width * t.width, this.height * t.height)
            },
            divide: function() {
                var t = f.read(arguments);
                return new f(this.width / t.width, this.height / t.height)
            },
            modulo: function() {
                var t = f.read(arguments);
                return new f(this.width % t.width, this.height % t.height)
            },
            negate: function() {
                return new f(-this.width, -this.height)
            },
            isZero: function() {
                var t = u.isZero;
                return t(this.width) && t(this.height)
            },
            isNaN: function() {
                return isNaN(this.width) || isNaN(this.height)
            },
            statics: {
                min: function(t, e) {
                    return new f(Math.min(t.width, e.width), Math.min(t.height, e.height))
                },
                max: function(t, e) {
                    return new f(Math.max(t.width, e.width), Math.max(t.height, e.height))
                },
                random: function() {
                    return new f(Math.random(), Math.random())
                }
            }
        }, r.each(["round", "ceil", "floor", "abs"], function(t) {
            var e = Math[t];
            this[t] = function() {
                return new f(e(this.width), e(this.height))
            }
        }, {})),
        g = f.extend({
            initialize: function(t, e, i, n) {
                this._width = t, this._height = e, this._owner = i, this._setter = n
            },
            _set: function(t, e, i) {
                return this._width = t, this._height = e, i || this._owner[this._setter](this), this
            },
            getWidth: function() {
                return this._width
            },
            setWidth: function(t) {
                this._width = t, this._owner[this._setter](this)
            },
            getHeight: function() {
                return this._height
            },
            setHeight: function(t) {
                this._height = t, this._owner[this._setter](this)
            }
        }),
        p = r.extend({
            _class: "Rectangle",
            _readIndex: !0,
            beans: !0,
            initialize: function(t, i, n, s) {
                var o, a = typeof t;
                if ("number" === a ? (this._set(t, i, n, s), o = 4) : "undefined" === a || null === t ? (this._set(0, 0, 0, 0), o = null === t ? 1 : 0) : 1 === arguments.length && (Array.isArray(t) ? (this._set.apply(this, t), o = 1) : t.x !== e || t.width !== e ? (this._set(t.x || 0, t.y || 0, t.width || 0, t.height || 0), o = 1) : t.from === e && t.to === e && (this._set(0, 0, 0, 0), r.filter(this, t), o = 1)), o === e) {
                    var h, u, l = c.readNamed(arguments, "from"),
                        d = r.peek(arguments),
                        g = l.x,
                        p = l.y;
                    if (d && d.x !== e || r.hasNamed(arguments, "to")) {
                        var v = c.readNamed(arguments, "to");
                        h = v.x - g, u = v.y - p, h < 0 && (g = v.x, h = -h), u < 0 && (p = v.y, u = -u)
                    } else {
                        var _ = f.read(arguments);
                        h = _.width, u = _.height
                    }
                    this._set(g, p, h, u), o = arguments.__index;
                    var m = arguments.__filtered;
                    m && (this.__filtered = m)
                }
                return this.__read && (this.__read = o), this
            },
            set: "#initialize",
            _set: function(t, e, i, n) {
                return this.x = t, this.y = e, this.width = i, this.height = n, this
            },
            clone: function() {
                return new p(this.x, this.y, this.width, this.height)
            },
            equals: function(t) {
                var e = r.isPlainValue(t) ? p.read(arguments) : t;
                return e === this || e && this.x === e.x && this.y === e.y && this.width === e.width && this.height === e.height || !1
            },
            toString: function() {
                var t = h.instance;
                return "{ x: " + t.number(this.x) + ", y: " + t.number(this.y) + ", width: " + t.number(this.width) + ", height: " + t.number(this.height) + " }"
            },
            _serialize: function(t) {
                var e = t.formatter;
                return [e.number(this.x), e.number(this.y), e.number(this.width), e.number(this.height)]
            },
            getPoint: function(t) {
                return new(t ? c : d)(this.x, this.y, this, "setPoint")
            },
            setPoint: function() {
                var t = c.read(arguments);
                this.x = t.x, this.y = t.y
            },
            getSize: function(t) {
                return new(t ? f : g)(this.width, this.height, this, "setSize")
            },
            _fw: 1,
            _fh: 1,
            setSize: function() {
                var t = f.read(arguments),
                    e = this._sx,
                    i = this._sy,
                    n = t.width,
                    r = t.height;
                e && (this.x += (this.width - n) * e), i && (this.y += (this.height - r) * i), this.width = n, this.height = r, this._fw = this._fh = 1
            },
            getLeft: function() {
                return this.x
            },
            setLeft: function(t) {
                if (!this._fw) {
                    var e = t - this.x;
                    this.width -= .5 === this._sx ? 2 * e : e
                }
                this.x = t, this._sx = this._fw = 0
            },
            getTop: function() {
                return this.y
            },
            setTop: function(t) {
                if (!this._fh) {
                    var e = t - this.y;
                    this.height -= .5 === this._sy ? 2 * e : e
                }
                this.y = t, this._sy = this._fh = 0
            },
            getRight: function() {
                return this.x + this.width
            },
            setRight: function(t) {
                if (!this._fw) {
                    var e = t - this.x;
                    this.width = .5 === this._sx ? 2 * e : e
                }
                this.x = t - this.width, this._sx = 1, this._fw = 0
            },
            getBottom: function() {
                return this.y + this.height
            },
            setBottom: function(t) {
                if (!this._fh) {
                    var e = t - this.y;
                    this.height = .5 === this._sy ? 2 * e : e
                }
                this.y = t - this.height, this._sy = 1, this._fh = 0
            },
            getCenterX: function() {
                return this.x + this.width / 2
            },
            setCenterX: function(t) {
                this._fw || .5 === this._sx ? this.x = t - this.width / 2 : (this._sx && (this.x += 2 * (t - this.x) * this._sx), this.width = 2 * (t - this.x)), this._sx = .5, this._fw = 0
            },
            getCenterY: function() {
                return this.y + this.height / 2
            },
            setCenterY: function(t) {
                this._fh || .5 === this._sy ? this.y = t - this.height / 2 : (this._sy && (this.y += 2 * (t - this.y) * this._sy), this.height = 2 * (t - this.y)), this._sy = .5, this._fh = 0
            },
            getCenter: function(t) {
                return new(t ? c : d)(this.getCenterX(), this.getCenterY(), this, "setCenter")
            },
            setCenter: function() {
                var t = c.read(arguments);
                return this.setCenterX(t.x), this.setCenterY(t.y), this
            },
            getArea: function() {
                return this.width * this.height
            },
            isEmpty: function() {
                return 0 === this.width || 0 === this.height
            },
            contains: function(t) {
                return t && t.width !== e || 4 === (Array.isArray(t) ? t : arguments).length ? this._containsRectangle(p.read(arguments)) : this._containsPoint(c.read(arguments))
            },
            _containsPoint: function(t) {
                var e = t.x,
                    i = t.y;
                return e >= this.x && i >= this.y && e <= this.x + this.width && i <= this.y + this.height
            },
            _containsRectangle: function(t) {
                var e = t.x,
                    i = t.y;
                return e >= this.x && i >= this.y && e + t.width <= this.x + this.width && i + t.height <= this.y + this.height
            },
            intersects: function() {
                var t = p.read(arguments),
                    e = r.read(arguments) || 0;
                return t.x + t.width > this.x - e && t.y + t.height > this.y - e && t.x < this.x + this.width + e && t.y < this.y + this.height + e
            },
            intersect: function() {
                var t = p.read(arguments),
                    e = Math.max(this.x, t.x),
                    i = Math.max(this.y, t.y),
                    n = Math.min(this.x + this.width, t.x + t.width),
                    r = Math.min(this.y + this.height, t.y + t.height);
                return new p(e, i, n - e, r - i)
            },
            unite: function() {
                var t = p.read(arguments),
                    e = Math.min(this.x, t.x),
                    i = Math.min(this.y, t.y),
                    n = Math.max(this.x + this.width, t.x + t.width),
                    r = Math.max(this.y + this.height, t.y + t.height);
                return new p(e, i, n - e, r - i)
            },
            include: function() {
                var t = c.read(arguments),
                    e = Math.min(this.x, t.x),
                    i = Math.min(this.y, t.y),
                    n = Math.max(this.x + this.width, t.x),
                    r = Math.max(this.y + this.height, t.y);
                return new p(e, i, n - e, r - i)
            },
            expand: function() {
                var t = f.read(arguments),
                    e = t.width,
                    i = t.height;
                return new p(this.x - e / 2, this.y - i / 2, this.width + e, this.height + i)
            },
            scale: function(t, i) {
                return this.expand(this.width * t - this.width, this.height * (i === e ? t : i) - this.height)
            }
        }, r.each([
            ["Top", "Left"],
            ["Top", "Right"],
            ["Bottom", "Left"],
            ["Bottom", "Right"],
            ["Left", "Center"],
            ["Top", "Center"],
            ["Right", "Center"],
            ["Bottom", "Center"]
        ], function(t, e) {
            var i = t.join(""),
                n = /^[RL]/.test(i);
            e >= 4 && (t[1] += n ? "Y" : "X");
            var r = t[n ? 0 : 1],
                s = t[n ? 1 : 0],
                o = "get" + r,
                a = "get" + s,
                h = "set" + r,
                u = "set" + s,
                l = "get" + i,
                f = "set" + i;
            this[l] = function(t) {
                return new(t ? c : d)(this[o](), this[a](), this, f)
            }, this[f] = function() {
                var t = c.read(arguments);
                this[h](t.x), this[u](t.y)
            }
        }, {
            beans: !0
        })),
        v = p.extend({
            initialize: function(t, e, i, n, r, s) {
                this._set(t, e, i, n, !0), this._owner = r, this._setter = s
            },
            _set: function(t, e, i, n, r) {
                return this._x = t, this._y = e, this._width = i, this._height = n, r || this._owner[this._setter](this), this
            }
        }, new function() {
            var t = p.prototype;
            return r.each(["x", "y", "width", "height"], function(t) {
                var e = r.capitalize(t),
                    i = "_" + t;
                this["get" + e] = function() {
                    return this[i]
                }, this["set" + e] = function(t) {
                    this[i] = t, this._dontNotify || this._owner[this._setter](this)
                }
            }, r.each(["Point", "Size", "Center", "Left", "Top", "Right", "Bottom", "CenterX", "CenterY", "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter"], function(e) {
                var i = "set" + e;
                this[i] = function() {
                    this._dontNotify = !0, t[i].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this)
                }
            }, {
                isSelected: function() {
                    return !!(2 & this._owner._selection)
                },
                setSelected: function(t) {
                    var e = this._owner;
                    e.changeSelection && e.changeSelection(2, t)
                }
            }))
        }),
        _ = r.extend({
            _class: "Matrix",
            initialize: function t(e, i) {
                var n = arguments.length,
                    r = !0;
                if (n >= 6 ? this._set.apply(this, arguments) : 1 === n || 2 === n ? e instanceof t ? this._set(e._a, e._b, e._c, e._d, e._tx, e._ty, i) : Array.isArray(e) ? this._set.apply(this, i ? e.concat([i]) : e) : r = !1 : n ? r = !1 : this.reset(), !r) throw new Error("Unsupported matrix parameters");
                return this
            },
            set: "#initialize",
            _set: function(t, e, i, n, r, s, o) {
                return this._a = t, this._b = e, this._c = i, this._d = n, this._tx = r, this._ty = s, o || this._changed(), this
            },
            _serialize: function(t, e) {
                return r.serialize(this.getValues(), t, !0, e)
            },
            _changed: function() {
                var t = this._owner;
                t && (t._applyMatrix ? t.transform(null, !0) : t._changed(9))
            },
            clone: function() {
                return new _(this._a, this._b, this._c, this._d, this._tx, this._ty)
            },
            equals: function(t) {
                return t === this || t && this._a === t._a && this._b === t._b && this._c === t._c && this._d === t._d && this._tx === t._tx && this._ty === t._ty
            },
            toString: function() {
                var t = h.instance;
                return "[[" + [t.number(this._a), t.number(this._c), t.number(this._tx)].join(", ") + "], [" + [t.number(this._b), t.number(this._d), t.number(this._ty)].join(", ") + "]]"
            },
            reset: function(t) {
                return this._a = this._d = 1, this._b = this._c = this._tx = this._ty = 0, t || this._changed(), this
            },
            apply: function(t, e) {
                var i = this._owner;
                return !!i && (i.transform(null, !0, r.pick(t, !0), e), this.isIdentity())
            },
            translate: function() {
                var t = c.read(arguments),
                    e = t.x,
                    i = t.y;
                return this._tx += e * this._a + i * this._c, this._ty += e * this._b + i * this._d, this._changed(), this
            },
            scale: function() {
                var t = c.read(arguments),
                    e = c.read(arguments, 0, {
                        readNull: !0
                    });
                return e && this.translate(e), this._a *= t.x, this._b *= t.x, this._c *= t.y, this._d *= t.y, e && this.translate(e.negate()), this._changed(), this
            },
            rotate: function(t) {
                t *= Math.PI / 180;
                var e = c.read(arguments, 1),
                    i = e.x,
                    n = e.y,
                    r = Math.cos(t),
                    s = Math.sin(t),
                    o = i - i * r + n * s,
                    a = n - i * s - n * r,
                    h = this._a,
                    u = this._b,
                    l = this._c,
                    d = this._d;
                return this._a = r * h + s * l, this._b = r * u + s * d, this._c = -s * h + r * l, this._d = -s * u + r * d, this._tx += o * h + a * l, this._ty += o * u + a * d, this._changed(), this
            },
            shear: function() {
                var t = c.read(arguments),
                    e = c.read(arguments, 0, {
                        readNull: !0
                    });
                e && this.translate(e);
                var i = this._a,
                    n = this._b;
                return this._a += t.y * this._c, this._b += t.y * this._d, this._c += t.x * i, this._d += t.x * n, e && this.translate(e.negate()), this._changed(), this
            },
            skew: function() {
                var t = c.read(arguments),
                    e = c.read(arguments, 0, {
                        readNull: !0
                    }),
                    i = Math.PI / 180,
                    n = new c(Math.tan(t.x * i), Math.tan(t.y * i));
                return this.shear(n, e)
            },
            append: function(t, e) {
                if (t) {
                    var i = this._a,
                        n = this._b,
                        r = this._c,
                        s = this._d,
                        o = t._a,
                        a = t._c,
                        h = t._b,
                        u = t._d,
                        l = t._tx,
                        c = t._ty;
                    this._a = o * i + h * r, this._c = a * i + u * r, this._b = o * n + h * s, this._d = a * n + u * s, this._tx += l * i + c * r, this._ty += l * n + c * s, e || this._changed()
                }
                return this
            },
            prepend: function(t, e) {
                if (t) {
                    var i = this._a,
                        n = this._b,
                        r = this._c,
                        s = this._d,
                        o = this._tx,
                        a = this._ty,
                        h = t._a,
                        u = t._c,
                        l = t._b,
                        c = t._d,
                        d = t._tx,
                        f = t._ty;
                    this._a = h * i + u * n, this._c = h * r + u * s, this._b = l * i + c * n, this._d = l * r + c * s, this._tx = h * o + u * a + d, this._ty = l * o + c * a + f, e || this._changed()
                }
                return this
            },
            appended: function(t) {
                return this.clone().append(t)
            },
            prepended: function(t) {
                return this.clone().prepend(t)
            },
            invert: function() {
                var t = this._a,
                    e = this._b,
                    i = this._c,
                    n = this._d,
                    r = this._tx,
                    s = this._ty,
                    o = t * n - e * i,
                    a = null;
                return o && !isNaN(o) && isFinite(r) && isFinite(s) && (this._a = n / o, this._b = -e / o, this._c = -i / o, this._d = t / o, this._tx = (i * s - n * r) / o, this._ty = (e * r - t * s) / o, a = this), a
            },
            inverted: function() {
                return this.clone().invert()
            },
            concatenate: "#append",
            preConcatenate: "#prepend",
            chain: "#appended",
            _shiftless: function() {
                return new _(this._a, this._b, this._c, this._d, 0, 0)
            },
            _orNullIfIdentity: function() {
                return this.isIdentity() ? null : this
            },
            isIdentity: function() {
                return 1 === this._a && 0 === this._b && 0 === this._c && 1 === this._d && 0 === this._tx && 0 === this._ty
            },
            isInvertible: function() {
                var t = this._a * this._d - this._c * this._b;
                return t && !isNaN(t) && isFinite(this._tx) && isFinite(this._ty)
            },
            isSingular: function() {
                return !this.isInvertible()
            },
            transform: function(t, e, i) {
                return arguments.length < 3 ? this._transformPoint(c.read(arguments)) : this._transformCoordinates(t, e, i)
            },
            _transformPoint: function(t, e, i) {
                var n = t.x,
                    r = t.y;
                return e || (e = new c), e._set(n * this._a + r * this._c + this._tx, n * this._b + r * this._d + this._ty, i)
            },
            _transformCoordinates: function(t, e, i) {
                for (var n = 0, r = 2 * i; n < r; n += 2) {
                    var s = t[n],
                        o = t[n + 1];
                    e[n] = s * this._a + o * this._c + this._tx, e[n + 1] = s * this._b + o * this._d + this._ty
                }
                return e
            },
            _transformCorners: function(t) {
                var e = t.x,
                    i = t.y,
                    n = e + t.width,
                    r = i + t.height,
                    s = [e, i, n, i, n, r, e, r];
                return this._transformCoordinates(s, s, 4)
            },
            _transformBounds: function(t, e, i) {
                for (var n = this._transformCorners(t), r = n.slice(0, 2), s = r.slice(), o = 2; o < 8; o++) {
                    var a = n[o],
                        h = 1 & o;
                    a < r[h] ? r[h] = a : a > s[h] && (s[h] = a)
                }
                return e || (e = new p), e._set(r[0], r[1], s[0] - r[0], s[1] - r[1], i)
            },
            inverseTransform: function() {
                return this._inverseTransform(c.read(arguments))
            },
            _inverseTransform: function(t, e, i) {
                var n = this._a,
                    r = this._b,
                    s = this._c,
                    o = this._d,
                    a = this._tx,
                    h = this._ty,
                    u = n * o - r * s,
                    l = null;
                if (u && !isNaN(u) && isFinite(a) && isFinite(h)) {
                    var d = t.x - this._tx,
                        f = t.y - this._ty;
                    e || (e = new c), l = e._set((d * o - f * s) / u, (f * n - d * r) / u, i)
                }
                return l
            },
            decompose: function() {
                var t, e, i, n = this._a,
                    r = this._b,
                    s = this._c,
                    o = this._d,
                    a = n * o - r * s,
                    h = Math.sqrt,
                    u = Math.atan2,
                    l = 180 / Math.PI;
                if (0 !== n || 0 !== r) {
                    var d = h(n * n + r * r);
                    t = Math.acos(n / d) * (r > 0 ? 1 : -1), e = [d, a / d], i = [u(n * s + r * o, d * d), 0]
                } else if (0 !== s || 0 !== o) {
                    var f = h(s * s + o * o);
                    t = Math.asin(s / f) * (o > 0 ? 1 : -1), e = [a / f, f], i = [0, u(n * s + r * o, f * f)]
                } else t = 0, i = e = [0, 0];
                return {
                    translation: this.getTranslation(),
                    rotation: t * l,
                    scaling: new c(e),
                    skewing: new c(i[0] * l, i[1] * l)
                }
            },
            getValues: function() {
                return [this._a, this._b, this._c, this._d, this._tx, this._ty]
            },
            getTranslation: function() {
                return new c(this._tx, this._ty)
            },
            getScaling: function() {
                return (this.decompose() || {}).scaling
            },
            getRotation: function() {
                return (this.decompose() || {}).rotation
            },
            applyToContext: function(t) {
                this.isIdentity() || t.transform(this._a, this._b, this._c, this._d, this._tx, this._ty)
            }
        }, r.each(["a", "b", "c", "d", "tx", "ty"], function(t) {
            var e = r.capitalize(t),
                i = "_" + t;
            this["get" + e] = function() {
                return this[i]
            }, this["set" + e] = function(t) {
                this[i] = t, this._changed()
            }
        }, {})),
        m = r.extend({
            _class: "Line",
            initialize: function(t, e, i, n, r) {
                var s = !1;
                arguments.length >= 4 ? (this._px = t, this._py = e, this._vx = i, this._vy = n, s = r) : (this._px = t.x, this._py = t.y, this._vx = e.x, this._vy = e.y, s = i), s || (this._vx -= this._px, this._vy -= this._py)
            },
            getPoint: function() {
                return new c(this._px, this._py)
            },
            getVector: function() {
                return new c(this._vx, this._vy)
            },
            getLength: function() {
                return this.getVector().getLength()
            },
            intersect: function(t, e) {
                return m.intersect(this._px, this._py, this._vx, this._vy, t._px, t._py, t._vx, t._vy, !0, e)
            },
            getSide: function(t, e) {
                return m.getSide(this._px, this._py, this._vx, this._vy, t.x, t.y, !0, e)
            },
            getDistance: function(t) {
                return Math.abs(this.getSignedDistance(t))
            },
            getSignedDistance: function(t) {
                return m.getSignedDistance(this._px, this._py, this._vx, this._vy, t.x, t.y, !0)
            },
            isCollinear: function(t) {
                return c.isCollinear(this._vx, this._vy, t._vx, t._vy)
            },
            isOrthogonal: function(t) {
                return c.isOrthogonal(this._vx, this._vy, t._vx, t._vy)
            },
            statics: {
                intersect: function(t, e, i, n, r, s, o, a, h, l) {
                    h || (i -= t, n -= e, o -= r, a -= s);
                    var d = i * a - n * o;
                    if (!u.isZero(d)) {
                        var f = t - r,
                            g = e - s,
                            p = (o * g - a * f) / d,
                            v = (i * g - n * f) / d;
                        if (l || -1e-12 < p && p < 1 + 1e-12 && -1e-12 < v && v < 1 + 1e-12) return l || (p = p <= 0 ? 0 : p >= 1 ? 1 : p), new c(t + p * i, e + p * n)
                    }
                },
                getSide: function(t, e, i, n, r, s, o, a) {
                    o || (i -= t, n -= e);
                    var h = r - t,
                        l = s - e,
                        c = h * n - l * i;
                    return !a && u.isZero(c) && (c = (h * i + h * i) / (i * i + n * n)) >= 0 && c <= 1 && (c = 0), c < 0 ? -1 : c > 0 ? 1 : 0
                },
                getSignedDistance: function(t, e, i, n, r, s, o) {
                    return o || (i -= t, n -= e), 0 === i ? n > 0 ? r - t : t - r : 0 === n ? i < 0 ? s - e : e - s : ((r - t) * n - (s - e) * i) / Math.sqrt(i * i + n * n)
                },
                getDistance: function(t, e, i, n, r, s, o) {
                    return Math.abs(m.getSignedDistance(t, e, i, n, r, s, o))
                }
            }
        }),
        y = a.extend({
            _class: "Project",
            _list: "projects",
            _reference: "project",
            _compactSerialize: !0,
            initialize: function(t) {
                a.call(this, !0), this._children = [], this._namedChildren = {}, this._activeLayer = null, this._currentStyle = new H(null, null, this), this._view = U.create(this, t || tt.getCanvas(1, 1)), this._selectionItems = {}, this._selectionCount = 0, this._updateVersion = 0
            },
            _serialize: function(t, e) {
                return r.serialize(this._children, t, !0, e)
            },
            _changed: function(t, e) {
                if (1 & t) {
                    var i = this._view;
                    i && (i._needsUpdate = !0, !i._requested && i._autoUpdate && i.requestUpdate())
                }
                var n = this._changes;
                if (n && e) {
                    var r = this._changesById,
                        s = e._id,
                        o = r[s];
                    o ? o.flags |= t : n.push(r[s] = {
                        item: e,
                        flags: t
                    })
                }
            },
            clear: function() {
                for (var t = this._children, e = t.length - 1; e >= 0; e--) t[e].remove()
            },
            isEmpty: function() {
                return !this._children.length
            },
            remove: function t() {
                return !!t.base.call(this) && (this._view && this._view.remove(), !0)
            },
            getView: function() {
                return this._view
            },
            getCurrentStyle: function() {
                return this._currentStyle
            },
            setCurrentStyle: function(t) {
                this._currentStyle.set(t)
            },
            getIndex: function() {
                return this._index
            },
            getOptions: function() {
                return this._scope.settings
            },
            getLayers: function() {
                return this._children
            },
            getActiveLayer: function() {
                return this._activeLayer || new b({
                    project: this,
                    insert: !0
                })
            },
            getSymbolDefinitions: function() {
                var t = [],
                    e = {};
                return this.getItems({
                    class: T,
                    match: function(i) {
                        var n = i._definition,
                            r = n._id;
                        return e[r] || (e[r] = !0, t.push(n)), !1
                    }
                }), t
            },
            getSymbols: "getSymbolDefinitions",
            getSelectedItems: function() {
                var t = this._selectionItems,
                    e = [];
                for (var i in t) {
                    var n = t[i],
                        r = n._selection;
                    1 & r && n.isInserted() ? e.push(n) : r || this._updateSelection(n)
                }
                return e
            },
            _updateSelection: function(t) {
                var e = t._id,
                    i = this._selectionItems;
                t._selection ? i[e] !== t && (this._selectionCount++, i[e] = t) : i[e] === t && (this._selectionCount--, delete i[e])
            },
            selectAll: function() {
                for (var t = this._children, e = 0, i = t.length; e < i; e++) t[e].setFullySelected(!0)
            },
            deselectAll: function() {
                var t = this._selectionItems;
                for (var e in t) t[e].setFullySelected(!1)
            },
            addLayer: function(t) {
                return this.insertLayer(e, t)
            },
            insertLayer: function(t, e) {
                if (e instanceof b) {
                    e._remove(!1, !0), r.splice(this._children, [e], t, 0), e._setProject(this, !0);
                    var i = e._name;
                    i && e.setName(i), this._changes && e._changed(5), this._activeLayer || (this._activeLayer = e)
                } else e = null;
                return e
            },
            _insertItem: function(t, i, n) {
                return i = this.insertLayer(t, i) || (this._activeLayer || this._insertItem(e, new b(w.NO_INSERT), !0)).insertChild(t, i), n && i.activate && i.activate(), i
            },
            getItems: function(t) {
                return w._getItems(this, t)
            },
            getItem: function(t) {
                return w._getItems(this, t, null, null, !0)[0] || null
            },
            importJSON: function(t) {
                this.activate();
                var e = this._activeLayer;
                return r.importJSON(t, e && e.isEmpty() && e)
            },
            removeOn: function(t) {
                var e = this._removeSets;
                if (e) {
                    "mouseup" === t && (e.mousedrag = null);
                    var i = e[t];
                    if (i) {
                        for (var n in i) {
                            var r = i[n];
                            for (var s in e) {
                                var o = e[s];
                                o && o != i && delete o[r._id]
                            }
                            r.remove()
                        }
                        e[t] = null
                    }
                }
            },
            draw: function(t, e, i) {
                this._updateVersion++, t.save(), e.applyToContext(t);
                for (var n = this._children, s = new r({
                        offset: new c(0, 0),
                        pixelRatio: i,
                        viewMatrix: e.isIdentity() ? null : e,
                        matrices: [new _],
                        updateMatrix: !0
                    }), o = 0, a = n.length; o < a; o++) n[o].draw(t, s);
                if (t.restore(), this._selectionCount > 0) {
                    t.save(), t.strokeWidth = 1;
                    var h = this._selectionItems,
                        u = this._scope.settings.handleSize,
                        l = this._updateVersion;
                    for (var d in h) h[d]._drawSelection(t, e, u, h, l);
                    t.restore()
                }
            }
        }),
        w = r.extend(s, {
            statics: {
                extend: function t(e) {
                    return e._serializeFields && (e._serializeFields = r.set({}, this.prototype._serializeFields, e._serializeFields)), t.base.apply(this, arguments)
                },
                NO_INSERT: {
                    insert: !1
                }
            },
            _class: "Item",
            _name: null,
            _applyMatrix: !0,
            _canApplyMatrix: !0,
            _canScaleStroke: !1,
            _pivot: null,
            _visible: !0,
            _blendMode: "normal",
            _opacity: 1,
            _locked: !1,
            _guide: !1,
            _clipMask: !1,
            _selection: 0,
            _selectBounds: !0,
            _selectChildren: !1,
            _serializeFields: {
                name: null,
                applyMatrix: null,
                matrix: new _,
                pivot: null,
                visible: !0,
                blendMode: "normal",
                opacity: 1,
                locked: !1,
                guide: !1,
                clipMask: !1,
                selected: !1,
                data: {}
            },
            _prioritize: ["applyMatrix"]
        }, new function() {
            var t = ["onMouseDown", "onMouseUp", "onMouseDrag", "onClick", "onDoubleClick", "onMouseMove", "onMouseEnter", "onMouseLeave"];
            return r.each(t, function(t) {
                this._events[t] = {
                    install: function(t) {
                        this.getView()._countItemEvent(t, 1)
                    },
                    uninstall: function(t) {
                        this.getView()._countItemEvent(t, -1)
                    }
                }
            }, {
                _events: {
                    onFrame: {
                        install: function() {
                            this.getView()._animateItem(this, !0)
                        },
                        uninstall: function() {
                            this.getView()._animateItem(this, !1)
                        }
                    },
                    onLoad: {},
                    onError: {}
                },
                statics: {
                    _itemHandlers: t
                }
            })
        }, {
            initialize: function() {},
            _initialize: function(t, i) {
                var n = t && r.isPlainObject(t),
                    s = n && !0 === t.internal,
                    o = this._matrix = new _,
                    a = n && t.project || paper.project,
                    h = paper.settings;
                return this._id = s ? null : l.get(), this._parent = this._index = null, this._applyMatrix = this._canApplyMatrix && h.applyMatrix, i && o.translate(i), o._owner = this, this._style = new H(a._currentStyle, this, a), s || n && 0 == t.insert || !h.insertItems && (!n || !0 !== t.insert) ? this._setProject(a) : (n && t.parent || a)._insertItem(e, this, !0), n && t !== w.NO_INSERT && this.set(t, {
                    internal: !0,
                    insert: !0,
                    project: !0,
                    parent: !0
                }), n
            },
            _serialize: function(t, e) {
                function i(i) {
                    for (var o in i) {
                        var a = s[o];
                        r.equals(a, "leading" === o ? 1.2 * i.fontSize : i[o]) || (n[o] = r.serialize(a, t, "data" !== o, e))
                    }
                }
                var n = {},
                    s = this;
                return i(this._serializeFields), this instanceof x || i(this._style._defaults), [this._class, n]
            },
            _changed: function(t) {
                var i = this._symbol,
                    n = this._parent || i,
                    r = this._project;
                8 & t && (this._bounds = this._position = this._decomposed = this._globalMatrix = e), n && 40 & t && w._clearBoundsCache(n), 2 & t && w._clearBoundsCache(this), r && r._changed(t, this), i && i._changed(t)
            },
            getId: function() {
                return this._id
            },
            getName: function() {
                return this._name
            },
            setName: function(t) {
                if (this._name && this._removeNamed(), t === +t + "") throw new Error("Names consisting only of numbers are not supported.");
                var i = this._getOwner();
                if (t && i) {
                    var n = i._children,
                        r = i._namedChildren;
                    (r[t] = r[t] || []).push(this), t in n || (n[t] = this)
                }
                this._name = t || e, this._changed(128)
            },
            getStyle: function() {
                return this._style
            },
            setStyle: function(t) {
                this.getStyle().set(t)
            }
        }, r.each(["locked", "visible", "blendMode", "opacity", "guide"], function(t) {
            var e = r.capitalize(t),
                i = "_" + t,
                n = {
                    locked: 128,
                    visible: 137
                };
            this["get" + e] = function() {
                return this[i]
            }, this["set" + e] = function(e) {
                e != this[i] && (this[i] = e, this._changed(n[t] || 129))
            }
        }, {}), {
            beans: !0,
            getSelection: function() {
                return this._selection
            },
            setSelection: function(t) {
                if (t !== this._selection) {
                    this._selection = t;
                    var e = this._project;
                    e && (e._updateSelection(this), this._changed(129))
                }
            },
            changeSelection: function(t, e) {
                var i = this._selection;
                this.setSelection(e ? i | t : i & ~t)
            },
            isSelected: function() {
                if (this._selectChildren)
                    for (var t = this._children, e = 0, i = t.length; e < i; e++)
                        if (t[e].isSelected()) return !0;
                return !!(1 & this._selection)
            },
            setSelected: function(t) {
                if (this._selectChildren)
                    for (var e = this._children, i = 0, n = e.length; i < n; i++) e[i].setSelected(t);
                this.changeSelection(1, t)
            },
            isFullySelected: function() {
                var t = this._children,
                    e = !!(1 & this._selection);
                if (t && e) {
                    for (var i = 0, n = t.length; i < n; i++)
                        if (!t[i].isFullySelected()) return !1;
                    return !0
                }
                return e
            },
            setFullySelected: function(t) {
                var e = this._children;
                if (e)
                    for (var i = 0, n = e.length; i < n; i++) e[i].setFullySelected(t);
                this.changeSelection(1, t)
            },
            isClipMask: function() {
                return this._clipMask
            },
            setClipMask: function(t) {
                this._clipMask != (t = !!t) && (this._clipMask = t, t && (this.setFillColor(null), this.setStrokeColor(null)), this._changed(129), this._parent && this._parent._changed(1024))
            },
            getData: function() {
                return this._data || (this._data = {}), this._data
            },
            setData: function(t) {
                this._data = t
            },
            getPosition: function(t) {
                var e = this._position,
                    i = t ? c : d;
                if (!e) {
                    var n = this._pivot;
                    e = this._position = n ? this._matrix._transformPoint(n) : this.getBounds().getCenter(!0)
                }
                return new i(e.x, e.y, this, "setPosition")
            },
            setPosition: function() {
                this.translate(c.read(arguments).subtract(this.getPosition(!0)))
            },
            getPivot: function() {
                var t = this._pivot;
                return t ? new d(t.x, t.y, this, "setPivot") : null
            },
            setPivot: function() {
                this._pivot = c.read(arguments, 0, {
                    clone: !0,
                    readNull: !0
                }), this._position = e
            }
        }, r.each({
            getStrokeBounds: {
                stroke: !0
            },
            getHandleBounds: {
                handle: !0
            },
            getInternalBounds: {
                internal: !0
            }
        }, function(t, e) {
            this[e] = function(e) {
                return this.getBounds(e, t)
            }
        }, {
            beans: !0,
            getBounds: function(t, e) {
                var i = e || t instanceof _,
                    n = r.set({}, i ? e : t, this._boundsOptions);
                n.stroke && !this.getStrokeScaling() || (n.cacheItem = this);
                var s = this._getCachedBounds(i && t, n).rect;
                return arguments.length ? s : new v(s.x, s.y, s.width, s.height, this, "setBounds")
            },
            setBounds: function() {
                var t = p.read(arguments),
                    e = this.getBounds(),
                    i = this._matrix,
                    n = new _,
                    r = t.getCenter();
                n.translate(r), t.width == e.width && t.height == e.height || (i.isInvertible() || (i.set(i._backup || (new _).translate(i.getTranslation())), e = this.getBounds()), n.scale(0 !== e.width ? t.width / e.width : 0, 0 !== e.height ? t.height / e.height : 0)), r = e.getCenter(), n.translate(-r.x, -r.y), this.transform(n)
            },
            _getBounds: function(t, e) {
                var i = this._children;
                return i && i.length ? (w._updateBoundsCache(this, e.cacheItem), w._getBounds(i, t, e)) : new p
            },
            _getBoundsCacheKey: function(t, e) {
                return [t.stroke ? 1 : 0, t.handle ? 1 : 0, e ? 1 : 0].join("")
            },
            _getCachedBounds: function(t, e, i) {
                t = t && t._orNullIfIdentity();
                var n = e.internal && !i,
                    r = e.cacheItem,
                    s = n ? null : this._matrix._orNullIfIdentity(),
                    o = r && (!t || t.equals(s)) && this._getBoundsCacheKey(e, n),
                    a = this._bounds;
                if (w._updateBoundsCache(this._parent || this._symbol, r), o && a && o in a) {
                    var h = a[o];
                    return {
                        rect: h.rect.clone(),
                        nonscaling: h.nonscaling
                    }
                }
                var u = this._getBounds(t || s, e),
                    l = u.rect || u,
                    c = this._style,
                    d = u.nonscaling || c.hasStroke() && !c.getStrokeScaling();
                if (o) {
                    a || (this._bounds = a = {});
                    var h = a[o] = {
                        rect: l.clone(),
                        nonscaling: d,
                        internal: n
                    }
                }
                return {
                    rect: l,
                    nonscaling: d
                }
            },
            _getStrokeMatrix: function(t, e) {
                var i = this.getStrokeScaling() ? null : e && e.internal ? this : this._parent || this._symbol && this._symbol._item,
                    n = i ? i.getViewMatrix().invert() : t;
                return n && n._shiftless()
            },
            statics: {
                _updateBoundsCache: function(t, e) {
                    if (t && e) {
                        var i = e._id,
                            n = t._boundsCache = t._boundsCache || {
                                ids: {},
                                list: []
                            };
                        n.ids[i] || (n.list.push(e), n.ids[i] = e)
                    }
                },
                _clearBoundsCache: function(t) {
                    var i = t._boundsCache;
                    if (i) {
                        t._bounds = t._position = t._boundsCache = e;
                        for (var n = 0, r = i.list, s = r.length; n < s; n++) {
                            var o = r[n];
                            o !== t && (o._bounds = o._position = e, o._boundsCache && w._clearBoundsCache(o))
                        }
                    }
                },
                _getBounds: function(t, e, i) {
                    var n = 1 / 0,
                        r = -n,
                        s = n,
                        o = r,
                        a = !1;
                    i = i || {};
                    for (var h = 0, u = t.length; h < u; h++) {
                        var l = t[h];
                        if (l._visible && !l.isEmpty()) {
                            var c = l._getCachedBounds(e && e.appended(l._matrix), i, !0),
                                d = c.rect;
                            n = Math.min(d.x, n), s = Math.min(d.y, s), r = Math.max(d.x + d.width, r), o = Math.max(d.y + d.height, o), c.nonscaling && (a = !0)
                        }
                    }
                    return {
                        rect: isFinite(n) ? new p(n, s, r - n, o - s) : new p,
                        nonscaling: a
                    }
                }
            }
        }), {
            beans: !0,
            _decompose: function() {
                return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose())
            },
            getRotation: function() {
                var t = this._decompose();
                return t ? t.rotation : 0
            },
            setRotation: function(t) {
                var e = this.getRotation();
                if (null != e && null != t) {
                    var i = this._decomposed;
                    this.rotate(t - e), i && (i.rotation = t, this._decomposed = i)
                }
            },
            getScaling: function() {
                var t = this._decompose(),
                    e = t && t.scaling;
                return new d(e ? e.x : 1, e ? e.y : 1, this, "setScaling")
            },
            setScaling: function() {
                var t = this.getScaling(),
                    e = c.read(arguments, 0, {
                        clone: !0,
                        readNull: !0
                    });
                if (t && e && !t.equals(e)) {
                    var i = this.getRotation(),
                        n = this._decomposed,
                        r = new _,
                        s = this.getPosition(!0);
                    r.translate(s), i && r.rotate(i), r.scale(e.x / t.x, e.y / t.y), i && r.rotate(-i), r.translate(s.negate()), this.transform(r), n && (n.scaling = e, this._decomposed = n)
                }
            },
            getMatrix: function() {
                return this._matrix
            },
            setMatrix: function() {
                var t = this._matrix;
                t.initialize.apply(t, arguments)
            },
            getGlobalMatrix: function(t) {
                var e = this._globalMatrix,
                    i = this._project._updateVersion;
                if (e && e._updateVersion !== i && (e = null), !e) {
                    e = this._globalMatrix = this._matrix.clone();
                    var n = this._parent;
                    n && e.prepend(n.getGlobalMatrix(!0)), e._updateVersion = i
                }
                return t ? e : e.clone()
            },
            getViewMatrix: function() {
                return this.getGlobalMatrix().prepend(this.getView()._matrix)
            },
            getApplyMatrix: function() {
                return this._applyMatrix
            },
            setApplyMatrix: function(t) {
                (this._applyMatrix = this._canApplyMatrix && !!t) && this.transform(null, !0)
            },
            getTransformContent: "#getApplyMatrix",
            setTransformContent: "#setApplyMatrix"
        }, {
            getProject: function() {
                return this._project
            },
            _setProject: function(t, e) {
                if (this._project !== t) {
                    this._project && this._installEvents(!1), this._project = t;
                    for (var i = this._children, n = 0, r = i && i.length; n < r; n++) i[n]._setProject(t);
                    e = !0
                }
                e && this._installEvents(!0)
            },
            getView: function() {
                return this._project._view
            },
            _installEvents: function t(e) {
                t.base.call(this, e);
                for (var i = this._children, n = 0, r = i && i.length; n < r; n++) i[n]._installEvents(e)
            },
            getLayer: function() {
                for (var t = this; t = t._parent;)
                    if (t instanceof b) return t;
                return null
            },
            getParent: function() {
                return this._parent
            },
            setParent: function(t) {
                return t.addChild(this)
            },
            _getOwner: "#getParent",
            getChildren: function() {
                return this._children
            },
            setChildren: function(t) {
                this.removeChildren(), this.addChildren(t)
            },
            getFirstChild: function() {
                return this._children && this._children[0] || null
            },
            getLastChild: function() {
                return this._children && this._children[this._children.length - 1] || null
            },
            getNextSibling: function() {
                var t = this._getOwner();
                return t && t._children[this._index + 1] || null
            },
            getPreviousSibling: function() {
                var t = this._getOwner();
                return t && t._children[this._index - 1] || null
            },
            getIndex: function() {
                return this._index
            },
            equals: function(t) {
                return t === this || t && this._class === t._class && this._style.equals(t._style) && this._matrix.equals(t._matrix) && this._locked === t._locked && this._visible === t._visible && this._blendMode === t._blendMode && this._opacity === t._opacity && this._clipMask === t._clipMask && this._guide === t._guide && this._equals(t) || !1
            },
            _equals: function(t) {
                return r.equals(this._children, t._children)
            },
            clone: function(t) {
                var i = new this.constructor(w.NO_INSERT),
                    n = this._children,
                    s = r.pick(t ? t.insert : e, t === e || !0 === t),
                    o = r.pick(t ? t.deep : e, !0);
                n && i.copyAttributes(this), n && !o || i.copyContent(this), n || i.copyAttributes(this), s && i.insertAbove(this);
                var a = this._name,
                    h = this._parent;
                if (a && h) {
                    for (var n = h._children, u = a, l = 1; n[a];) a = u + " " + l++;
                    a !== u && i.setName(a)
                }
                return i
            },
            copyContent: function(t) {
                for (var e = t._children, i = 0, n = e && e.length; i < n; i++) this.addChild(e[i].clone(!1), !0)
            },
            copyAttributes: function(t, e) {
                this.setStyle(t._style);
                for (var i = ["_locked", "_visible", "_blendMode", "_opacity", "_clipMask", "_guide"], n = 0, s = i.length; n < s; n++) {
                    var o = i[n];
                    t.hasOwnProperty(o) && (this[o] = t[o])
                }
                e || this._matrix.set(t._matrix, !0), this.setApplyMatrix(t._applyMatrix), this.setPivot(t._pivot), this.setSelection(t._selection);
                var a = t._data,
                    h = t._name;
                this._data = a ? r.clone(a) : null, h && this.setName(h)
            },
            rasterize: function(t, i) {
                var n = this.getStrokeBounds(),
                    s = (t || this.getView().getResolution()) / 72,
                    o = n.getTopLeft().floor(),
                    a = n.getBottomRight().ceil(),
                    h = new f(a.subtract(o)),
                    u = new C(w.NO_INSERT);
                if (!h.isZero()) {
                    var l = tt.getCanvas(h.multiply(s)),
                        c = l.getContext("2d"),
                        d = (new _).scale(s).translate(o.negate());
                    c.save(), d.applyToContext(c), this.draw(c, new r({
                        matrices: [d]
                    })), c.restore(), u.setCanvas(l)
                }
                return u.transform((new _).translate(o.add(h.divide(2))).scale(1 / s)), (i === e || i) && u.insertAbove(this), u
            },
            contains: function() {
                return !!this._contains(this._matrix._inverseTransform(c.read(arguments)))
            },
            _contains: function(t) {
                var e = this._children;
                if (e) {
                    for (var i = e.length - 1; i >= 0; i--)
                        if (e[i].contains(t)) return !0;
                    return !1
                }
                return t.isInside(this.getInternalBounds())
            },
            isInside: function() {
                return p.read(arguments).contains(this.getBounds())
            },
            _asPathItem: function() {
                return new O.Rectangle({
                    rectangle: this.getInternalBounds(),
                    matrix: this._matrix,
                    insert: !1
                })
            },
            intersects: function(t, e) {
                return t instanceof w && this._asPathItem().getIntersections(t._asPathItem(), null, e, !0).length > 0
            }
        }, new function() {
            function t() {
                return this._hitTest(c.read(arguments), z.getOptions(arguments))
            }

            function e() {
                var t = c.read(arguments),
                    e = z.getOptions(arguments),
                    i = [];
                return this._hitTest(t, r.set({
                    all: i
                }, e)), i
            }

            function i(t, e, i, n) {
                var r = this._children;
                if (r)
                    for (var s = r.length - 1; s >= 0; s--) {
                        var o = r[s],
                            a = o !== n && o._hitTest(t, e, i);
                        if (a && !e.all) return a
                    }
                return null
            }
            return y.inject({
                hitTest: t,
                hitTestAll: e,
                _hitTest: i
            }), {
                hitTest: t,
                hitTestAll: e,
                _hitTestChildren: i
            }
        }, {
            _hitTest: function(t, e, i) {
                function n(t) {
                    return t && g && !g(t) && (t = null), t && e.all && e.all.push(t), t
                }

                function s(e, i) {
                    var n = i ? l["get" + i]() : p.getPosition();
                    if (t.subtract(n).divide(u).length <= 1) return new z(e, p, {
                        name: i ? r.hyphenate(i) : e,
                        point: n
                    })
                }
                if (this._locked || !this._visible || this._guide && !e.guides || this.isEmpty()) return null;
                var o = this._matrix,
                    a = i ? i.appended(o) : this.getGlobalMatrix().prepend(this.getView()._matrix),
                    h = Math.max(e.tolerance, 1e-12),
                    u = e._tolerancePadding = new f(O._getStrokePadding(h, o._shiftless().invert()));
                if (!(t = o._inverseTransform(t)) || !this._children && !this.getBounds({
                        internal: !0,
                        stroke: !0,
                        handle: !0
                    }).expand(u.multiply(2))._containsPoint(t)) return null;
                var l, c, d = !(e.guides && !this._guide || e.selected && !this.isSelected() || e.type && e.type !== r.hyphenate(this._class) || e.class && !(this instanceof e.class)),
                    g = e.match,
                    p = this,
                    v = e.position,
                    _ = e.center,
                    m = e.bounds;
                if (d && this._parent && (v || _ || m)) {
                    if ((_ || m) && (l = this.getInternalBounds()), !(c = v && s("position") || _ && s("center", "Center")) && m)
                        for (var y = ["TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter"], w = 0; w < 8 && !c; w++) c = s("bounds", y[w]);
                    c = n(c)
                }
                return c || (c = this._hitTestChildren(t, e, a) || d && n(this._hitTestSelf(t, e, a, this.getStrokeScaling() ? null : a._shiftless().invert())) || null), c && c.point && (c.point = o.transform(c.point)), c
            },
            _hitTestSelf: function(t, e) {
                if (e.fill && this.hasFill() && this._contains(t)) return new z("fill", this)
            },
            matches: function(t, e) {
                function i(t, e) {
                    for (var n in t)
                        if (t.hasOwnProperty(n)) {
                            var s = t[n],
                                o = e[n];
                            if (r.isPlainObject(s) && r.isPlainObject(o)) {
                                if (!i(s, o)) return !1
                            } else if (!r.equals(s, o)) return !1
                        }
                    return !0
                }
                var n = typeof t;
                if ("object" === n) {
                    for (var s in t)
                        if (t.hasOwnProperty(s) && !this.matches(s, t[s])) return !1;
                    return !0
                }
                if ("function" === n) return t(this);
                if ("match" === t) return e(this);
                var o = /^(empty|editable)$/.test(t) ? this["is" + r.capitalize(t)]() : "type" === t ? r.hyphenate(this._class) : this[t];
                if ("class" === t) {
                    if ("function" == typeof e) return this instanceof e;
                    o = this._class
                }
                if ("function" == typeof e) return !!e(o);
                if (e) {
                    if (e.test) return e.test(o);
                    if (r.isPlainObject(e)) return i(e, o)
                }
                return r.equals(o, e)
            },
            getItems: function(t) {
                return w._getItems(this, t, this._matrix)
            },
            getItem: function(t) {
                return w._getItems(this, t, this._matrix, null, !0)[0] || null
            },
            statics: {
                _getItems: function t(e, i, n, s, o) {
                    if (!s) {
                        var a = "object" == typeof i && i,
                            h = a && a.overlapping,
                            u = a && a.inside,
                            l = h || u,
                            c = l && p.read([l]);
                        s = {
                            items: [],
                            recursive: a && !1 !== a.recursive,
                            inside: !!u,
                            overlapping: !!h,
                            rect: c,
                            path: h && new O.Rectangle({
                                rectangle: c,
                                insert: !1
                            })
                        }, a && (i = r.filter({}, i, {
                            recursive: !0,
                            inside: !0,
                            overlapping: !0
                        }))
                    }
                    var d = e._children,
                        f = s.items,
                        c = s.rect;
                    n = c && (n || new _);
                    for (var g = 0, v = d && d.length; g < v; g++) {
                        var m = d[g],
                            y = n && n.appended(m._matrix),
                            w = !0;
                        if (c) {
                            var l = m.getBounds(y);
                            if (!c.intersects(l)) continue;
                            c.contains(l) || s.overlapping && (l.contains(c) || s.path.intersects(m, y)) || (w = !1)
                        }
                        if (w && m.matches(i) && (f.push(m), o)) break;
                        if (!1 !== s.recursive && t(m, i, y, s, o), o && f.length > 0) break
                    }
                    return f
                }
            }
        }, {
            importJSON: function(t) {
                var e = r.importJSON(t, this);
                return e !== this ? this.addChild(e) : e
            },
            addChild: function(t) {
                return this.insertChild(e, t)
            },
            insertChild: function(t, e) {
                var i = e ? this.insertChildren(t, [e]) : null;
                return i && i[0]
            },
            addChildren: function(t) {
                return this.insertChildren(this._children.length, t)
            },
            insertChildren: function(t, e) {
                var i = this._children;
                if (i && e && e.length > 0) {
                    e = r.slice(e);
                    for (var n = {}, s = e.length - 1; s >= 0; s--) {
                        var o = e[s],
                            a = o && o._id;
                        !o || n[a] ? e.splice(s, 1) : (o._remove(!1, !0), n[a] = !0)
                    }
                    r.splice(i, e, t, 0);
                    for (var h = this._project, u = h._changes, s = 0, l = e.length; s < l; s++) {
                        var o = e[s],
                            c = o._name;
                        o._parent = this, o._setProject(h, !0), c && o.setName(c), u && o._changed(5)
                    }
                    this._changed(11)
                } else e = null;
                return e
            },
            _insertItem: "#insertChild",
            _insertAt: function(t, e) {
                var i = t && t._getOwner(),
                    n = t !== this && i ? this : null;
                return n && (n._remove(!1, !0), i._insertItem(t._index + e, n)), n
            },
            insertAbove: function(t) {
                return this._insertAt(t, 1)
            },
            insertBelow: function(t) {
                return this._insertAt(t, 0)
            },
            sendToBack: function() {
                var t = this._getOwner();
                return t ? t._insertItem(0, this) : null
            },
            bringToFront: function() {
                var t = this._getOwner();
                return t ? t._insertItem(e, this) : null
            },
            appendTop: "#addChild",
            appendBottom: function(t) {
                return this.insertChild(0, t)
            },
            moveAbove: "#insertAbove",
            moveBelow: "#insertBelow",
            addTo: function(t) {
                return t._insertItem(e, this)
            },
            copyTo: function(t) {
                return this.clone(!1).addTo(t)
            },
            reduce: function(t) {
                var e = this._children;
                if (e && 1 === e.length) {
                    var i = e[0].reduce(t);
                    return this._parent ? (i.insertAbove(this), this.remove()) : i.remove(), i
                }
                return this
            },
            _removeNamed: function() {
                var t = this._getOwner();
                if (t) {
                    var e = t._children,
                        i = t._namedChildren,
                        n = this._name,
                        r = i[n],
                        s = r ? r.indexOf(this) : -1; - 1 !== s && (e[n] == this && delete e[n], r.splice(s, 1), r.length ? e[n] = r[0] : delete i[n])
                }
            },
            _remove: function(t, e) {
                var i = this._getOwner(),
                    n = this._project,
                    s = this._index;
                return !!i && (this._name && this._removeNamed(), null != s && (n._activeLayer === this && (n._activeLayer = this.getNextSibling() || this.getPreviousSibling()), r.splice(i._children, null, s, 1)), this._installEvents(!1), t && n._changes && this._changed(5), e && i._changed(11, this), this._parent = null, !0)
            },
            remove: function() {
                return this._remove(!0, !0)
            },
            replaceWith: function(t) {
                var e = t && t.insertBelow(this);
                return e && this.remove(), e
            },
            removeChildren: function(t, e) {
                if (!this._children) return null;
                t = t || 0, e = r.pick(e, this._children.length);
                for (var i = r.splice(this._children, null, t, e - t), n = i.length - 1; n >= 0; n--) i[n]._remove(!0, !1);
                return i.length > 0 && this._changed(11), i
            },
            clear: "#removeChildren",
            reverseChildren: function() {
                if (this._children) {
                    this._children.reverse();
                    for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._index = t;
                    this._changed(11)
                }
            },
            isEmpty: function() {
                var t = this._children;
                return !t || !t.length
            },
            isEditable: function() {
                for (var t = this; t;) {
                    if (!t._visible || t._locked) return !1;
                    t = t._parent
                }
                return !0
            },
            hasFill: function() {
                return this.getStyle().hasFill()
            },
            hasStroke: function() {
                return this.getStyle().hasStroke()
            },
            hasShadow: function() {
                return this.getStyle().hasShadow()
            },
            _getOrder: function(t) {
                function e(t) {
                    var e = [];
                    do {
                        e.unshift(t)
                    } while (t = t._parent);
                    return e
                }
                for (var i = e(this), n = e(t), r = 0, s = Math.min(i.length, n.length); r < s; r++)
                    if (i[r] != n[r]) return i[r]._index < n[r]._index ? 1 : -1;
                return 0
            },
            hasChildren: function() {
                return this._children && this._children.length > 0
            },
            isInserted: function() {
                return !!this._parent && this._parent.isInserted()
            },
            isAbove: function(t) {
                return -1 === this._getOrder(t)
            },
            isBelow: function(t) {
                return 1 === this._getOrder(t)
            },
            isParent: function(t) {
                return this._parent === t
            },
            isChild: function(t) {
                return t && t._parent === this
            },
            isDescendant: function(t) {
                for (var e = this; e = e._parent;)
                    if (e === t) return !0;
                return !1
            },
            isAncestor: function(t) {
                return !!t && t.isDescendant(this)
            },
            isSibling: function(t) {
                return this._parent === t._parent
            },
            isGroupedWith: function(t) {
                for (var e = this._parent; e;) {
                    if (e._parent && /^(Group|Layer|CompoundPath)$/.test(e._class) && t.isDescendant(e)) return !0;
                    e = e._parent
                }
                return !1
            }
        }, r.each(["rotate", "scale", "shear", "skew"], function(t) {
            var e = "rotate" === t;
            this[t] = function() {
                var i = (e ? r : c).read(arguments),
                    n = c.read(arguments, 0, {
                        readNull: !0
                    });
                return this.transform((new _)[t](i, n || this.getPosition(!0)))
            }
        }, {
            translate: function() {
                var t = new _;
                return this.transform(t.translate.apply(t, arguments))
            },
            transform: function(t, e, i, n) {
                var r = this._matrix,
                    s = t && !t.isIdentity(),
                    o = (e || this._applyMatrix) && (!r.isIdentity() || s || e && i && this._children);
                if (!s && !o) return this;
                if (s) {
                    !t.isInvertible() && r.isInvertible() && (r._backup = r.getValues()), r.prepend(t, !0);
                    var a = this._style,
                        h = a.getFillColor(!0),
                        u = a.getStrokeColor(!0);
                    h && h.transform(t), u && u.transform(t)
                }
                if (o && (o = this._transformContent(r, i, n))) {
                    var l = this._pivot;
                    l && r._transformPoint(l, l, !0), r.reset(!0), n && this._canApplyMatrix && (this._applyMatrix = !0)
                }
                var c = this._bounds,
                    d = this._position;
                (s || o) && this._changed(9);
                var f = s && c && t.decompose();
                if (f && f.skewing.isZero() && f.rotation % 90 == 0) {
                    for (var g in c) {
                        var p = c[g];
                        if (p.nonscaling) delete c[g];
                        else if (o || !p.internal) {
                            var v = p.rect;
                            t._transformBounds(v, v)
                        }
                    }
                    this._bounds = c;
                    var _ = c[this._getBoundsCacheKey(this._boundsOptions || {})];
                    _ && (this._position = _.rect.getCenter(!0))
                } else s && d && this._pivot && (this._position = t._transformPoint(d, d));
                return this
            },
            _transformContent: function(t, e, i) {
                var n = this._children;
                if (n) {
                    for (var r = 0, s = n.length; r < s; r++) n[r].transform(t, !0, e, i);
                    return !0
                }
            },
            globalToLocal: function() {
                return this.getGlobalMatrix(!0)._inverseTransform(c.read(arguments))
            },
            localToGlobal: function() {
                return this.getGlobalMatrix(!0)._transformPoint(c.read(arguments))
            },
            parentToLocal: function() {
                return this._matrix._inverseTransform(c.read(arguments))
            },
            localToParent: function() {
                return this._matrix._transformPoint(c.read(arguments))
            },
            fitBounds: function(t, e) {
                t = p.read(arguments);
                var i = this.getBounds(),
                    n = i.height / i.width,
                    r = t.height / t.width,
                    s = (e ? n > r : n < r) ? t.width / i.width : t.height / i.height,
                    o = new p(new c, new f(i.width * s, i.height * s));
                o.setCenter(t.getCenter()), this.setBounds(o)
            }
        }), {
            _setStyles: function(t, e, i) {
                var n = this._style,
                    r = this._matrix;
                if (n.hasFill() && (t.fillStyle = n.getFillColor().toCanvasStyle(t, r)), n.hasStroke()) {
                    t.strokeStyle = n.getStrokeColor().toCanvasStyle(t, r), t.lineWidth = n.getStrokeWidth();
                    var s = n.getStrokeJoin(),
                        o = n.getStrokeCap(),
                        a = n.getMiterLimit();
                    if (s && (t.lineJoin = s), o && (t.lineCap = o), a && (t.miterLimit = a), paper.support.nativeDash) {
                        var h = n.getDashArray(),
                            u = n.getDashOffset();
                        h && h.length && ("setLineDash" in t ? (t.setLineDash(h), t.lineDashOffset = u) : (t.mozDash = h, t.mozDashOffset = u))
                    }
                }
                if (n.hasShadow()) {
                    var l = e.pixelRatio || 1,
                        d = i._shiftless().prepend((new _).scale(l, l)),
                        f = d.transform(new c(n.getShadowBlur(), 0)),
                        g = d.transform(this.getShadowOffset());
                    t.shadowColor = n.getShadowColor().toCanvasStyle(t), t.shadowBlur = f.getLength(), t.shadowOffsetX = g.x, t.shadowOffsetY = g.y
                }
            },
            draw: function(t, e, i) {
                var n = this._updateVersion = this._project._updateVersion;
                if (this._visible && 0 !== this._opacity) {
                    var r = e.matrices,
                        s = e.viewMatrix,
                        o = this._matrix,
                        a = r[r.length - 1].appended(o);
                    if (a.isInvertible()) {
                        s = s ? s.appended(a) : a, r.push(a), e.updateMatrix && (a._updateVersion = n, this._globalMatrix = a);
                        var h, u, l, c = this._blendMode,
                            d = this._opacity,
                            f = "normal" === c,
                            g = et.nativeModes[c],
                            p = f && 1 === d || e.dontStart || e.clip || (g || f && d < 1) && this._canComposite(),
                            v = e.pixelRatio || 1;
                        if (!p) {
                            var _ = this.getStrokeBounds(s);
                            if (!_.width || !_.height) return;
                            l = e.offset, u = e.offset = _.getTopLeft().floor(), h = t, t = tt.getContext(_.getSize().ceil().add(1).multiply(v)), 1 !== v && t.scale(v, v)
                        }
                        t.save();
                        var m = i ? i.appended(o) : this._canScaleStroke && !this.getStrokeScaling(!0) && s,
                            y = !p && e.clipItem,
                            w = !m || y;
                        if (p ? (t.globalAlpha = d, g && (t.globalCompositeOperation = c)) : w && t.translate(-u.x, -u.y), w && (p ? o : s).applyToContext(t), y && e.clipItem.draw(t, e.extend({
                                clip: !0
                            })), m) {
                            t.setTransform(v, 0, 0, v, 0, 0);
                            var x = e.offset;
                            x && t.translate(-x.x, -x.y)
                        }
                        this._draw(t, e, s, m), t.restore(), r.pop(), e.clip && !e.dontFinish && t.clip(), p || (et.process(c, t, h, d, u.subtract(l).multiply(v)), tt.release(t), e.offset = l)
                    }
                }
            },
            _isUpdated: function(t) {
                var e = this._parent;
                if (e instanceof L) return e._isUpdated(t);
                var i = this._updateVersion === t;
                return !i && e && e._visible && e._isUpdated(t) && (this._updateVersion = t, i = !0), i
            },
            _drawSelection: function(t, e, i, n, r) {
                var s = this._selection,
                    o = 1 & s,
                    a = 2 & s || o && this._selectBounds,
                    h = 4 & s;
                if (this._drawSelected || (o = !1), (o || a || h) && this._isUpdated(r)) {
                    var u, l = this.getSelectedColor(!0) || (u = this.getLayer()) && u.getSelectedColor(!0),
                        c = e.appended(this.getGlobalMatrix(!0)),
                        d = i / 2;
                    if (t.strokeStyle = t.fillStyle = l ? l.toCanvasStyle(t) : "#009dec", o && this._drawSelected(t, c, n), h) {
                        var f = this.getPosition(!0),
                            g = f.x,
                            p = f.y;
                        t.beginPath(), t.arc(g, p, d, 0, 2 * Math.PI, !0), t.stroke();
                        for (var v = [
                                [0, -1],
                                [1, 0],
                                [0, 1],
                                [-1, 0]
                            ], _ = d, m = i + 1, y = 0; y < 4; y++) {
                            var w = v[y],
                                x = w[0],
                                b = w[1];
                            t.moveTo(g + x * _, p + b * _), t.lineTo(g + x * m, p + b * m), t.stroke()
                        }
                    }
                    if (a) {
                        var S = c._transformCorners(this.getInternalBounds());
                        t.beginPath();
                        for (var y = 0; y < 8; y++) t[y ? "lineTo" : "moveTo"](S[y], S[++y]);
                        t.closePath(), t.stroke();
                        for (var y = 0; y < 8; y++) t.fillRect(S[y] - d, S[++y] - d, i, i)
                    }
                }
            },
            _canComposite: function() {
                return !1
            }
        }, r.each(["down", "drag", "up", "move"], function(t) {
            this["removeOn" + r.capitalize(t)] = function() {
                var e = {};
                return e[t] = !0, this.removeOn(e)
            }
        }, {
            removeOn: function(t) {
                for (var e in t)
                    if (t[e]) {
                        var i = "mouse" + e,
                            n = this._project,
                            r = n._removeSets = n._removeSets || {};
                        r[i] = r[i] || {}, r[i][this._id] = this
                    }
                return this
            }
        })),
        x = w.extend({
            _class: "Group",
            _selectBounds: !1,
            _selectChildren: !0,
            _serializeFields: {
                children: []
            },
            initialize: function(t) {
                this._children = [], this._namedChildren = {}, this._initialize(t) || this.addChildren(Array.isArray(t) ? t : arguments)
            },
            _changed: function t(i) {
                t.base.call(this, i), 1026 & i && (this._clipItem = e)
            },
            _getClipItem: function() {
                var t = this._clipItem;
                if (t === e) {
                    t = null;
                    for (var i = this._children, n = 0, r = i.length; n < r; n++)
                        if (i[n]._clipMask) {
                            t = i[n];
                            break
                        }
                    this._clipItem = t
                }
                return t
            },
            isClipped: function() {
                return !!this._getClipItem()
            },
            setClipped: function(t) {
                var e = this.getFirstChild();
                e && e.setClipMask(t)
            },
            _getBounds: function t(e, i) {
                var n = this._getClipItem();
                return n ? n._getCachedBounds(e && e.appended(n._matrix), r.set({}, i, {
                    stroke: !1
                })) : t.base.call(this, e, i)
            },
            _hitTestChildren: function t(e, i, n) {
                var r = this._getClipItem();
                return (!r || r.contains(e)) && t.base.call(this, e, i, n, r)
            },
            _draw: function(t, e) {
                var i = e.clip,
                    n = !i && this._getClipItem();
                e = e.extend({
                    clipItem: n,
                    clip: !1
                }), i ? (t.beginPath(), e.dontStart = e.dontFinish = !0) : n && n.draw(t, e.extend({
                    clip: !0
                }));
                for (var r = this._children, s = 0, o = r.length; s < o; s++) {
                    var a = r[s];
                    a !== n && a.draw(t, e)
                }
            }
        }),
        b = x.extend({
            _class: "Layer",
            initialize: function() {
                x.apply(this, arguments)
            },
            _getOwner: function() {
                return this._parent || null != this._index && this._project
            },
            isInserted: function t() {
                return this._parent ? t.base.call(this) : null != this._index
            },
            activate: function() {
                this._project._activeLayer = this
            },
            _hitTestSelf: function() {}
        }),
        S = w.extend({
            _class: "Shape",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _canScaleStroke: !0,
            _serializeFields: {
                type: null,
                size: null,
                radius: null
            },
            initialize: function(t, e) {
                this._initialize(t, e)
            },
            _equals: function(t) {
                return this._type === t._type && this._size.equals(t._size) && r.equals(this._radius, t._radius)
            },
            copyContent: function(t) {
                this.setType(t._type), this.setSize(t._size), this.setRadius(t._radius)
            },
            getType: function() {
                return this._type
            },
            setType: function(t) {
                this._type = t
            },
            getShape: "#getType",
            setShape: "#setType",
            getSize: function() {
                var t = this._size;
                return new g(t.width, t.height, this, "setSize")
            },
            setSize: function() {
                var t = f.read(arguments);
                if (this._size) {
                    if (!this._size.equals(t)) {
                        var e = this._type,
                            i = t.width,
                            n = t.height;
                        "rectangle" === e ? this._radius.set(f.min(this._radius, t.divide(2))) : "circle" === e ? (i = n = (i + n) / 2, this._radius = i / 2) : "ellipse" === e && this._radius._set(i / 2, n / 2), this._size._set(i, n), this._changed(9)
                    }
                } else this._size = t.clone()
            },
            getRadius: function() {
                var t = this._radius;
                return "circle" === this._type ? t : new g(t.width, t.height, this, "setRadius")
            },
            setRadius: function(t) {
                var e = this._type;
                if ("circle" === e) {
                    if (t === this._radius) return;
                    var i = 2 * t;
                    this._radius = t, this._size._set(i, i)
                } else if (t = f.read(arguments), this._radius) {
                    if (this._radius.equals(t)) return;
                    if (this._radius.set(t), "rectangle" === e) {
                        var i = f.max(this._size, t.multiply(2));
                        this._size.set(i)
                    } else "ellipse" === e && this._size._set(2 * t.width, 2 * t.height)
                } else this._radius = t.clone();
                this._changed(9)
            },
            isEmpty: function() {
                return !1
            },
            toPath: function(t) {
                var i = new(O[r.capitalize(this._type)])({
                    center: new c,
                    size: this._size,
                    radius: this._radius,
                    insert: !1
                });
                return i.copyAttributes(this), paper.settings.applyMatrix && i.setApplyMatrix(!0), (t === e || t) && i.insertAbove(this), i
            },
            toShape: "#clone",
            _asPathItem: function() {
                return this.toPath(!1)
            },
            _draw: function(t, e, i, n) {
                var r = this._style,
                    s = r.hasFill(),
                    o = r.hasStroke(),
                    a = e.dontFinish || e.clip,
                    h = !n;
                if (s || o || a) {
                    var u = this._type,
                        l = this._radius,
                        c = "circle" === u;
                    if (e.dontStart || t.beginPath(), h && c) t.arc(0, 0, l, 0, 2 * Math.PI, !0);
                    else {
                        var d = c ? l : l.width,
                            f = c ? l : l.height,
                            g = this._size,
                            p = g.width,
                            v = g.height;
                        if (h && "rectangle" === u && 0 === d && 0 === f) t.rect(-p / 2, -v / 2, p, v);
                        else {
                            var _ = p / 2,
                                m = v / 2,
                                y = .44771525016920644,
                                w = d * y,
                                x = f * y,
                                b = [-_, -m + f, -_, -m + x, -_ + w, -m, -_ + d, -m, _ - d, -m, _ - w, -m, _, -m + x, _, -m + f, _, m - f, _, m - x, _ - w, m, _ - d, m, -_ + d, m, -_ + w, m, -_, m - x, -_, m - f];
                            n && n.transform(b, b, 32), t.moveTo(b[0], b[1]), t.bezierCurveTo(b[2], b[3], b[4], b[5], b[6], b[7]), _ !== d && t.lineTo(b[8], b[9]), t.bezierCurveTo(b[10], b[11], b[12], b[13], b[14], b[15]), m !== f && t.lineTo(b[16], b[17]), t.bezierCurveTo(b[18], b[19], b[20], b[21], b[22], b[23]), _ !== d && t.lineTo(b[24], b[25]), t.bezierCurveTo(b[26], b[27], b[28], b[29], b[30], b[31])
                        }
                    }
                    t.closePath()
                }
                a || !s && !o || (this._setStyles(t, e, i), s && (t.fill(r.getFillRule()), t.shadowColor = "rgba(0,0,0,0)"), o && t.stroke())
            },
            _canComposite: function() {
                return !(this.hasFill() && this.hasStroke())
            },
            _getBounds: function(t, e) {
                var i = new p(this._size).setCenter(0, 0),
                    n = this._style,
                    r = e.stroke && n.hasStroke() && n.getStrokeWidth();
                return t && (i = t._transformBounds(i)), r ? i.expand(O._getStrokePadding(r, this._getStrokeMatrix(t, e))) : i
            }
        }, new function() {
            function t(t, e, i) {
                var n = t._radius;
                if (!n.isZero())
                    for (var r = t._size.divide(2), s = 1; s <= 4; s++) {
                        var o = new c(s > 1 && s < 4 ? -1 : 1, s > 2 ? -1 : 1),
                            a = o.multiply(r),
                            h = a.subtract(o.multiply(n)),
                            u = new p(i ? a.add(o.multiply(i)) : a, h);
                        if (u.contains(e)) return {
                            point: h,
                            quadrant: s
                        }
                    }
            }

            function e(t, e, i, n) {
                var r = t.divide(e);
                return (!n || r.isInQuadrant(n)) && r.subtract(r.normalize()).multiply(e).divide(i).length <= 1
            }
            return {
                _contains: function e(i) {
                    if ("rectangle" === this._type) {
                        var n = t(this, i);
                        return n ? i.subtract(n.point).divide(this._radius).getLength() <= 1 : e.base.call(this, i)
                    }
                    return i.divide(this.size).getLength() <= .5
                },
                _hitTestSelf: function i(n, r, s, o) {
                    var a = !1,
                        h = this._style,
                        u = r.stroke && h.hasStroke(),
                        l = r.fill && h.hasFill();
                    if (u || l) {
                        var c = this._type,
                            d = this._radius,
                            f = u ? h.getStrokeWidth() / 2 : 0,
                            g = r._tolerancePadding.add(O._getStrokePadding(f, !h.getStrokeScaling() && o));
                        if ("rectangle" === c) {
                            var v = g.multiply(2),
                                _ = t(this, n, v);
                            if (_) a = e(n.subtract(_.point), d, g, _.quadrant);
                            else {
                                var m = new p(this._size).setCenter(0, 0),
                                    y = m.expand(v),
                                    w = m.expand(v.negate());
                                a = y._containsPoint(n) && !w._containsPoint(n)
                            }
                        } else a = e(n, d, g)
                    }
                    return a ? new z(u ? "stroke" : "fill", this) : i.base.apply(this, arguments)
                }
            }
        }, {
            statics: new function() {
                function t(t, e, i, n, s) {
                    var o = new S(r.getNamed(s), e);
                    return o._type = t, o._size = i, o._radius = n, o
                }
                return {
                    Circle: function() {
                        var e = c.readNamed(arguments, "center"),
                            i = r.readNamed(arguments, "radius");
                        return t("circle", e, new f(2 * i), i, arguments)
                    },
                    Rectangle: function() {
                        var e = p.readNamed(arguments, "rectangle"),
                            i = f.min(f.readNamed(arguments, "radius"), e.getSize(!0).divide(2));
                        return t("rectangle", e.getCenter(!0), e.getSize(!0), i, arguments)
                    },
                    Ellipse: function() {
                        var e = S._readEllipse(arguments),
                            i = e.radius;
                        return t("ellipse", e.center, i.multiply(2), i, arguments)
                    },
                    _readEllipse: function(t) {
                        var e, i;
                        if (r.hasNamed(t, "radius")) e = c.readNamed(t, "center"), i = f.readNamed(t, "radius");
                        else {
                            var n = p.readNamed(t, "rectangle");
                            e = n.getCenter(!0), i = n.getSize(!0).divide(2)
                        }
                        return {
                            center: e,
                            radius: i
                        }
                    }
                }
            }
        }),
        C = w.extend({
            _class: "Raster",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _boundsOptions: {
                stroke: !1,
                handle: !1
            },
            _serializeFields: {
                crossOrigin: null,
                source: null
            },
            _prioritize: ["crossOrigin"],
            initialize: function(t, i) {
                if (!this._initialize(t, i !== e && c.read(arguments, 1))) {
                    var r = "string" == typeof t ? n.getElementById(t) : t;
                    r ? this.setImage(r) : this.setSource(t)
                }
                this._size || (this._size = new f, this._loaded = !1)
            },
            _equals: function(t) {
                return this.getSource() === t.getSource()
            },
            copyContent: function(t) {
                var e = t._image,
                    i = t._canvas;
                if (e) this._setImage(e);
                else if (i) {
                    var n = tt.getCanvas(t._size);
                    n.getContext("2d").drawImage(i, 0, 0), this._setImage(n)
                }
                this._crossOrigin = t._crossOrigin
            },
            getSize: function() {
                var t = this._size;
                return new g(t ? t.width : 0, t ? t.height : 0, this, "setSize")
            },
            setSize: function() {
                var t = f.read(arguments);
                if (!t.equals(this._size))
                    if (t.width > 0 && t.height > 0) {
                        var e = this.getElement();
                        this._setImage(tt.getCanvas(t)), e && this.getContext(!0).drawImage(e, 0, 0, t.width, t.height)
                    } else this._canvas && tt.release(this._canvas), this._size = t.clone()
            },
            getWidth: function() {
                return this._size ? this._size.width : 0
            },
            setWidth: function(t) {
                this.setSize(t, this.getHeight())
            },
            getHeight: function() {
                return this._size ? this._size.height : 0
            },
            setHeight: function(t) {
                this.setSize(this.getWidth(), t)
            },
            getLoaded: function() {
                return this._loaded
            },
            isEmpty: function() {
                var t = this._size;
                return !t || 0 === t.width && 0 === t.height
            },
            getResolution: function() {
                var t = this._matrix,
                    e = new c(0, 0).transform(t),
                    i = new c(1, 0).transform(t).subtract(e),
                    n = new c(0, 1).transform(t).subtract(e);
                return new f(72 / i.getLength(), 72 / n.getLength())
            },
            getPpi: "#getResolution",
            getImage: function() {
                return this._image
            },
            setImage: function(t) {
                function e(t) {
                    var e = i.getView(),
                        n = t && t.type || "load";
                    e && i.responds(n) && (paper = e._scope, i.emit(n, new X(t)))
                }
                var i = this;
                this._setImage(t), this._loaded ? setTimeout(e, 0) : t && V.add(t, {
                    load: function(n) {
                        i._setImage(t), e(n)
                    },
                    error: e
                })
            },
            _setImage: function(t) {
                this._canvas && tt.release(this._canvas), t && t.getContext ? (this._image = null, this._canvas = t, this._loaded = !0) : (this._image = t, this._canvas = null, this._loaded = !!(t && t.src && t.complete)), this._size = new f(t ? t.naturalWidth || t.width : 0, t ? t.naturalHeight || t.height : 0), this._context = null, this._changed(521)
            },
            getCanvas: function() {
                if (!this._canvas) {
                    var t = tt.getContext(this._size);
                    try {
                        this._image && t.drawImage(this._image, 0, 0), this._canvas = t.canvas
                    } catch (e) {
                        tt.release(t)
                    }
                }
                return this._canvas
            },
            setCanvas: "#setImage",
            getContext: function(t) {
                return this._context || (this._context = this.getCanvas().getContext("2d")), t && (this._image = null, this._changed(513)), this._context
            },
            setContext: function(t) {
                this._context = t
            },
            getSource: function() {
                var t = this._image;
                return t && t.src || this.toDataURL()
            },
            setSource: function(e) {
                var i = new t.Image,
                    n = this._crossOrigin;
                n && (i.crossOrigin = n), i.src = e, this.setImage(i)
            },
            getCrossOrigin: function() {
                var t = this._image;
                return t && t.crossOrigin || this._crossOrigin || ""
            },
            setCrossOrigin: function(t) {
                this._crossOrigin = t;
                var e = this._image;
                e && (e.crossOrigin = t)
            },
            getElement: function() {
                return this._canvas || this._loaded && this._image
            }
        }, {
            beans: !1,
            getSubCanvas: function() {
                var t = p.read(arguments),
                    e = tt.getContext(t.getSize());
                return e.drawImage(this.getCanvas(), t.x, t.y, t.width, t.height, 0, 0, t.width, t.height), e.canvas
            },
            getSubRaster: function() {
                var t = p.read(arguments),
                    e = new C(w.NO_INSERT);
                return e._setImage(this.getSubCanvas(t)), e.translate(t.getCenter().subtract(this.getSize().divide(2))), e._matrix.prepend(this._matrix), e.insertAbove(this), e
            },
            toDataURL: function() {
                var t = this._image,
                    e = t && t.src;
                if (/^data:/.test(e)) return e;
                var i = this.getCanvas();
                return i ? i.toDataURL.apply(i, arguments) : null
            },
            drawImage: function(t) {
                var e = c.read(arguments, 1);
                this.getContext(!0).drawImage(t, e.x, e.y)
            },
            getAverageColor: function(t) {
                var e, i;
                if (t ? t instanceof M ? (i = t, e = t.getBounds()) : "object" == typeof t && ("width" in t ? e = new p(t) : "x" in t && (e = new p(t.x - .5, t.y - .5, 1, 1))) : e = this.getBounds(), !e) return null;
                var n = Math.min(e.width, 32),
                    s = Math.min(e.height, 32),
                    o = C._sampleContext;
                o ? o.clearRect(0, 0, 33, 33) : o = C._sampleContext = tt.getContext(new f(32)), o.save();
                var a = (new _).scale(n / e.width, s / e.height).translate(-e.x, -e.y);
                a.applyToContext(o), i && i.draw(o, new r({
                    clip: !0,
                    matrices: [a]
                })), this._matrix.applyToContext(o);
                var h = this.getElement(),
                    u = this._size;
                h && o.drawImage(h, -u.width / 2, -u.height / 2), o.restore();
                for (var l = o.getImageData(.5, .5, Math.ceil(n), Math.ceil(s)).data, c = [0, 0, 0], d = 0, g = 0, v = l.length; g < v; g += 4) {
                    var m = l[g + 3];
                    d += m, m /= 255, c[0] += l[g] * m, c[1] += l[g + 1] * m, c[2] += l[g + 2] * m
                }
                for (var g = 0; g < 3; g++) c[g] /= d;
                return d ? B.read(c) : null
            },
            getPixel: function() {
                var t = c.read(arguments),
                    e = this.getContext().getImageData(t.x, t.y, 1, 1).data;
                return new B("rgb", [e[0] / 255, e[1] / 255, e[2] / 255], e[3] / 255)
            },
            setPixel: function() {
                var t = c.read(arguments),
                    e = B.read(arguments),
                    i = e._convert("rgb"),
                    n = e._alpha,
                    r = this.getContext(!0),
                    s = r.createImageData(1, 1),
                    o = s.data;
                o[0] = 255 * i[0], o[1] = 255 * i[1], o[2] = 255 * i[2], o[3] = null != n ? 255 * n : 255, r.putImageData(s, t.x, t.y)
            },
            createImageData: function() {
                var t = f.read(arguments);
                return this.getContext().createImageData(t.width, t.height)
            },
            getImageData: function() {
                var t = p.read(arguments);
                return t.isEmpty() && (t = new p(this._size)), this.getContext().getImageData(t.x, t.y, t.width, t.height)
            },
            setImageData: function(t) {
                var e = c.read(arguments, 1);
                this.getContext(!0).putImageData(t, e.x, e.y)
            },
            _getBounds: function(t, e) {
                var i = new p(this._size).setCenter(0, 0);
                return t ? t._transformBounds(i) : i
            },
            _hitTestSelf: function(t) {
                if (this._contains(t)) {
                    var e = this;
                    return new z("pixel", e, {
                        offset: t.add(e._size.divide(2)).round(),
                        color: {
                            get: function() {
                                return e.getPixel(this.offset)
                            }
                        }
                    })
                }
            },
            _draw: function(t) {
                var e = this.getElement();
                e && (t.globalAlpha = this._opacity, t.drawImage(e, -this._size.width / 2, -this._size.height / 2))
            },
            _canComposite: function() {
                return !0
            }
        }),
        T = w.extend({
            _class: "SymbolItem",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _boundsOptions: {
                stroke: !0
            },
            _serializeFields: {
                symbol: null
            },
            initialize: function(t, i) {
                this._initialize(t, i !== e && c.read(arguments, 1)) || this.setDefinition(t instanceof E ? t : new E(t))
            },
            _equals: function(t) {
                return this._definition === t._definition
            },
            copyContent: function(t) {
                this.setDefinition(t._definition)
            },
            getDefinition: function() {
                return this._definition
            },
            setDefinition: function(t) {
                this._definition = t, this._changed(9)
            },
            getSymbol: "#getDefinition",
            setSymbol: "#setDefinition",
            isEmpty: function() {
                return this._definition._item.isEmpty()
            },
            _getBounds: function(t, e) {
                var i = this._definition._item;
                return i._getCachedBounds(i._matrix.prepended(t), e)
            },
            _hitTestSelf: function(t, e, i) {
                var n = this._definition._item._hitTest(t, e, i);
                return n && (n.item = this), n
            },
            _draw: function(t, e) {
                this._definition._item.draw(t, e)
            }
        }),
        E = r.extend({
            _class: "SymbolDefinition",
            initialize: function(t, e) {
                this._id = l.get(), this.project = paper.project, t && this.setItem(t, e)
            },
            _serialize: function(t, e) {
                return e.add(this, function() {
                    return r.serialize([this._class, this._item], t, !1, e)
                })
            },
            _changed: function(t) {
                8 & t && w._clearBoundsCache(this), 1 & t && this.project._changed(t)
            },
            getItem: function() {
                return this._item
            },
            setItem: function(t, e) {
                t._symbol && (t = t.clone()), this._item && (this._item._symbol = null), this._item = t, t.remove(), t.setSelected(!1), e || t.setPosition(new c), t._symbol = this, this._changed(9)
            },
            getDefinition: "#getItem",
            setDefinition: "#setItem",
            place: function(t) {
                return new T(this, t)
            },
            clone: function() {
                return new E(this._item.clone(!1))
            },
            equals: function(t) {
                return t === this || t && this._item.equals(t._item) || !1
            }
        }),
        z = r.extend({
            _class: "HitResult",
            initialize: function(t, e, i) {
                this.type = t, this.item = e, i && this.inject(i)
            },
            statics: {
                getOptions: function(t) {
                    var e = t && r.read(t);
                    return r.set({
                        type: null,
                        tolerance: paper.settings.hitTolerance,
                        fill: !e,
                        stroke: !e,
                        segments: !e,
                        handles: !1,
                        ends: !1,
                        position: !1,
                        center: !1,
                        bounds: !1,
                        guides: !1,
                        selected: !1
                    }, e)
                }
            }
        }),
        k = r.extend({
            _class: "Segment",
            beans: !0,
            _selection: 0,
            initialize: function(t, i, n, r, s, o) {
                var a, h, u, l, c = arguments.length;
                c > 0 && (null == t || "object" == typeof t ? 1 === c && t && "point" in t ? (a = t.point, h = t.handleIn, u = t.handleOut, l = t.selection) : (a = t, h = i, u = n, l = r) : (a = [t, i], h = n !== e ? [n, r] : null, u = s !== e ? [s, o] : null)), new I(a, this, "_point"), new I(h, this, "_handleIn"), new I(u, this, "_handleOut"), l && this.setSelection(l)
            },
            _serialize: function(t, e) {
                var i = this._point,
                    n = this._selection,
                    s = n || this.hasHandles() ? [i, this._handleIn, this._handleOut] : i;
                return n && s.push(n), r.serialize(s, t, !0, e)
            },
            _changed: function(t) {
                var e = this._path;
                if (e) {
                    var i, n = e._curves,
                        r = this._index;
                    n && (t && t !== this._point && t !== this._handleIn || !(i = r > 0 ? n[r - 1] : e._closed ? n[n.length - 1] : null) || i._changed(), t && t !== this._point && t !== this._handleOut || !(i = n[r]) || i._changed()), e._changed(25)
                }
            },
            getPoint: function() {
                return this._point
            },
            setPoint: function() {
                this._point.set(c.read(arguments))
            },
            getHandleIn: function() {
                return this._handleIn
            },
            setHandleIn: function() {
                this._handleIn.set(c.read(arguments))
            },
            getHandleOut: function() {
                return this._handleOut
            },
            setHandleOut: function() {
                this._handleOut.set(c.read(arguments))
            },
            hasHandles: function() {
                return !this._handleIn.isZero() || !this._handleOut.isZero()
            },
            isSmooth: function() {
                var t = this._handleIn,
                    e = this._handleOut;
                return !t.isZero() && !e.isZero() && t.isCollinear(e)
            },
            clearHandles: function() {
                this._handleIn._set(0, 0), this._handleOut._set(0, 0)
            },
            getSelection: function() {
                return this._selection
            },
            setSelection: function(t) {
                var e = this._selection,
                    i = this._path;
                this._selection = t = t || 0, i && t !== e && (i._updateSelection(this, e, t), i._changed(129))
            },
            changeSelection: function(t, e) {
                var i = this._selection;
                this.setSelection(e ? i | t : i & ~t)
            },
            isSelected: function() {
                return !!(7 & this._selection)
            },
            setSelected: function(t) {
                this.changeSelection(7, t)
            },
            getIndex: function() {
                return this._index !== e ? this._index : null
            },
            getPath: function() {
                return this._path || null
            },
            getCurve: function() {
                var t = this._path,
                    e = this._index;
                return t ? (e > 0 && !t._closed && e === t._segments.length - 1 && e--, t.getCurves()[e] || null) : null
            },
            getLocation: function() {
                var t = this.getCurve();
                return t ? new P(t, this === t._segment1 ? 0 : 1) : null
            },
            getNext: function() {
                var t = this._path && this._path._segments;
                return t && (t[this._index + 1] || this._path._closed && t[0]) || null
            },
            smooth: function(t, i, n) {
                var r = t || {},
                    s = r.type,
                    o = r.factor,
                    a = this.getPrevious(),
                    h = this.getNext(),
                    u = (a || this)._point,
                    l = this._point,
                    d = (h || this)._point,
                    f = u.getDistance(l),
                    g = l.getDistance(d);
                if (s && "catmull-rom" !== s) {
                    if ("geometric" !== s) throw new Error("Smoothing method '" + s + "' not supported.");
                    if (a && h) {
                        var p = u.subtract(d),
                            v = o === e ? .4 : o,
                            _ = v * f / (f + g);
                        i || this.setHandleIn(p.multiply(_)), n || this.setHandleOut(p.multiply(_ - v))
                    }
                } else {
                    var m = o === e ? .5 : o,
                        y = Math.pow(f, m),
                        w = y * y,
                        x = Math.pow(g, m),
                        b = x * x;
                    if (!i && a) {
                        var S = 2 * b + 3 * x * y + w,
                            C = 3 * x * (x + y);
                        this.setHandleIn(0 !== C ? new c((b * u._x + S * l._x - w * d._x) / C - l._x, (b * u._y + S * l._y - w * d._y) / C - l._y) : new c)
                    }
                    if (!n && h) {
                        var S = 2 * w + 3 * y * x + b,
                            C = 3 * y * (y + x);
                        this.setHandleOut(0 !== C ? new c((w * d._x + S * l._x - b * u._x) / C - l._x, (w * d._y + S * l._y - b * u._y) / C - l._y) : new c)
                    }
                }
            },
            getPrevious: function() {
                var t = this._path && this._path._segments;
                return t && (t[this._index - 1] || this._path._closed && t[t.length - 1]) || null
            },
            isFirst: function() {
                return !this._index
            },
            isLast: function() {
                var t = this._path;
                return t && this._index === t._segments.length - 1 || !1
            },
            reverse: function() {
                var t = this._handleIn,
                    e = this._handleOut,
                    i = t.clone();
                t.set(e), e.set(i)
            },
            reversed: function() {
                return new k(this._point, this._handleOut, this._handleIn)
            },
            remove: function() {
                return !!this._path && !!this._path.removeSegment(this._index)
            },
            clone: function() {
                return new k(this._point, this._handleIn, this._handleOut)
            },
            equals: function(t) {
                return t === this || t && this._class === t._class && this._point.equals(t._point) && this._handleIn.equals(t._handleIn) && this._handleOut.equals(t._handleOut) || !1
            },
            toString: function() {
                var t = ["point: " + this._point];
                return this._handleIn.isZero() || t.push("handleIn: " + this._handleIn), this._handleOut.isZero() || t.push("handleOut: " + this._handleOut), "{ " + t.join(", ") + " }"
            },
            transform: function(t) {
                this._transformCoordinates(t, new Array(6), !0), this._changed()
            },
            interpolate: function(t, e, i) {
                var n = 1 - i,
                    r = i,
                    s = t._point,
                    o = e._point,
                    a = t._handleIn,
                    h = e._handleIn,
                    u = e._handleOut,
                    l = t._handleOut;
                this._point._set(n * s._x + r * o._x, n * s._y + r * o._y, !0),
                    this._handleIn._set(n * a._x + r * h._x, n * a._y + r * h._y, !0), this._handleOut._set(n * l._x + r * u._x, n * l._y + r * u._y, !0), this._changed()
            },
            _transformCoordinates: function(t, e, i) {
                var n = this._point,
                    r = i && this._handleIn.isZero() ? null : this._handleIn,
                    s = i && this._handleOut.isZero() ? null : this._handleOut,
                    o = n._x,
                    a = n._y,
                    h = 2;
                return e[0] = o, e[1] = a, r && (e[h++] = r._x + o, e[h++] = r._y + a), s && (e[h++] = s._x + o, e[h++] = s._y + a), t && (t._transformCoordinates(e, e, h / 2), o = e[0], a = e[1], i ? (n._x = o, n._y = a, h = 2, r && (r._x = e[h++] - o, r._y = e[h++] - a), s && (s._x = e[h++] - o, s._y = e[h++] - a)) : (r || (e[h++] = o, e[h++] = a), s || (e[h++] = o, e[h++] = a))), e
            }
        }),
        I = c.extend({
            initialize: function(t, i, n) {
                var r, s, o;
                if (t)
                    if ((r = t[0]) !== e) s = t[1];
                    else {
                        var a = t;
                        (r = a.x) === e && (a = c.read(arguments), r = a.x), s = a.y, o = a.selected
                    }
                else r = s = 0;
                this._x = r, this._y = s, this._owner = i, i[n] = this, o && this.setSelected(!0)
            },
            _set: function(t, e) {
                return this._x = t, this._y = e, this._owner._changed(this), this
            },
            getX: function() {
                return this._x
            },
            setX: function(t) {
                this._x = t, this._owner._changed(this)
            },
            getY: function() {
                return this._y
            },
            setY: function(t) {
                this._y = t, this._owner._changed(this)
            },
            isZero: function() {
                var t = u.isZero;
                return t(this._x) && t(this._y)
            },
            isSelected: function() {
                return !!(this._owner._selection & this._getSelection())
            },
            setSelected: function(t) {
                this._owner.changeSelection(this._getSelection(), t)
            },
            _getSelection: function() {
                var t = this._owner;
                return this === t._point ? 1 : this === t._handleIn ? 2 : this === t._handleOut ? 4 : 0
            }
        }),
        A = r.extend({
            _class: "Curve",
            beans: !0,
            initialize: function(t, e, i, n, r, s, o, a) {
                var h, u, l, c, d, f, g = arguments.length;
                3 === g ? (this._path = t, h = e, u = i) : g ? 1 === g ? "segment1" in t ? (h = new k(t.segment1), u = new k(t.segment2)) : "point1" in t ? (l = t.point1, d = t.handle1, f = t.handle2, c = t.point2) : Array.isArray(t) && (l = [t[0], t[1]], c = [t[6], t[7]], d = [t[2] - t[0], t[3] - t[1]], f = [t[4] - t[6], t[5] - t[7]]) : 2 === g ? (h = new k(t), u = new k(e)) : 4 === g ? (l = t, d = e, f = i, c = n) : 8 === g && (l = [t, e], c = [o, a], d = [i - t, n - e], f = [r - o, s - a]) : (h = new k, u = new k), this._segment1 = h || new k(l, null, d), this._segment2 = u || new k(c, f, null)
            },
            _serialize: function(t, e) {
                return r.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], t, !0, e)
            },
            _changed: function() {
                this._length = this._bounds = e
            },
            clone: function() {
                return new A(this._segment1, this._segment2)
            },
            toString: function() {
                var t = ["point1: " + this._segment1._point];
                return this._segment1._handleOut.isZero() || t.push("handle1: " + this._segment1._handleOut), this._segment2._handleIn.isZero() || t.push("handle2: " + this._segment2._handleIn), t.push("point2: " + this._segment2._point), "{ " + t.join(", ") + " }"
            },
            classify: function() {
                return A.classify(this.getValues())
            },
            remove: function() {
                var t = !1;
                if (this._path) {
                    var e = this._segment2,
                        i = e._handleOut;
                    t = e.remove(), t && this._segment1._handleOut.set(i)
                }
                return t
            },
            getPoint1: function() {
                return this._segment1._point
            },
            setPoint1: function() {
                this._segment1._point.set(c.read(arguments))
            },
            getPoint2: function() {
                return this._segment2._point
            },
            setPoint2: function() {
                this._segment2._point.set(c.read(arguments))
            },
            getHandle1: function() {
                return this._segment1._handleOut
            },
            setHandle1: function() {
                this._segment1._handleOut.set(c.read(arguments))
            },
            getHandle2: function() {
                return this._segment2._handleIn
            },
            setHandle2: function() {
                this._segment2._handleIn.set(c.read(arguments))
            },
            getSegment1: function() {
                return this._segment1
            },
            getSegment2: function() {
                return this._segment2
            },
            getPath: function() {
                return this._path
            },
            getIndex: function() {
                return this._segment1._index
            },
            getNext: function() {
                var t = this._path && this._path._curves;
                return t && (t[this._segment1._index + 1] || this._path._closed && t[0]) || null
            },
            getPrevious: function() {
                var t = this._path && this._path._curves;
                return t && (t[this._segment1._index - 1] || this._path._closed && t[t.length - 1]) || null
            },
            isFirst: function() {
                return !this._segment1._index
            },
            isLast: function() {
                var t = this._path;
                return t && this._segment1._index === t._curves.length - 1 || !1
            },
            isSelected: function() {
                return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected()
            },
            setSelected: function(t) {
                this.getPoint1().setSelected(t), this.getHandle1().setSelected(t), this.getHandle2().setSelected(t), this.getPoint2().setSelected(t)
            },
            getValues: function(t) {
                return A.getValues(this._segment1, this._segment2, t)
            },
            getPoints: function() {
                for (var t = this.getValues(), e = [], i = 0; i < 8; i += 2) e.push(new c(t[i], t[i + 1]));
                return e
            }
        }, {
            getLength: function() {
                return null == this._length && (this._length = A.getLength(this.getValues(), 0, 1)), this._length
            },
            getArea: function() {
                return A.getArea(this.getValues())
            },
            getLine: function() {
                return new m(this._segment1._point, this._segment2._point)
            },
            getPart: function(t, e) {
                return new A(A.getPart(this.getValues(), t, e))
            },
            getPartLength: function(t, e) {
                return A.getLength(this.getValues(), t, e)
            },
            divideAt: function(t) {
                return this.divideAtTime(t && t.curve === this ? t.time : this.getTimeAt(t))
            },
            divideAtTime: function(t, e) {
                var i = null;
                if (t >= 1e-8 && t <= 1 - 1e-8) {
                    var n = A.subdivide(this.getValues(), t),
                        r = n[0],
                        s = n[1],
                        o = e || this.hasHandles(),
                        a = this._segment1,
                        h = this._segment2,
                        u = this._path;
                    o && (a._handleOut._set(r[2] - r[0], r[3] - r[1]), h._handleIn._set(s[4] - s[6], s[5] - s[7]));
                    var l = r[6],
                        d = r[7],
                        f = new k(new c(l, d), o && new c(r[4] - l, r[5] - d), o && new c(s[2] - l, s[3] - d));
                    u ? (u.insert(a._index + 1, f), i = this.getNext()) : (this._segment2 = f, this._changed(), i = new A(f, h))
                }
                return i
            },
            splitAt: function(t) {
                var e = this._path;
                return e ? e.splitAt(t) : null
            },
            splitAtTime: function(t) {
                return this.splitAt(this.getLocationAtTime(t))
            },
            divide: function(t, i) {
                return this.divideAtTime(t === e ? .5 : i ? t : this.getTimeAt(t))
            },
            split: function(t, i) {
                return this.splitAtTime(t === e ? .5 : i ? t : this.getTimeAt(t))
            },
            reversed: function() {
                return new A(this._segment2.reversed(), this._segment1.reversed())
            },
            clearHandles: function() {
                this._segment1._handleOut._set(0, 0), this._segment2._handleIn._set(0, 0)
            },
            statics: {
                getValues: function(t, e, i, n) {
                    var r = t._point,
                        s = t._handleOut,
                        o = e._handleIn,
                        a = e._point,
                        h = r.x,
                        u = r.y,
                        l = a.x,
                        c = a.y,
                        d = n ? [h, u, h, u, l, c, l, c] : [h, u, h + s._x, u + s._y, l + o._x, c + o._y, l, c];
                    return i && i._transformCoordinates(d, d, 4), d
                },
                subdivide: function(t, i) {
                    var n = t[0],
                        r = t[1],
                        s = t[2],
                        o = t[3],
                        a = t[4],
                        h = t[5],
                        u = t[6],
                        l = t[7];
                    i === e && (i = .5);
                    var c = 1 - i,
                        d = c * n + i * s,
                        f = c * r + i * o,
                        g = c * s + i * a,
                        p = c * o + i * h,
                        v = c * a + i * u,
                        _ = c * h + i * l,
                        m = c * d + i * g,
                        y = c * f + i * p,
                        w = c * g + i * v,
                        x = c * p + i * _,
                        b = c * m + i * w,
                        S = c * y + i * x;
                    return [
                        [n, r, d, f, m, y, b, S],
                        [b, S, w, x, v, _, u, l]
                    ]
                },
                getMonoCurves: function(t, e) {
                    var i = [],
                        n = e ? 0 : 1,
                        r = t[n + 0],
                        s = t[n + 2],
                        o = t[n + 4],
                        a = t[n + 6];
                    if (r >= s == s >= o && s >= o == o >= a || A.isStraight(t)) i.push(t);
                    else {
                        var h = 3 * (s - o) - r + a,
                            l = 2 * (r + o) - 4 * s,
                            c = s - r,
                            d = [],
                            f = u.solveQuadratic(h, l, c, d, 1e-8, 1 - 1e-8);
                        if (f) {
                            d.sort();
                            var g = d[0],
                                p = A.subdivide(t, g);
                            i.push(p[0]), f > 1 && (g = (d[1] - g) / (1 - g), p = A.subdivide(p[1], g), i.push(p[0])), i.push(p[1])
                        } else i.push(t)
                    }
                    return i
                },
                solveCubic: function(t, e, i, n, r, s) {
                    var o = t[e],
                        a = t[e + 2],
                        h = t[e + 4],
                        l = t[e + 6],
                        c = 0;
                    if (!(o < i && l < i && a < i && h < i || o > i && l > i && a > i && h > i)) {
                        var d = 3 * (a - o),
                            f = 3 * (h - a) - d,
                            g = l - o - d - f;
                        c = u.solveCubic(g, f, d, o - i, n, r, s)
                    }
                    return c
                },
                getTimeOf: function(t, e) {
                    var i = new c(t[0], t[1]),
                        n = new c(t[6], t[7]);
                    if (null === (e.isClose(i, 1e-12) ? 0 : e.isClose(n, 1e-12) ? 1 : null))
                        for (var r = [e.x, e.y], s = [], o = 0; o < 2; o++)
                            for (var a = A.solveCubic(t, o, r[o], s, 0, 1), h = 0; h < a; h++) {
                                var u = s[h];
                                if (e.isClose(A.getPoint(t, u), 1e-7)) return u
                            }
                    return e.isClose(i, 1e-7) ? 0 : e.isClose(n, 1e-7) ? 1 : null
                },
                getNearestTime: function(t, e) {
                    function i(i) {
                        if (i >= 0 && i <= 1) {
                            var n = e.getDistance(A.getPoint(t, i), !0);
                            if (n < d) return d = n, f = i, !0
                        }
                    }
                    if (A.isStraight(t)) {
                        var n = t[0],
                            r = t[1],
                            s = t[6],
                            o = t[7],
                            a = s - n,
                            h = o - r,
                            u = a * a + h * h;
                        if (0 === u) return 0;
                        var l = ((e.x - n) * a + (e.y - r) * h) / u;
                        return l < 1e-12 ? 0 : l > .999999999999 ? 1 : A.getTimeOf(t, new c(n + l * a, r + l * h))
                    }
                    for (var d = 1 / 0, f = 0, g = 0; g <= 100; g++) i(g / 100);
                    for (var p = .005; p > 1e-8;) i(f - p) || i(f + p) || (p /= 2);
                    return f
                },
                getPart: function(t, e, i) {
                    var n = e > i;
                    if (n) {
                        var r = e;
                        e = i, i = r
                    }
                    return e > 0 && (t = A.subdivide(t, e)[1]), i < 1 && (t = A.subdivide(t, (i - e) / (1 - e))[0]), n ? [t[6], t[7], t[4], t[5], t[2], t[3], t[0], t[1]] : t
                },
                isFlatEnough: function(t, e) {
                    var i = t[0],
                        n = t[1],
                        r = t[2],
                        s = t[3],
                        o = t[4],
                        a = t[5],
                        h = t[6],
                        u = t[7],
                        l = 3 * r - 2 * i - h,
                        c = 3 * s - 2 * n - u,
                        d = 3 * o - 2 * h - i,
                        f = 3 * a - 2 * u - n;
                    return Math.max(l * l, d * d) + Math.max(c * c, f * f) <= 16 * e * e
                },
                getArea: function(t) {
                    var e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        s = t[4],
                        o = t[5],
                        a = t[6],
                        h = t[7];
                    return 3 * ((h - i) * (n + s) - (a - e) * (r + o) + r * (e - s) - n * (i - o) + h * (s + e / 3) - a * (o + i / 3)) / 20
                },
                getBounds: function(t) {
                    for (var e = t.slice(0, 2), i = e.slice(), n = [0, 0], r = 0; r < 2; r++) A._addBounds(t[r], t[r + 2], t[r + 4], t[r + 6], r, 0, e, i, n);
                    return new p(e[0], e[1], i[0] - e[0], i[1] - e[1])
                },
                _addBounds: function(t, e, i, n, r, s, o, a, h) {
                    function l(t, e) {
                        var i = t - e,
                            n = t + e;
                        i < o[r] && (o[r] = i), n > a[r] && (a[r] = n)
                    }
                    s /= 2;
                    var c = o[r] - s,
                        d = a[r] + s;
                    if (t < c || e < c || i < c || n < c || t > d || e > d || i > d || n > d)
                        if (e < t != e < n && i < t != i < n) l(t, s), l(n, s);
                        else {
                            var f = 3 * (e - i) - t + n,
                                g = 2 * (t + i) - 4 * e,
                                p = e - t,
                                v = u.solveQuadratic(f, g, p, h);
                            l(n, 0);
                            for (var _ = 0; _ < v; _++) {
                                var m = h[_],
                                    y = 1 - m;
                                1e-8 <= m && m <= 1 - 1e-8 && l(y * y * y * t + 3 * y * y * m * e + 3 * y * m * m * i + m * m * m * n, s)
                            }
                        }
                }
            }
        }, r.each(["getBounds", "getStrokeBounds", "getHandleBounds"], function(t) {
            this[t] = function() {
                this._bounds || (this._bounds = {});
                var e = this._bounds[t];
                return e || (e = this._bounds[t] = O[t]([this._segment1, this._segment2], !1, this._path)), e.clone()
            }
        }, {}), r.each({
            isStraight: function(t, e, i, n) {
                if (e.isZero() && i.isZero()) return !0;
                var r = n.subtract(t);
                if (r.isZero()) return !1;
                if (r.isCollinear(e) && r.isCollinear(i)) {
                    var s = new m(t, n);
                    if (s.getDistance(t.add(e)) < 1e-7 && s.getDistance(n.add(i)) < 1e-7) {
                        var o = r.dot(r),
                            a = r.dot(e) / o,
                            h = r.dot(i) / o;
                        return a >= 0 && a <= 1 && h <= 0 && h >= -1
                    }
                }
                return !1
            },
            isLinear: function(t, e, i, n) {
                var r = n.subtract(t).divide(3);
                return e.equals(r) && i.negate().equals(r)
            }
        }, function(t, e) {
            this[e] = function(e) {
                var i = this._segment1,
                    n = this._segment2;
                return t(i._point, i._handleOut, n._handleIn, n._point, e)
            }, this.statics[e] = function(e, i) {
                var n = e[0],
                    r = e[1],
                    s = e[6],
                    o = e[7];
                return t(new c(n, r), new c(e[2] - n, e[3] - r), new c(e[4] - s, e[5] - o), new c(s, o), i)
            }
        }, {
            statics: {},
            hasHandles: function() {
                return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero()
            },
            hasLength: function(t) {
                return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (t || 0)
            },
            isCollinear: function(t) {
                return t && this.isStraight() && t.isStraight() && this.getLine().isCollinear(t.getLine())
            },
            isHorizontal: function() {
                return this.isStraight() && Math.abs(this.getTangentAtTime(.5).y) < 1e-8
            },
            isVertical: function() {
                return this.isStraight() && Math.abs(this.getTangentAtTime(.5).x) < 1e-8
            }
        }), {
            beans: !1,
            getLocationAt: function(t, e) {
                return this.getLocationAtTime(e ? t : this.getTimeAt(t))
            },
            getLocationAtTime: function(t) {
                return null != t && t >= 0 && t <= 1 ? new P(this, t) : null
            },
            getTimeAt: function(t, e) {
                return A.getTimeAt(this.getValues(), t, e)
            },
            getParameterAt: "#getTimeAt",
            getOffsetAtTime: function(t) {
                return this.getPartLength(0, t)
            },
            getLocationOf: function() {
                return this.getLocationAtTime(this.getTimeOf(c.read(arguments)))
            },
            getOffsetOf: function() {
                var t = this.getLocationOf.apply(this, arguments);
                return t ? t.getOffset() : null
            },
            getTimeOf: function() {
                return A.getTimeOf(this.getValues(), c.read(arguments))
            },
            getParameterOf: "#getTimeOf",
            getNearestLocation: function() {
                var t = c.read(arguments),
                    e = this.getValues(),
                    i = A.getNearestTime(e, t),
                    n = A.getPoint(e, i);
                return new P(this, i, n, null, t.getDistance(n))
            },
            getNearestPoint: function() {
                var t = this.getNearestLocation.apply(this, arguments);
                return t ? t.getPoint() : t
            }
        }, new function() {
            var t = ["getPoint", "getTangent", "getNormal", "getWeightedTangent", "getWeightedNormal", "getCurvature"];
            return r.each(t, function(t) {
                this[t + "At"] = function(e, i) {
                    var n = this.getValues();
                    return A[t](n, i ? e : A.getTimeAt(n, e))
                }, this[t + "AtTime"] = function(e) {
                    return A[t](this.getValues(), e)
                }
            }, {
                statics: {
                    _evaluateMethods: t
                }
            })
        }, new function() {
            function t(t) {
                var e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    s = t[4],
                    o = t[5],
                    a = t[6],
                    h = t[7],
                    u = 9 * (n - s) + 3 * (a - e),
                    l = 6 * (e + s) - 12 * n,
                    c = 3 * (n - e),
                    d = 9 * (r - o) + 3 * (h - i),
                    f = 6 * (i + o) - 12 * r,
                    g = 3 * (r - i);
                return function(t) {
                    var e = (u * t + l) * t + c,
                        i = (d * t + f) * t + g;
                    return Math.sqrt(e * e + i * i)
                }
            }

            function i(t, e) {
                return Math.max(2, Math.min(16, Math.ceil(32 * Math.abs(e - t))))
            }

            function n(t, e, i, n) {
                if (null == e || e < 0 || e > 1) return null;
                var r = t[0],
                    s = t[1],
                    o = t[2],
                    a = t[3],
                    h = t[4],
                    l = t[5],
                    d = t[6],
                    f = t[7],
                    g = u.isZero;
                g(o - r) && g(a - s) && (o = r, a = s), g(h - d) && g(l - f) && (h = d, l = f);
                var p, v, _ = 3 * (o - r),
                    m = 3 * (h - o) - _,
                    y = d - r - _ - m,
                    w = 3 * (a - s),
                    x = 3 * (l - a) - w,
                    b = f - s - w - x;
                if (0 === i) p = 0 === e ? r : 1 === e ? d : ((y * e + m) * e + _) * e + r, v = 0 === e ? s : 1 === e ? f : ((b * e + x) * e + w) * e + s;
                else {
                    if (e < 1e-8 ? (p = _, v = w) : e > 1 - 1e-8 ? (p = 3 * (d - h), v = 3 * (f - l)) : (p = (3 * y * e + 2 * m) * e + _, v = (3 * b * e + 2 * x) * e + w), n) {
                        0 === p && 0 === v && (e < 1e-8 || e > 1 - 1e-8) && (p = h - o, v = l - a);
                        var S = Math.sqrt(p * p + v * v);
                        S && (p /= S, v /= S)
                    }
                    if (3 === i) {
                        var h = 6 * y * e + 2 * m,
                            l = 6 * b * e + 2 * x,
                            C = Math.pow(p * p + v * v, 1.5);
                        p = 0 !== C ? (p * l - v * h) / C : 0, v = 0
                    }
                }
                return 2 === i ? new c(v, -p) : new c(p, v)
            }
            return {
                statics: {
                    classify: function(t) {
                        function i(t, i, n) {
                            var r = i !== e,
                                s = r && i > 0 && i < 1,
                                o = r && n > 0 && n < 1;
                            return !r || (s || o) && ("loop" !== t || s && o) || (t = "arch", s = o = !1), {
                                type: t,
                                roots: s || o ? s && o ? i < n ? [i, n] : [n, i] : [s ? i : n] : null
                            }
                        }
                        var n = t[0],
                            r = t[1],
                            s = t[2],
                            o = t[3],
                            a = t[4],
                            h = t[5],
                            l = t[6],
                            c = t[7],
                            d = n * (c - h) + r * (a - l) + l * h - c * a,
                            f = s * (r - c) + o * (l - n) + n * c - r * l,
                            g = a * (o - r) + h * (n - s) + s * r - o * n,
                            p = 3 * g,
                            v = p - f,
                            _ = v - f + d,
                            m = Math.sqrt(_ * _ + v * v + p * p),
                            y = 0 !== m ? 1 / m : 0,
                            w = u.isZero;
                        if (_ *= y, v *= y, p *= y, w(_)) return w(v) ? i(w(p) ? "line" : "quadratic") : i("serpentine", p / (3 * v));
                        var x = 3 * v * v - 4 * _ * p;
                        if (w(x)) return i("cusp", v / (2 * _));
                        var b = x > 0 ? Math.sqrt(x / 3) : Math.sqrt(-x),
                            S = 2 * _;
                        return i(x > 0 ? "serpentine" : "loop", (v + b) / S, (v - b) / S)
                    },
                    getLength: function(n, r, s, o) {
                        if (r === e && (r = 0), s === e && (s = 1), A.isStraight(n)) {
                            var a = n;
                            s < 1 && (a = A.subdivide(a, s)[0], r /= s), r > 0 && (a = A.subdivide(a, r)[1]);
                            var h = a[6] - a[0],
                                l = a[7] - a[1];
                            return Math.sqrt(h * h + l * l)
                        }
                        return u.integrate(o || t(n), r, s, i(r, s))
                    },
                    getTimeAt: function(n, r, s) {
                        function o(t) {
                            return v += u.integrate(d, s, t, i(s, t)), s = t, v - r
                        }
                        if (s === e && (s = r < 0 ? 1 : 0), 0 === r) return s;
                        var a = Math.abs,
                            h = r > 0,
                            l = h ? s : 0,
                            c = h ? 1 : s,
                            d = t(n),
                            f = A.getLength(n, l, c, d),
                            g = a(r) - f;
                        if (a(g) < 1e-12) return h ? c : l;
                        if (g > 1e-12) return null;
                        var p = r / f,
                            v = 0;
                        return u.findRoot(o, d, s + p, l, c, 32, 1e-12)
                    },
                    getPoint: function(t, e) {
                        return n(t, e, 0, !1)
                    },
                    getTangent: function(t, e) {
                        return n(t, e, 1, !0)
                    },
                    getWeightedTangent: function(t, e) {
                        return n(t, e, 1, !1)
                    },
                    getNormal: function(t, e) {
                        return n(t, e, 2, !0)
                    },
                    getWeightedNormal: function(t, e) {
                        return n(t, e, 2, !1)
                    },
                    getCurvature: function(t, e) {
                        return n(t, e, 3, !1).x
                    },
                    getPeaks: function(t) {
                        var e = t[0],
                            i = t[1],
                            n = t[2],
                            r = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            h = t[7],
                            l = 3 * n - e - 3 * s + a,
                            c = 3 * e - 6 * n + 3 * s,
                            d = -3 * e + 3 * n,
                            f = 3 * r - i - 3 * o + h,
                            g = 3 * i - 6 * r + 3 * o,
                            p = -3 * i + 3 * r,
                            v = [];
                        return u.solveCubic(9 * (l * l + f * f), 9 * (l * c + g * f), 2 * (c * c + g * g) + 3 * (d * l + p * f), d * c + g * p, v, 1e-8, 1 - 1e-8), v.sort()
                    }
                }
            }
        }, new function() {
            function t(t, e, i, n, r, s, o) {
                var a = !o && i.getPrevious() === r,
                    h = !o && i !== r && i.getNext() === r;
                if (null !== n && n >= (a ? 1e-8 : 0) && n <= (h ? 1 - 1e-8 : 1) && null !== s && s >= (h ? 1e-8 : 0) && s <= (a ? 1 - 1e-8 : 1)) {
                    var u = new P(i, n, null, o),
                        l = new P(r, s, null, o);
                    u._intersection = l, l._intersection = u, e && !e(u) || P.insert(t, u, !0)
                }
            }

            function e(r, s, o, a, h, u, l, c, d, f, g, p, v) {
                if (++d >= 4096 || ++c >= 40) return d;
                var _, y, w = s[0],
                    x = s[1],
                    b = s[6],
                    S = s[7],
                    C = m.getSignedDistance,
                    T = C(w, x, b, S, s[2], s[3]),
                    E = C(w, x, b, S, s[4], s[5]),
                    z = T * E > 0 ? .75 : 4 / 9,
                    k = z * Math.min(0, T, E),
                    I = z * Math.max(0, T, E),
                    P = C(w, x, b, S, r[0], r[1]),
                    M = C(w, x, b, S, r[2], r[3]),
                    O = C(w, x, b, S, r[4], r[5]),
                    L = C(w, x, b, S, r[6], r[7]),
                    N = i(P, M, O, L),
                    F = N[0],
                    D = N[1];
                if (0 === T && 0 === E && 0 === P && 0 === M && 0 === O && 0 === L || null == (_ = n(F, D, k, I)) || null == (y = n(F.reverse(), D.reverse(), k, I))) return d;
                var R = f + (g - f) * _,
                    B = f + (g - f) * y;
                if (Math.max(v - p, B - R) < 1e-9) {
                    var j = (R + B) / 2,
                        q = (p + v) / 2;
                    t(h, u, l ? a : o, l ? q : j, l ? o : a, l ? j : q)
                } else if (r = A.getPart(r, _, y), y - _ > .8)
                    if (B - R > v - p) {
                        var H = A.subdivide(r, .5),
                            j = (R + B) / 2;
                        d = e(s, H[0], a, o, h, u, !l, c, d, p, v, R, j), d = e(s, H[1], a, o, h, u, !l, c, d, p, v, j, B)
                    } else {
                        var H = A.subdivide(s, .5),
                            q = (p + v) / 2;
                        d = e(H[0], r, a, o, h, u, !l, c, d, p, q, R, B), d = e(H[1], r, a, o, h, u, !l, c, d, q, v, R, B)
                    }
                else d = v - p >= 1e-9 ? e(s, r, a, o, h, u, !l, c, d, p, v, R, B) : e(r, s, o, a, h, u, l, c, d, R, B, p, v);
                return d
            }

            function i(t, e, i, n) {
                var r, s = [0, t],
                    o = [1 / 3, e],
                    a = [2 / 3, i],
                    h = [1, n],
                    u = e - (2 * t + n) / 3,
                    l = i - (t + 2 * n) / 3;
                if (u * l < 0) r = [
                    [s, o, h],
                    [s, a, h]
                ];
                else {
                    var c = u / l;
                    r = [c >= 2 ? [s, o, h] : c <= .5 ? [s, a, h] : [s, o, a, h],
                        [s, h]
                    ]
                }
                return (u || l) < 0 ? r.reverse() : r
            }

            function n(t, e, i, n) {
                return t[0][1] < i ? r(t, !0, i) : e[0][1] > n ? r(e, !1, n) : t[0][0]
            }

            function r(t, e, i) {
                for (var n = t[0][0], r = t[0][1], s = 1, o = t.length; s < o; s++) {
                    var a = t[s][0],
                        h = t[s][1];
                    if (e ? h >= i : h <= i) return h === i ? a : n + (i - r) * (a - n) / (h - r);
                    n = a, r = h
                }
                return null
            }

            function s(t, e, i, n, r) {
                var s = u.isZero;
                if (s(n) && s(r)) {
                    var o = A.getTimeOf(t, new c(e, i));
                    return null === o ? [] : [o]
                }
                for (var a = Math.atan2(-r, n), h = Math.sin(a), l = Math.cos(a), d = [], f = [], g = 0; g < 8; g += 2) {
                    var p = t[g] - e,
                        v = t[g + 1] - i;
                    d.push(p * l - v * h, p * h + v * l)
                }
                return A.solveCubic(d, 1, 0, f, 0, 1), f
            }

            function o(e, i, n, r, o, a, h) {
                for (var u = i[0], l = i[1], c = i[6], d = i[7], f = s(e, u, l, c - u, d - l), g = 0, p = f.length; g < p; g++) {
                    var v = f[g],
                        _ = A.getPoint(e, v),
                        m = A.getTimeOf(i, _);
                    null !== m && t(o, a, h ? r : n, h ? m : v, h ? n : r, h ? v : m)
                }
            }

            function a(e, i, n, r, s, o) {
                var a = m.intersect(e[0], e[1], e[6], e[7], i[0], i[1], i[6], i[7]);
                a && t(s, o, n, A.getTimeOf(e, a), r, A.getTimeOf(i, a))
            }

            function h(i, n, r, s, h, u) {
                var l = Math.min,
                    d = Math.max;
                if (d(i[0], i[2], i[4], i[6]) + 1e-12 > l(n[0], n[2], n[4], n[6]) && l(i[0], i[2], i[4], i[6]) - 1e-12 < d(n[0], n[2], n[4], n[6]) && d(i[1], i[3], i[5], i[7]) + 1e-12 > l(n[1], n[3], n[5], n[7]) && l(i[1], i[3], i[5], i[7]) - 1e-12 < d(n[1], n[3], n[5], n[7])) {
                    var g = f(i, n);
                    if (g)
                        for (var p = 0; p < 2; p++) {
                            var v = g[p];
                            t(h, u, r, v[0], s, v[1], !0)
                        } else {
                            var _ = A.isStraight(i),
                                m = A.isStraight(n),
                                y = _ && m,
                                w = _ && !m,
                                x = h.length;
                            if ((y ? a : _ || m ? o : e)(w ? n : i, w ? i : n, w ? s : r, w ? r : s, h, u, w, 0, 0, 0, 1, 0, 1), !y || h.length === x)
                                for (var p = 0; p < 4; p++) {
                                    var b = p >> 1,
                                        S = 1 & p,
                                        C = 6 * b,
                                        T = 6 * S,
                                        E = new c(i[C], i[C + 1]),
                                        z = new c(n[T], n[T + 1]);
                                    E.isClose(z, 1e-12) && t(h, u, r, b, s, S)
                                }
                        }
                }
                return h
            }

            function l(e, i, n, r) {
                var s = A.classify(e);
                if ("loop" === s.type) {
                    var o = s.roots;
                    t(n, r, i, o[0], i, o[1])
                }
                return n
            }

            function d(t, e, i, n, r, s) {
                var o = !e;
                o && (e = t);
                for (var a, u, c = t.length, d = e.length, f = [], g = [], p = 0; p < d; p++) f[p] = e[p].getValues(r);
                for (var p = 0; p < c; p++) {
                    var v = t[p],
                        _ = o ? f[p] : v.getValues(n),
                        m = v.getPath();
                    m !== u && (u = m, a = [], g.push(a)), o && l(_, v, a, i);
                    for (var y = o ? p + 1 : 0; y < d; y++) {
                        if (s && a.length) return a;
                        h(_, f[y], v, e[y], a, i)
                    }
                }
                a = [];
                for (var p = 0, w = g.length; p < w; p++) a.push.apply(a, g[p]);
                return a
            }

            function f(t, e) {
                function i(t) {
                    var e = t[6] - t[0],
                        i = t[7] - t[1];
                    return e * e + i * i
                }
                var n = Math.abs,
                    r = m.getDistance,
                    s = A.isStraight(t),
                    o = A.isStraight(e),
                    a = s && o,
                    h = i(t) < i(e),
                    u = h ? e : t,
                    l = h ? t : e,
                    d = u[0],
                    f = u[1],
                    g = u[6] - d,
                    p = u[7] - f;
                if (r(d, f, g, p, l[0], l[1], !0) < 1e-7 && r(d, f, g, p, l[6], l[7], !0) < 1e-7) !a && r(d, f, g, p, u[2], u[3], !0) < 1e-7 && r(d, f, g, p, u[4], u[5], !0) < 1e-7 && r(d, f, g, p, l[2], l[3], !0) < 1e-7 && r(d, f, g, p, l[4], l[5], !0) < 1e-7 && (s = o = a = !0);
                else if (a) return null;
                if (s ^ o) return null;
                for (var v = [t, e], _ = [], y = 0; y < 4 && _.length < 2; y++) {
                    var w = 1 & y,
                        x = 1 ^ w,
                        b = y >> 1,
                        S = A.getTimeOf(v[w], new c(v[x][b ? 6 : 0], v[x][b ? 7 : 1]));
                    if (null != S) {
                        var C = w ? [b, S] : [S, b];
                        (!_.length || n(C[0] - _[0][0]) > 1e-8 && n(C[1] - _[0][1]) > 1e-8) && _.push(C)
                    }
                    if (y > 2 && !_.length) break
                }
                if (2 !== _.length) _ = null;
                else if (!a) {
                    var T = A.getPart(t, _[0][0], _[1][0]),
                        E = A.getPart(e, _[0][1], _[1][1]);
                    (n(E[2] - T[2]) > 1e-7 || n(E[3] - T[3]) > 1e-7 || n(E[4] - T[4]) > 1e-7 || n(E[5] - T[5]) > 1e-7) && (_ = null)
                }
                return _
            }
            return {
                getIntersections: function(t) {
                    var e = this.getValues(),
                        i = t && t !== this && t.getValues();
                    return i ? h(e, i, this, t, []) : l(e, this, [])
                },
                statics: {
                    getOverlaps: f,
                    getIntersections: d,
                    getCurveLineIntersections: s
                }
            }
        }),
        P = r.extend({
            _class: "CurveLocation",
            initialize: function(t, e, i, n, r) {
                if (e >= .99999999) {
                    var s = t.getNext();
                    s && (e = 0, t = s)
                }
                this._setCurve(t), this._time = e, this._point = i || t.getPointAtTime(e), this._overlap = n, this._distance = r, this._intersection = this._next = this._previous = null
            },
            _setCurve: function(t) {
                var e = t._path;
                this._path = e, this._version = e ? e._version : 0, this._curve = t, this._segment = null, this._segment1 = t._segment1, this._segment2 = t._segment2
            },
            _setSegment: function(t) {
                this._setCurve(t.getCurve()), this._segment = t, this._time = t === this._segment1 ? 0 : 1, this._point = t._point.clone()
            },
            getSegment: function() {
                var t = this._segment;
                if (!t) {
                    var e = this.getCurve(),
                        i = this.getTime();
                    0 === i ? t = e._segment1 : 1 === i ? t = e._segment2 : null != i && (t = e.getPartLength(0, i) < e.getPartLength(i, 1) ? e._segment1 : e._segment2), this._segment = t
                }
                return t
            },
            getCurve: function() {
                function t(t) {
                    var e = t && t.getCurve();
                    if (e && null != (i._time = e.getTimeOf(i._point))) return i._setCurve(e), e
                }
                var e = this._path,
                    i = this;
                return e && e._version !== this._version && (this._time = this._offset = this._curveOffset = this._curve = null), this._curve || t(this._segment) || t(this._segment1) || t(this._segment2.getPrevious())
            },
            getPath: function() {
                var t = this.getCurve();
                return t && t._path
            },
            getIndex: function() {
                var t = this.getCurve();
                return t && t.getIndex()
            },
            getTime: function() {
                var t = this.getCurve(),
                    e = this._time;
                return t && null == e ? this._time = t.getTimeOf(this._point) : e
            },
            getParameter: "#getTime",
            getPoint: function() {
                return this._point
            },
            getOffset: function() {
                var t = this._offset;
                if (null == t) {
                    t = 0;
                    var e = this.getPath(),
                        i = this.getIndex();
                    if (e && null != i)
                        for (var n = e.getCurves(), r = 0; r < i; r++) t += n[r].getLength();
                    this._offset = t += this.getCurveOffset()
                }
                return t
            },
            getCurveOffset: function() {
                var t = this._curveOffset;
                if (null == t) {
                    var e = this.getCurve(),
                        i = this.getTime();
                    this._curveOffset = t = null != i && e && e.getPartLength(0, i)
                }
                return t
            },
            getIntersection: function() {
                return this._intersection
            },
            getDistance: function() {
                return this._distance
            },
            divide: function() {
                var t = this.getCurve(),
                    e = t && t.divideAtTime(this.getTime());
                return e && this._setSegment(e._segment1), e
            },
            split: function() {
                var t = this.getCurve(),
                    e = t._path,
                    i = t && t.splitAtTime(this.getTime());
                return i && this._setSegment(e.getLastSegment()), i
            },
            equals: function(t, e) {
                var i = this === t;
                if (!i && t instanceof P) {
                    var n = this.getCurve(),
                        r = t.getCurve(),
                        s = n._path;
                    if (s === r._path) {
                        var o = Math.abs,
                            a = o(this.getOffset() - t.getOffset()),
                            h = !e && this._intersection,
                            u = !e && t._intersection;
                        i = (a < 1e-7 || s && o(s.getLength() - a) < 1e-7) && (!h && !u || h && u && h.equals(u, !0))
                    }
                }
                return i
            },
            toString: function() {
                var t = [],
                    e = this.getPoint(),
                    i = h.instance;
                e && t.push("point: " + e);
                var n = this.getIndex();
                null != n && t.push("index: " + n);
                var r = this.getTime();
                return null != r && t.push("time: " + i.number(r)), null != this._distance && t.push("distance: " + i.number(this._distance)), "{ " + t.join(", ") + " }"
            },
            isTouching: function() {
                var t = this._intersection;
                if (t && this.getTangent().isCollinear(t.getTangent())) {
                    var e = this.getCurve(),
                        i = t.getCurve();
                    return !(e.isStraight() && i.isStraight() && e.getLine().intersect(i.getLine()))
                }
                return !1
            },
            isCrossing: function() {
                function t(t, e) {
                    var i = t.getValues(),
                        n = A.classify(i).roots || A.getPeaks(i),
                        r = n.length,
                        s = e && r > 1 ? n[r - 1] : r > 0 ? n[0] : .5;
                    c.push(A.getLength(i, e ? s : 0, e ? 1 : s) / 2)
                }

                function e(t, e, i) {
                    return e < i ? t > e && t < i : t > e || t < i
                }
                var i = this._intersection;
                if (!i) return !1;
                var n = this.getTime(),
                    r = i.getTime(),
                    s = n >= 1e-8 && n <= 1 - 1e-8,
                    o = r >= 1e-8 && r <= 1 - 1e-8;
                if (s && o) return !this.isTouching();
                var a = this.getCurve(),
                    h = n < 1e-8 ? a.getPrevious() : a,
                    u = i.getCurve(),
                    l = r < 1e-8 ? u.getPrevious() : u;
                if (n > 1 - 1e-8 && (a = a.getNext()), r > 1 - 1e-8 && (u = u.getNext()), !(h && a && l && u)) return !1;
                var c = [];
                s || (t(h, !0), t(a, !1)), o || (t(l, !0), t(u, !1));
                var d = this.getPoint(),
                    f = Math.min.apply(Math, c),
                    g = s ? a.getTangentAtTime(n) : a.getPointAt(f).subtract(d),
                    p = s ? g.negate() : h.getPointAt(-f).subtract(d),
                    v = o ? u.getTangentAtTime(r) : u.getPointAt(f).subtract(d),
                    _ = o ? v.negate() : l.getPointAt(-f).subtract(d),
                    m = p.getAngle(),
                    y = g.getAngle(),
                    w = _.getAngle(),
                    x = v.getAngle();
                return !!(s ? e(m, w, x) ^ e(y, w, x) && e(m, x, w) ^ e(y, x, w) : e(w, m, y) ^ e(x, m, y) && e(w, y, m) ^ e(x, y, m))
            },
            hasOverlap: function() {
                return !!this._overlap
            }
        }, r.each(A._evaluateMethods, function(t) {
            var e = t + "At";
            this[t] = function() {
                var t = this.getCurve(),
                    i = this.getTime();
                return null != i && t && t[e](i, !0)
            }
        }, {
            preserve: !0
        }), new function() {
            function t(t, e, i) {
                function n(i, n) {
                    for (var s = i + n; s >= -1 && s <= r; s += n) {
                        var o = t[(s % r + r) % r];
                        if (!e.getPoint().isClose(o.getPoint(), 1e-7)) break;
                        if (e.equals(o)) return o
                    }
                    return null
                }
                for (var r = t.length, s = 0, o = r - 1; s <= o;) {
                    var a, h = s + o >>> 1,
                        u = t[h];
                    if (i && (a = e.equals(u) ? u : n(h, -1) || n(h, 1))) return e._overlap && (a._overlap = a._intersection._overlap = !0), a;
                    var l = e.getPath(),
                        c = u.getPath();
                    (l !== c ? l._id - c._id : e.getIndex() + e.getTime() - (u.getIndex() + u.getTime())) < 0 ? o = h - 1 : s = h + 1
                }
                return t.splice(s, 0, e), e
            }
            return {
                statics: {
                    insert: t,
                    expand: function(e) {
                        for (var i = e.slice(), n = e.length - 1; n >= 0; n--) t(i, e[n]._intersection, !1);
                        return i
                    }
                }
            }
        }),
        M = w.extend({
            _class: "PathItem",
            _selectBounds: !1,
            _canScaleStroke: !0,
            beans: !0,
            initialize: function() {},
            statics: {
                create: function(t) {
                    var e, i, n;
                    if (r.isPlainObject(t) ? (i = t.segments, e = t.pathData) : Array.isArray(t) ? i = t : "string" == typeof t && (e = t), i) {
                        var s = i[0];
                        n = s && Array.isArray(s[0])
                    } else e && (n = (e.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(e));
                    return new(n ? L : O)(t)
                }
            },
            _asPathItem: function() {
                return this
            },
            isClockwise: function() {
                return this.getArea() >= 0
            },
            setClockwise: function(t) {
                this.isClockwise() != (t = !!t) && this.reverse()
            },
            setPathData: function(t) {
                function e(t, e) {
                    var i = +n[t];
                    return a && (i += h[e]), i
                }

                function i(t) {
                    return new c(e(t, "x"), e(t + 1, "y"))
                }
                var n, r, s, o = t && t.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi),
                    a = !1,
                    h = new c,
                    u = new c;
                this.clear();
                for (var l = 0, d = o && o.length; l < d; l++) {
                    var g = o[l],
                        p = g[0],
                        v = p.toLowerCase();
                    n = g.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                    var _ = n && n.length;
                    switch (a = p === v, "z" !== r || /[mz]/.test(v) || this.moveTo(h), v) {
                        case "m":
                        case "l":
                            for (var m = "m" === v, y = 0; y < _; y += 2) this[m ? "moveTo" : "lineTo"](h = i(y)), m && (u = h, m = !1);
                            s = h;
                            break;
                        case "h":
                        case "v":
                            var w = "h" === v ? "x" : "y";
                            h = h.clone();
                            for (var y = 0; y < _; y++) h[w] = e(y, w), this.lineTo(h);
                            s = h;
                            break;
                        case "c":
                            for (var y = 0; y < _; y += 6) this.cubicCurveTo(i(y), s = i(y + 2), h = i(y + 4));
                            break;
                        case "s":
                            for (var y = 0; y < _; y += 4) this.cubicCurveTo(/[cs]/.test(r) ? h.multiply(2).subtract(s) : h, s = i(y), h = i(y + 2)), r = v;
                            break;
                        case "q":
                            for (var y = 0; y < _; y += 4) this.quadraticCurveTo(s = i(y), h = i(y + 2));
                            break;
                        case "t":
                            for (var y = 0; y < _; y += 2) this.quadraticCurveTo(s = /[qt]/.test(r) ? h.multiply(2).subtract(s) : h, h = i(y)), r = v;
                            break;
                        case "a":
                            for (var y = 0; y < _; y += 7) this.arcTo(h = i(y + 5), new f(+n[y], +n[y + 1]), +n[y + 2], +n[y + 4], +n[y + 3]);
                            break;
                        case "z":
                            this.closePath(1e-12), h = u
                    }
                    r = v
                }
            },
            _canComposite: function() {
                return !(this.hasFill() && this.hasStroke())
            },
            _contains: function(t) {
                var e = t.isInside(this.getBounds({
                    internal: !0,
                    handle: !0
                })) ? this._getWinding(t) : {};
                return e.onPath || !!("evenodd" === this.getFillRule() ? 1 & e.windingL || 1 & e.windingR : e.winding)
            },
            getIntersections: function(t, e, i, n) {
                var r = this === t || !t,
                    s = this._matrix._orNullIfIdentity(),
                    o = r ? s : (i || t._matrix)._orNullIfIdentity();
                return r || this.getBounds(s).intersects(t.getBounds(o), 1e-12) ? A.getIntersections(this.getCurves(), !r && t.getCurves(), e, s, o, n) : []
            },
            getCrossings: function(t) {
                return this.getIntersections(t, function(t) {
                    return t.hasOverlap() || t.isCrossing()
                })
            },
            getNearestLocation: function() {
                for (var t = c.read(arguments), e = this.getCurves(), i = 1 / 0, n = null, r = 0, s = e.length; r < s; r++) {
                    var o = e[r].getNearestLocation(t);
                    o._distance < i && (i = o._distance, n = o)
                }
                return n
            },
            getNearestPoint: function() {
                var t = this.getNearestLocation.apply(this, arguments);
                return t ? t.getPoint() : t
            },
            interpolate: function(t, e, i) {
                var n = !this._children,
                    r = n ? "_segments" : "_children",
                    s = t[r],
                    o = e[r],
                    a = this[r];
                if (!s || !o || s.length !== o.length) throw new Error("Invalid operands in interpolate() call: " + t + ", " + e);
                var h = a.length,
                    u = o.length;
                if (h < u)
                    for (var l = n ? k : O, c = h; c < u; c++) this.add(new l);
                else h > u && this[n ? "removeSegments" : "removeChildren"](u, h);
                for (var c = 0; c < u; c++) a[c].interpolate(s[c], o[c], i);
                n && (this.setClosed(t._closed), this._changed(9))
            },
            compare: function(t) {
                var e = !1;
                if (t) {
                    var i = this._children || [this],
                        n = t._children ? t._children.slice() : [t],
                        r = i.length,
                        s = n.length,
                        o = [],
                        a = 0;
                    e = !0;
                    for (var h = r - 1; h >= 0 && e; h--) {
                        var u = i[h];
                        e = !1;
                        for (var l = s - 1; l >= 0 && !e; l--) u.compare(n[l]) && (o[l] || (o[l] = !0, a++), e = !0)
                    }
                    e = e && a === s
                }
                return e
            }
        }),
        O = M.extend({
            _class: "Path",
            _serializeFields: {
                segments: [],
                closed: !1
            },
            initialize: function(t) {
                this._closed = !1, this._segments = [], this._version = 0;
                var i = Array.isArray(t) ? "object" == typeof t[0] ? t : arguments : !t || t.size !== e || t.x === e && t.point === e ? null : arguments;
                i && i.length > 0 ? this.setSegments(i) : (this._curves = e, this._segmentSelection = 0, i || "string" != typeof t || (this.setPathData(t), t = null)), this._initialize(!i && t)
            },
            _equals: function(t) {
                return this._closed === t._closed && r.equals(this._segments, t._segments)
            },
            copyContent: function(t) {
                this.setSegments(t._segments), this._closed = t._closed
            },
            _changed: function t(i) {
                if (t.base.call(this, i), 8 & i) {
                    if (this._length = this._area = e, 16 & i) this._version++;
                    else if (this._curves)
                        for (var n = 0, r = this._curves.length; n < r; n++) this._curves[n]._changed()
                } else 32 & i && (this._bounds = e)
            },
            getStyle: function() {
                var t = this._parent;
                return (t instanceof L ? t : this)._style
            },
            getSegments: function() {
                return this._segments
            },
            setSegments: function(t) {
                var i = this.isFullySelected(),
                    n = t && t.length;
                if (this._segments.length = 0, this._segmentSelection = 0, this._curves = e, n) {
                    var r = t[n - 1];
                    "boolean" == typeof r && (this.setClosed(r), n--), this._add(k.readList(t, 0, {}, n))
                }
                i && this.setFullySelected(!0)
            },
            getFirstSegment: function() {
                return this._segments[0]
            },
            getLastSegment: function() {
                return this._segments[this._segments.length - 1]
            },
            getCurves: function() {
                var t = this._curves,
                    e = this._segments;
                if (!t) {
                    var i = this._countCurves();
                    t = this._curves = new Array(i);
                    for (var n = 0; n < i; n++) t[n] = new A(this, e[n], e[n + 1] || e[0])
                }
                return t
            },
            getFirstCurve: function() {
                return this.getCurves()[0]
            },
            getLastCurve: function() {
                var t = this.getCurves();
                return t[t.length - 1]
            },
            isClosed: function() {
                return this._closed
            },
            setClosed: function(t) {
                if (this._closed != (t = !!t)) {
                    if (this._closed = t, this._curves) {
                        var e = this._curves.length = this._countCurves();
                        t && (this._curves[e - 1] = new A(this, this._segments[e - 1], this._segments[0]))
                    }
                    this._changed(25)
                }
            }
        }, {
            beans: !0,
            getPathData: function(t, e) {
                function i(e, i) {
                    if (e._transformCoordinates(t, p), n = p[0], r = p[1], v) _.push("M" + g.pair(n, r)), v = !1;
                    else if (a = p[2], u = p[3], a === n && u === r && l === s && c === o) {
                        if (!i) {
                            var h = n - s,
                                d = r - o;
                            _.push(0 === h ? "v" + g.number(d) : 0 === d ? "h" + g.number(h) : "l" + g.pair(h, d))
                        }
                    } else _.push("c" + g.pair(l - s, c - o) + " " + g.pair(a - s, u - o) + " " + g.pair(n - s, r - o));
                    s = n, o = r, l = p[4], c = p[5]
                }
                var n, r, s, o, a, u, l, c, d = this._segments,
                    f = d.length,
                    g = new h(e),
                    p = new Array(6),
                    v = !0,
                    _ = [];
                if (!f) return "";
                for (var m = 0; m < f; m++) i(d[m]);
                return this._closed && f > 0 && (i(d[0], !0), _.push("z")), _.join("")
            },
            isEmpty: function() {
                return !this._segments.length
            },
            _transformContent: function(t) {
                for (var e = this._segments, i = new Array(6), n = 0, r = e.length; n < r; n++) e[n]._transformCoordinates(t, i, !0);
                return !0
            },
            _add: function(t, e) {
                for (var i = this._segments, n = this._curves, r = t.length, s = null == e, e = s ? i.length : e, o = 0; o < r; o++) {
                    var a = t[o];
                    a._path && (a = t[o] = a.clone()), a._path = this, a._index = e + o, a._selection && this._updateSelection(a, 0, a._selection)
                }
                if (s) i.push.apply(i, t);
                else {
                    i.splice.apply(i, [e, 0].concat(t));
                    for (var o = e + r, h = i.length; o < h; o++) i[o]._index = o
                }
                if (n) {
                    var u = this._countCurves(),
                        l = e > 0 && e + r - 1 === u ? e - 1 : e,
                        c = l,
                        d = Math.min(l + r, u);
                    t._curves && (n.splice.apply(n, [l, 0].concat(t._curves)), c += t._curves.length);
                    for (var o = c; o < d; o++) n.splice(o, 0, new A(this, null, null));
                    this._adjustCurves(l, d)
                }
                return this._changed(25), t
            },
            _adjustCurves: function(t, e) {
                for (var i, n = this._segments, r = this._curves, s = t; s < e; s++) i = r[s], i._path = this, i._segment1 = n[s], i._segment2 = n[s + 1] || n[0], i._changed();
                (i = r[this._closed && !t ? n.length - 1 : t - 1]) && (i._segment2 = n[t] || n[0], i._changed()), (i = r[e]) && (i._segment1 = n[e], i._changed())
            },
            _countCurves: function() {
                var t = this._segments.length;
                return !this._closed && t > 0 ? t - 1 : t
            },
            add: function(t) {
                return arguments.length > 1 && "number" != typeof t ? this._add(k.readList(arguments)) : this._add([k.read(arguments)])[0]
            },
            insert: function(t, e) {
                return arguments.length > 2 && "number" != typeof e ? this._add(k.readList(arguments, 1), t) : this._add([k.read(arguments, 1)], t)[0]
            },
            addSegment: function() {
                return this._add([k.read(arguments)])[0]
            },
            insertSegment: function(t) {
                return this._add([k.read(arguments, 1)], t)[0]
            },
            addSegments: function(t) {
                return this._add(k.readList(t))
            },
            insertSegments: function(t, e) {
                return this._add(k.readList(e), t)
            },
            removeSegment: function(t) {
                return this.removeSegments(t, t + 1)[0] || null
            },
            removeSegments: function(t, e, i) {
                t = t || 0, e = r.pick(e, this._segments.length);
                var n = this._segments,
                    s = this._curves,
                    o = n.length,
                    a = n.splice(t, e - t),
                    h = a.length;
                if (!h) return a;
                for (var u = 0; u < h; u++) {
                    var l = a[u];
                    l._selection && this._updateSelection(l, l._selection, 0), l._index = l._path = null
                }
                for (var u = t, c = n.length; u < c; u++) n[u]._index = u;
                if (s) {
                    for (var d = t > 0 && e === o + (this._closed ? 1 : 0) ? t - 1 : t, s = s.splice(d, h), u = s.length - 1; u >= 0; u--) s[u]._path = null;
                    i && (a._curves = s.slice(1)), this._adjustCurves(d, d)
                }
                return this._changed(25), a
            },
            clear: "#removeSegments",
            hasHandles: function() {
                for (var t = this._segments, e = 0, i = t.length; e < i; e++)
                    if (t[e].hasHandles()) return !0;
                return !1
            },
            clearHandles: function() {
                for (var t = this._segments, e = 0, i = t.length; e < i; e++) t[e].clearHandles()
            },
            getLength: function() {
                if (null == this._length) {
                    for (var t = this.getCurves(), e = 0, i = 0, n = t.length; i < n; i++) e += t[i].getLength();
                    this._length = e
                }
                return this._length
            },
            getArea: function() {
                var t = this._area;
                if (null == t) {
                    var e = this._segments,
                        i = this._closed;
                    t = 0;
                    for (var n = 0, r = e.length; n < r; n++) {
                        var s = n + 1 === r;
                        t += A.getArea(A.getValues(e[n], e[s ? 0 : n + 1], null, s && !i))
                    }
                    this._area = t
                }
                return t
            },
            isFullySelected: function() {
                var t = this._segments.length;
                return this.isSelected() && t > 0 && this._segmentSelection === 7 * t
            },
            setFullySelected: function(t) {
                t && this._selectSegments(!0), this.setSelected(t)
            },
            setSelection: function t(e) {
                1 & e || this._selectSegments(!1), t.base.call(this, e)
            },
            _selectSegments: function(t) {
                var e = this._segments,
                    i = e.length,
                    n = t ? 7 : 0;
                this._segmentSelection = n * i;
                for (var r = 0; r < i; r++) e[r]._selection = n
            },
            _updateSelection: function(t, e, i) {
                t._selection = i, (this._segmentSelection += i - e) > 0 && this.setSelected(!0)
            },
            divideAt: function(t) {
                var e, i = this.getLocationAt(t);
                return i && (e = i.getCurve().divideAt(i.getCurveOffset())) ? e._segment1 : null
            },
            splitAt: function(t) {
                var e = this.getLocationAt(t),
                    i = e && e.index,
                    n = e && e.time;
                n > 1 - 1e-8 && (i++, n = 0);
                var r = this.getCurves();
                if (i >= 0 && i < r.length) {
                    n >= 1e-8 && r[i++].divideAtTime(n);
                    var s, o = this.removeSegments(i, this._segments.length, !0);
                    return this._closed ? (this.setClosed(!1), s = this) : (s = new O(w.NO_INSERT), s.insertAbove(this), s.copyAttributes(this)), s._add(o, 0), this.addSegment(o[0]), s
                }
                return null
            },
            split: function(t, i) {
                var n, r = i === e ? t : (n = this.getCurves()[t]) && n.getLocationAtTime(i);
                return null != r ? this.splitAt(r) : null
            },
            join: function(t, e) {
                var i = e || 0;
                if (t && t !== this) {
                    var n = t._segments,
                        r = this.getLastSegment(),
                        s = t.getLastSegment();
                    if (!s) return this;
                    r && r._point.isClose(s._point, i) && t.reverse();
                    var o = t.getFirstSegment();
                    if (r && r._point.isClose(o._point, i)) r.setHandleOut(o._handleOut), this._add(n.slice(1));
                    else {
                        var a = this.getFirstSegment();
                        a && a._point.isClose(o._point, i) && t.reverse(), s = t.getLastSegment(), a && a._point.isClose(s._point, i) ? (a.setHandleIn(s._handleIn), this._add(n.slice(0, n.length - 1), 0)) : this._add(n.slice())
                    }
                    t._closed && this._add([n[0]]), t.remove()
                }
                var h = this.getFirstSegment(),
                    u = this.getLastSegment();
                return h !== u && h._point.isClose(u._point, i) && (h.setHandleIn(u._handleIn), u.remove(), this.setClosed(!0)), this
            },
            reduce: function(t) {
                for (var e = this.getCurves(), i = t && t.simplify, n = i ? 1e-7 : 0, r = e.length - 1; r >= 0; r--) {
                    var s = e[r];
                    !s.hasHandles() && (!s.hasLength(n) || i && s.isCollinear(s.getNext())) && s.remove()
                }
                return this
            },
            reverse: function() {
                this._segments.reverse();
                for (var t = 0, e = this._segments.length; t < e; t++) {
                    var i = this._segments[t],
                        n = i._handleIn;
                    i._handleIn = i._handleOut, i._handleOut = n, i._index = t
                }
                this._curves = null, this._changed(9)
            },
            flatten: function(t) {
                for (var e = new N(this, t || .25, 256, !0), i = e.parts, n = i.length, r = [], s = 0; s < n; s++) r.push(new k(i[s].curve.slice(0, 2)));
                !this._closed && n > 0 && r.push(new k(i[n - 1].curve.slice(6))), this.setSegments(r)
            },
            simplify: function(t) {
                var e = new F(this).fit(t || 2.5);
                return e && this.setSegments(e), !!e
            },
            smooth: function(t) {
                function i(t, e) {
                    var i = t && t.index;
                    if (null != i) {
                        var r = t.path;
                        if (r && r !== n) throw new Error(t._class + " " + i + " of " + r + " is not part of " + n);
                        e && t instanceof A && i++
                    } else i = "number" == typeof t ? t : e;
                    return Math.min(i < 0 && h ? i % a : i < 0 ? i + a : i, a - 1)
                }
                var n = this,
                    r = t || {},
                    s = r.type || "asymmetric",
                    o = this._segments,
                    a = o.length,
                    h = this._closed,
                    u = h && r.from === e && r.to === e,
                    l = i(r.from, 0),
                    c = i(r.to, a - 1);
                if (l > c)
                    if (h) l -= a;
                    else {
                        var d = l;
                        l = c, c = d
                    }
                if (/^(?:asymmetric|continuous)$/.test(s)) {
                    var f = "asymmetric" === s,
                        g = Math.min,
                        p = c - l + 1,
                        v = p - 1,
                        _ = u ? g(p, 4) : 1,
                        m = _,
                        y = _,
                        w = [];
                    if (h || (m = g(1, l), y = g(1, a - c - 1)), (v += m + y) <= 1) return;
                    for (var x = 0, b = l - m; x <= v; x++, b++) w[x] = o[(b < 0 ? b + a : b) % a]._point;
                    for (var S = w[0]._x + 2 * w[1]._x, C = w[0]._y + 2 * w[1]._y, T = 2, E = v - 1, z = [S], k = [C], I = [T], P = [], M = [], x = 1; x < v; x++) {
                        var O = x < E,
                            L = O ? 1 : f ? 1 : 2,
                            N = O ? 4 : f ? 2 : 7,
                            F = O ? 4 : f ? 3 : 8,
                            D = O ? 2 : f ? 0 : 1,
                            R = L / T;
                        T = I[x] = N - R, S = z[x] = F * w[x]._x + D * w[x + 1]._x - R * S, C = k[x] = F * w[x]._y + D * w[x + 1]._y - R * C
                    }
                    P[E] = z[E] / I[E], M[E] = k[E] / I[E];
                    for (var x = v - 2; x >= 0; x--) P[x] = (z[x] - P[x + 1]) / I[x], M[x] = (k[x] - M[x + 1]) / I[x];
                    P[v] = (3 * w[v]._x - P[E]) / 2, M[v] = (3 * w[v]._y - M[E]) / 2;
                    for (var x = m, B = v - y, b = l; x <= B; x++, b++) {
                        var j = o[b < 0 ? b + a : b],
                            q = j._point,
                            H = P[x] - q._x,
                            W = M[x] - q._y;
                        (u || x < B) && j.setHandleOut(H, W), (u || x > m) && j.setHandleIn(-H, -W)
                    }
                } else
                    for (var x = l; x <= c; x++) o[x < 0 ? x + a : x].smooth(r, !u && x === l, !u && x === c)
            },
            toShape: function(t) {
                function i(t, e) {
                    var i = l[t],
                        n = i.getNext(),
                        r = l[e],
                        s = r.getNext();
                    return i._handleOut.isZero() && n._handleIn.isZero() && r._handleOut.isZero() && s._handleIn.isZero() && n._point.subtract(i._point).isCollinear(s._point.subtract(r._point))
                }

                function n(t) {
                    var e = l[t],
                        i = e.getNext(),
                        n = e._handleOut,
                        r = i._handleIn;
                    if (n.isOrthogonal(r)) {
                        var s = e._point,
                            o = i._point,
                            a = new m(s, n, !0).intersect(new m(o, r, !0), !0);
                        return a && u.isZero(n.getLength() / a.subtract(s).getLength() - .5522847498307936) && u.isZero(r.getLength() / a.subtract(o).getLength() - .5522847498307936)
                    }
                    return !1
                }

                function r(t, e) {
                    return l[t]._point.getDistance(l[e]._point)
                }
                if (!this._closed) return null;
                var s, o, a, h, l = this._segments;
                if (!this.hasHandles() && 4 === l.length && i(0, 2) && i(1, 3) && function(t) {
                        var e = l[t],
                            i = e.getPrevious(),
                            n = e.getNext();
                        return i._handleOut.isZero() && e._handleIn.isZero() && e._handleOut.isZero() && n._handleIn.isZero() && e._point.subtract(i._point).isOrthogonal(n._point.subtract(e._point))
                    }(1) ? (s = S.Rectangle, o = new f(r(0, 3), r(0, 1)), h = l[1]._point.add(l[2]._point).divide(2)) : 8 === l.length && n(0) && n(2) && n(4) && n(6) && i(1, 5) && i(3, 7) ? (s = S.Rectangle, o = new f(r(1, 6), r(0, 3)), a = o.subtract(new f(r(0, 7), r(1, 2))).divide(2), h = l[3]._point.add(l[4]._point).divide(2)) : 4 === l.length && n(0) && n(1) && n(2) && n(3) && (u.isZero(r(0, 2) - r(1, 3)) ? (s = S.Circle, a = r(0, 2) / 2) : (s = S.Ellipse, a = new f(r(2, 0) / 2, r(3, 1) / 2)), h = l[1]._point), s) {
                    var c = this.getPosition(!0),
                        d = new s({
                            center: c,
                            size: o,
                            radius: a,
                            insert: !1
                        });
                    return d.copyAttributes(this, !0), d._matrix.prepend(this._matrix), d.rotate(h.subtract(c).getAngle() + 90), (t === e || t) && d.insertAbove(this), d
                }
                return null
            },
            toPath: "#clone",
            compare: function t(e) {
                if (!e || e instanceof L) return t.base.call(this, e);
                var i = this.getCurves(),
                    n = e.getCurves(),
                    r = i.length,
                    s = n.length;
                if (!r || !s) return r == s;
                for (var o, a, h = i[0].getValues(), u = [], l = 0, c = 0, d = 0; d < s; d++) {
                    var f = n[d].getValues();
                    u.push(f);
                    var g = A.getOverlaps(h, f);
                    if (g) {
                        o = !d && g[0][0] > 0 ? s - 1 : d, a = g[0][1];
                        break
                    }
                }
                for (var p, v = Math.abs, f = u[o]; h && f;) {
                    var g = A.getOverlaps(h, f);
                    if (g) {
                        if (v(g[0][0] - c) < 1e-8) {
                            c = g[1][0], 1 === c && (h = ++l < r ? i[l].getValues() : null, c = 0);
                            var _ = g[0][1];
                            if (v(_ - a) < 1e-8) {
                                if (p || (p = [o, _]), a = g[1][1], 1 === a && (++o >= s && (o = 0), f = u[o] || n[o].getValues(), a = 0), !h) return p[0] === o && p[1] === a;
                                continue
                            }
                        }
                    }
                    break
                }
                return !1
            },
            _hitTestSelf: function(t, e, i, n) {
                function r(e, i) {
                    return t.subtract(e).divide(i).length <= 1
                }

                function s(t, i, n) {
                    if (!e.selected || i.isSelected()) {
                        var s = t._point;
                        if (i !== s && (i = i.add(s)), r(i, x)) return new z(n, p, {
                            segment: t,
                            point: i
                        })
                    }
                }

                function o(t, i) {
                    return (i || e.segments) && s(t, t._point, "segment") || !i && e.handles && (s(t, t._handleIn, "handle-in") || s(t, t._handleOut, "handle-out"))
                }

                function a(t) {
                    d.add(t)
                }

                function h(e) {
                    var i = y || e._index > 0 && e._index < m - 1;
                    if ("round" === (i ? u : l)) return r(e._point, x);
                    if (d = new O({
                            internal: !0,
                            closed: !0
                        }), i ? e.isSmooth() || O._addBevelJoin(e, u, T, c, null, n, a, !0) : "square" === l && O._addSquareCap(e, l, T, null, n, a, !0), !d.isEmpty()) {
                        var s;
                        return d.contains(t) || (s = d.getNearestLocation(t)) && r(s.getPoint(), w)
                    }
                }
                var u, l, c, d, f, g, p = this,
                    v = this.getStyle(),
                    _ = this._segments,
                    m = _.length,
                    y = this._closed,
                    w = e._tolerancePadding,
                    x = w,
                    b = e.stroke && v.hasStroke(),
                    S = e.fill && v.hasFill(),
                    C = e.curves,
                    T = b ? v.getStrokeWidth() / 2 : S && e.tolerance > 0 || C ? 0 : null;
                if (null !== T && (T > 0 ? (u = v.getStrokeJoin(), l = v.getStrokeCap(), c = v.getMiterLimit(), x = x.add(O._getStrokePadding(T, n))) : u = l = "round"), !e.ends || e.segments || y) {
                    if (e.segments || e.handles)
                        for (var E = 0; E < m; E++)
                            if (g = o(_[E])) return g
                } else if (g = o(_[0], !0) || o(_[m - 1], !0)) return g;
                if (null !== T) {
                    if (f = this.getNearestLocation(t)) {
                        var k = f.getTime();
                        0 === k || 1 === k && m > 1 ? h(f.getSegment()) || (f = null) : r(f.getPoint(), x) || (f = null)
                    }
                    if (!f && "miter" === u && m > 1)
                        for (var E = 0; E < m; E++) {
                            var I = _[E];
                            if (t.getDistance(I._point) <= c * T && h(I)) {
                                f = I.getLocation();
                                break
                            }
                        }
                }
                return !f && S && this._contains(t) || f && !b && !C ? new z("fill", this) : f ? new z(b ? "stroke" : "curve", this, {
                    location: f,
                    point: f.getPoint()
                }) : null
            }
        }, r.each(A._evaluateMethods, function(t) {
            this[t + "At"] = function(e) {
                var i = this.getLocationAt(e);
                return i && i[t]()
            }
        }, {
            beans: !1,
            getLocationOf: function() {
                for (var t = c.read(arguments), e = this.getCurves(), i = 0, n = e.length; i < n; i++) {
                    var r = e[i].getLocationOf(t);
                    if (r) return r
                }
                return null
            },
            getOffsetOf: function() {
                var t = this.getLocationOf.apply(this, arguments);
                return t ? t.getOffset() : null
            },
            getLocationAt: function(t) {
                if ("number" == typeof t) {
                    for (var e = this.getCurves(), i = 0, n = 0, r = e.length; n < r; n++) {
                        var s = i,
                            o = e[n];
                        if ((i += o.getLength()) > t) return o.getLocationAt(t - s)
                    }
                    if (e.length > 0 && t <= this.getLength()) return new P(e[e.length - 1], 1)
                } else if (t && t.getPath && t.getPath() === this) return t;
                return null
            }
        }), new function() {
            function t(t, e, i, n) {
                function r(e) {
                    var i = h[e],
                        n = h[e + 1];
                    s == i && o == n || (t.beginPath(), t.moveTo(s, o), t.lineTo(i, n), t.stroke(), t.beginPath(), t.arc(i, n, a, 0, 2 * Math.PI, !0), t.fill())
                }
                for (var s, o, a = n / 2, h = new Array(6), u = 0, l = e.length; u < l; u++) {
                    var c = e[u],
                        d = c._selection;
                    if (c._transformCoordinates(i, h), s = h[0], o = h[1], 2 & d && r(2), 4 & d && r(4), t.fillRect(s - a, o - a, n, n), !(1 & d)) {
                        var f = t.fillStyle;
                        t.fillStyle = "#ffffff", t.fillRect(s - a + 1, o - a + 1, n - 2, n - 2), t.fillStyle = f
                    }
                }
            }

            function e(t, e, i) {
                function n(e) {
                    if (i) e._transformCoordinates(i, g), r = g[0], s = g[1];
                    else {
                        var n = e._point;
                        r = n._x, s = n._y
                    }
                    if (p) t.moveTo(r, s), p = !1;
                    else {
                        if (i) h = g[2], u = g[3];
                        else {
                            var d = e._handleIn;
                            h = r + d._x, u = s + d._y
                        }
                        h === r && u === s && l === o && c === a ? t.lineTo(r, s) : t.bezierCurveTo(l, c, h, u, r, s)
                    }
                    if (o = r, a = s, i) l = g[4], c = g[5];
                    else {
                        var d = e._handleOut;
                        l = o + d._x, c = a + d._y
                    }
                }
                for (var r, s, o, a, h, u, l, c, d = e._segments, f = d.length, g = new Array(6), p = !0, v = 0; v < f; v++) n(d[v]);
                e._closed && f > 0 && n(d[0])
            }
            return {
                _draw: function(t, i, n, r) {
                    function s(t) {
                        return c[(t % d + d) % d]
                    }
                    var o = i.dontStart,
                        a = i.dontFinish || i.clip,
                        h = this.getStyle(),
                        u = h.hasFill(),
                        l = h.hasStroke(),
                        c = h.getDashArray(),
                        d = !paper.support.nativeDash && l && c && c.length;
                    if (o || t.beginPath(), (u || l && !d || a) && (e(t, this, r), this._closed && t.closePath()), !a && (u || l) && (this._setStyles(t, i, n), u && (t.fill(h.getFillRule()), t.shadowColor = "rgba(0,0,0,0)"), l)) {
                        if (d) {
                            o || t.beginPath();
                            var f, g = new N(this, .25, 32, !1, r),
                                p = g.length,
                                v = -h.getDashOffset(),
                                _ = 0;
                            for (v %= p; v > 0;) v -= s(_--) + s(_--);
                            for (; v < p;) f = v + s(_++), (v > 0 || f > 0) && g.drawPart(t, Math.max(v, 0), Math.max(f, 0)), v = f + s(_++)
                        }
                        t.stroke()
                    }
                },
                _drawSelected: function(i, n) {
                    i.beginPath(), e(i, this, n), i.stroke(), t(i, this._segments, n, paper.settings.handleSize)
                }
            }
        }, new function() {
            function t(t) {
                var e = t._segments;
                if (!e.length) throw new Error("Use a moveTo() command first");
                return e[e.length - 1]
            }
            return {
                moveTo: function() {
                    var t = this._segments;
                    1 === t.length && this.removeSegment(0), t.length || this._add([new k(c.read(arguments))])
                },
                moveBy: function() {
                    throw new Error("moveBy() is unsupported on Path items.")
                },
                lineTo: function() {
                    this._add([new k(c.read(arguments))])
                },
                cubicCurveTo: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = c.read(arguments),
                        r = t(this);
                    r.setHandleOut(e.subtract(r._point)), this._add([new k(n, i.subtract(n))])
                },
                quadraticCurveTo: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = t(this)._point;
                    this.cubicCurveTo(e.add(n.subtract(e).multiply(1 / 3)), e.add(i.subtract(e).multiply(1 / 3)), i)
                },
                curveTo: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = r.pick(r.read(arguments), .5),
                        s = 1 - n,
                        o = t(this)._point,
                        a = e.subtract(o.multiply(s * s)).subtract(i.multiply(n * n)).divide(2 * n * s);
                    if (a.isNaN()) throw new Error("Cannot put a curve through points with parameter = " + n);
                    this.quadraticCurveTo(a, i)
                },
                arcTo: function() {
                    var e, i, n, s, o, a = Math.abs,
                        h = Math.sqrt,
                        l = t(this),
                        d = l._point,
                        g = c.read(arguments),
                        p = r.peek(arguments),
                        v = r.pick(p, !0);
                    if ("boolean" == typeof v) var y = d.add(g).divide(2),
                        e = y.add(y.subtract(d).rotate(v ? -90 : 90));
                    else if (r.remain(arguments) <= 2) e = g, g = c.read(arguments);
                    else {
                        var w = f.read(arguments),
                            x = u.isZero;
                        if (x(w.width) || x(w.height)) return this.lineTo(g);
                        var b = r.read(arguments),
                            v = !!r.read(arguments),
                            S = !!r.read(arguments),
                            y = d.add(g).divide(2),
                            C = d.subtract(y).rotate(-b),
                            T = C.x,
                            E = C.y,
                            z = a(w.width),
                            I = a(w.height),
                            A = z * z,
                            P = I * I,
                            M = T * T,
                            O = E * E,
                            L = h(M / A + O / P);
                        if (L > 1 && (z *= L, I *= L, A = z * z, P = I * I), L = (A * P - A * O - P * M) / (A * O + P * M), a(L) < 1e-12 && (L = 0), L < 0) throw new Error("Cannot create an arc with the given arguments");
                        i = new c(z * E / I, -I * T / z).multiply((S === v ? -1 : 1) * h(L)).rotate(b).add(y), o = (new _).translate(i).rotate(b).scale(z, I), s = o._inverseTransform(d), n = s.getDirectedAngle(o._inverseTransform(g)), !v && n > 0 ? n -= 360 : v && n < 0 && (n += 360)
                    }
                    if (e) {
                        var N = new m(d.add(e).divide(2), e.subtract(d).rotate(90), !0),
                            F = new m(e.add(g).divide(2), g.subtract(e).rotate(90), !0),
                            D = new m(d, g),
                            R = D.getSide(e);
                        if (!(i = N.intersect(F, !0))) {
                            if (!R) return this.lineTo(g);
                            throw new Error("Cannot create an arc with the given arguments")
                        }
                        s = d.subtract(i), n = s.getDirectedAngle(g.subtract(i));
                        var B = D.getSide(i);
                        0 === B ? n = R * a(n) : R === B && (n += n < 0 ? 360 : -360)
                    }
                    for (var j = a(n), q = j >= 360 ? 4 : Math.ceil((j - 1e-7) / 90), H = n / q, W = H * Math.PI / 360, V = 4 / 3 * Math.sin(W) / (1 + Math.cos(W)), U = [], Y = 0; Y <= q; Y++) {
                        var C = g,
                            X = null;
                        if (Y < q && (X = s.rotate(90).multiply(V), o ? (C = o._transformPoint(s), X = o._transformPoint(s.add(X)).subtract(C)) : C = i.add(s)), Y) {
                            var Z = s.rotate(-90).multiply(V);
                            o && (Z = o._transformPoint(s.add(Z)).subtract(C)), U.push(new k(C, Z, X))
                        } else l.setHandleOut(X);
                        s = s.rotate(H)
                    }
                    this._add(U)
                },
                lineBy: function() {
                    var e = c.read(arguments),
                        i = t(this)._point;
                    this.lineTo(i.add(e))
                },
                curveBy: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = r.read(arguments),
                        s = t(this)._point;
                    this.curveTo(s.add(e), s.add(i), n)
                },
                cubicCurveBy: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = c.read(arguments),
                        r = t(this)._point;
                    this.cubicCurveTo(r.add(e), r.add(i), r.add(n))
                },
                quadraticCurveBy: function() {
                    var e = c.read(arguments),
                        i = c.read(arguments),
                        n = t(this)._point;
                    this.quadraticCurveTo(n.add(e), n.add(i))
                },
                arcBy: function() {
                    var e = t(this)._point,
                        i = e.add(c.read(arguments)),
                        n = r.pick(r.peek(arguments), !0);
                    "boolean" == typeof n ? this.arcTo(i, n) : this.arcTo(i, e.add(c.read(arguments)))
                },
                closePath: function(t) {
                    this.setClosed(!0), this.join(this, t)
                }
            }
        }, {
            _getBounds: function(t, e) {
                var i = e.handle ? "getHandleBounds" : e.stroke ? "getStrokeBounds" : "getBounds";
                return O[i](this._segments, this._closed, this, t, e)
            },
            statics: {
                getBounds: function(t, e, i, n, r, s) {
                    function o(t) {
                        t._transformCoordinates(n, h);
                        for (var e = 0; e < 2; e++) A._addBounds(u[e], u[e + 4], h[e + 2], h[e], e, s ? s[e] : 0, l, c, d);
                        var i = u;
                        u = h, h = i
                    }
                    var a = t[0];
                    if (!a) return new p;
                    for (var h = new Array(6), u = a._transformCoordinates(n, new Array(6)), l = u.slice(0, 2), c = l.slice(), d = new Array(2), f = 1, g = t.length; f < g; f++) o(t[f]);
                    return e && o(a), new p(l[0], l[1], c[0] - l[0], c[1] - l[1])
                },
                getStrokeBounds: function(t, e, i, n, r) {
                    function s(t) {
                        v = v.include(t)
                    }

                    function o(t) {
                        v = v.unite(x.setCenter(t._point.transform(n)))
                    }

                    function a(t, e) {
                        "round" === e || t.isSmooth() ? o(t) : O._addBevelJoin(t, e, _, w, n, d, s)
                    }

                    function h(t, e) {
                        "round" === e ? o(t) : O._addSquareCap(t, e, _, n, d, s)
                    }
                    var u = i.getStyle(),
                        l = u.hasStroke(),
                        c = u.getStrokeWidth(),
                        d = l && i._getStrokeMatrix(n, r),
                        g = l && O._getStrokePadding(c, d),
                        v = O.getBounds(t, e, i, n, r, g);
                    if (!l) return v;
                    for (var _ = c / 2, m = u.getStrokeJoin(), y = u.getStrokeCap(), w = u.getMiterLimit(), x = new p(new f(g)), b = t.length - (e ? 0 : 1), S = 1; S < b; S++) a(t[S], m);
                    return e ? a(t[0], m) : b > 0 && (h(t[0], y), h(t[t.length - 1], y)), v
                },
                _getStrokePadding: function(t, e) {
                    if (!e) return [t, t];
                    var i = new c(t, 0).transform(e),
                        n = new c(0, t).transform(e),
                        r = i.getAngleInRadians(),
                        s = i.getLength(),
                        o = n.getLength(),
                        a = Math.sin(r),
                        h = Math.cos(r),
                        u = Math.tan(r),
                        l = Math.atan2(o * u, s),
                        d = Math.atan2(o, u * s);
                    return [Math.abs(s * Math.cos(l) * h + o * Math.sin(l) * a), Math.abs(o * Math.sin(d) * h + s * Math.cos(d) * a)]
                },
                _addBevelJoin: function(t, e, i, n, r, s, o, a) {
                    var h = t.getCurve(),
                        u = h.getPrevious(),
                        l = h.getPoint1().transform(r),
                        d = u.getNormalAtTime(1).multiply(i).transform(s),
                        f = h.getNormalAtTime(0).multiply(i).transform(s);
                    if (d.getDirectedAngle(f) < 0 && (d = d.negate(), f = f.negate()), a && o(l), o(l.add(d)), "miter" === e) {
                        var g = new m(l.add(d), new c(-d.y, d.x), !0).intersect(new m(l.add(f), new c(-f.y, f.x), !0), !0);
                        g && l.getDistance(g) <= n * i && o(g)
                    }
                    o(l.add(f))
                },
                _addSquareCap: function(t, e, i, n, r, s, o) {
                    var a = t._point.transform(n),
                        h = t.getLocation(),
                        u = h.getNormal().multiply(0 === h.getTime() ? i : -i).transform(r);
                    "square" === e && (o && (s(a.subtract(u)), s(a.add(u))), a = a.add(u.rotate(-90))), s(a.add(u)), s(a.subtract(u))
                },
                getHandleBounds: function(t, e, i, n, r) {
                    var s, o, a = i.getStyle(),
                        h = r.stroke && a.hasStroke();
                    if (h) {
                        var u = i._getStrokeMatrix(n, r),
                            l = a.getStrokeWidth() / 2,
                            c = l;
                        "miter" === a.getStrokeJoin() && (c = l * a.getMiterLimit()), "square" === a.getStrokeCap() && (c = Math.max(c, l * Math.SQRT2)), s = O._getStrokePadding(l, u), o = O._getStrokePadding(c, u)
                    }
                    for (var d = new Array(6), f = 1 / 0, g = -f, v = f, _ = g, m = 0, y = t.length; m < y; m++) {
                        t[m]._transformCoordinates(n, d);
                        for (var w = 0; w < 6; w += 2) {
                            var x = w ? s : o,
                                b = x ? x[0] : 0,
                                S = x ? x[1] : 0,
                                C = d[w],
                                T = d[w + 1],
                                E = C - b,
                                z = C + b,
                                k = T - S,
                                I = T + S;
                            E < f && (f = E), z > g && (g = z), k < v && (v = k), I > _ && (_ = I)
                        }
                    }
                    return new p(f, v, g - f, _ - v)
                }
            }
        });
    O.inject({
        statics: new function() {
            function t(t, e, i) {
                var n = r.getNamed(i),
                    s = new O(n && 0 == n.insert && w.NO_INSERT);
                return s._add(t), s._closed = e, s.set(n, {
                    insert: !0
                })
            }

            function e(e, i, r) {
                for (var s = new Array(4), o = 0; o < 4; o++) {
                    var a = n[o];
                    s[o] = new k(a._point.multiply(i).add(e), a._handleIn.multiply(i), a._handleOut.multiply(i))
                }
                return t(s, !0, r)
            }
            var i = .5522847498307936,
                n = [new k([-1, 0], [0, i], [0, -i]), new k([0, -1], [-i, 0], [i, 0]), new k([1, 0], [0, -i], [0, i]), new k([0, 1], [i, 0], [-i, 0])];
            return {
                Line: function() {
                    return t([new k(c.readNamed(arguments, "from")), new k(c.readNamed(arguments, "to"))], !1, arguments)
                },
                Circle: function() {
                    var t = c.readNamed(arguments, "center"),
                        i = r.readNamed(arguments, "radius");
                    return e(t, new f(i), arguments)
                },
                Rectangle: function() {
                    var e, n = p.readNamed(arguments, "rectangle"),
                        r = f.readNamed(arguments, "radius", 0, {
                            readNull: !0
                        }),
                        s = n.getBottomLeft(!0),
                        o = n.getTopLeft(!0),
                        a = n.getTopRight(!0),
                        h = n.getBottomRight(!0);
                    if (!r || r.isZero()) e = [new k(s), new k(o), new k(a), new k(h)];
                    else {
                        r = f.min(r, n.getSize(!0).divide(2));
                        var u = r.width,
                            l = r.height,
                            c = u * i,
                            d = l * i;
                        e = [new k(s.add(u, 0), null, [-c, 0]), new k(s.subtract(0, l), [0, d]), new k(o.add(0, l), null, [0, -d]), new k(o.add(u, 0), [-c, 0], null), new k(a.subtract(u, 0), null, [c, 0]), new k(a.add(0, l), [0, -d], null), new k(h.subtract(0, l), null, [0, d]), new k(h.subtract(u, 0), [c, 0])]
                    }
                    return t(e, !0, arguments)
                },
                RoundRectangle: "#Rectangle",
                Ellipse: function() {
                    var t = S._readEllipse(arguments);
                    return e(t.center, t.radius, arguments)
                },
                Oval: "#Ellipse",
                Arc: function() {
                    var t = c.readNamed(arguments, "from"),
                        e = c.readNamed(arguments, "through"),
                        i = c.readNamed(arguments, "to"),
                        n = r.getNamed(arguments),
                        s = new O(n && 0 == n.insert && w.NO_INSERT);
                    return s.moveTo(t), s.arcTo(e, i), s.set(n)
                },
                RegularPolygon: function() {
                    for (var e = c.readNamed(arguments, "center"), i = r.readNamed(arguments, "sides"), n = r.readNamed(arguments, "radius"), s = 360 / i, o = i % 3 == 0, a = new c(0, o ? -n : n), h = o ? -1 : .5, u = new Array(i), l = 0; l < i; l++) u[l] = new k(e.add(a.rotate((l + h) * s)));
                    return t(u, !0, arguments)
                },
                Star: function() {
                    for (var e = c.readNamed(arguments, "center"), i = 2 * r.readNamed(arguments, "points"), n = r.readNamed(arguments, "radius1"), s = r.readNamed(arguments, "radius2"), o = 360 / i, a = new c(0, -1), h = new Array(i), u = 0; u < i; u++) h[u] = new k(e.add(a.rotate(o * u).multiply(u % 2 ? s : n)));
                    return t(h, !0, arguments)
                }
            }
        }
    });
    var L = M.extend({
        _class: "CompoundPath",
        _serializeFields: {
            children: []
        },
        beans: !0,
        initialize: function(t) {
            this._children = [], this._namedChildren = {}, this._initialize(t) || ("string" == typeof t ? this.setPathData(t) : this.addChildren(Array.isArray(t) ? t : arguments))
        },
        insertChildren: function t(e, i) {
            var n = i,
                s = n[0];
            s && "number" == typeof s[0] && (n = [n]);
            for (var o = i.length - 1; o >= 0; o--) {
                var a = n[o];
                n !== i || a instanceof O || (n = r.slice(n)), Array.isArray(a) ? n[o] = new O({
                    segments: a,
                    insert: !1
                }) : a instanceof L && (n.splice.apply(n, [o, 1].concat(a.removeChildren())), a.remove())
            }
            return t.base.call(this, e, n)
        },
        reduce: function t(e) {
            for (var i = this._children, n = i.length - 1; n >= 0; n--) {
                var r = i[n].reduce(e);
                r.isEmpty() && r.remove()
            }
            if (!i.length) {
                var r = new O(w.NO_INSERT);
                return r.copyAttributes(this), r.insertAbove(this), this.remove(), r
            }
            return t.base.call(this)
        },
        isClosed: function() {
            for (var t = this._children, e = 0, i = t.length; e < i; e++)
                if (!t[e]._closed) return !1;
            return !0
        },
        setClosed: function(t) {
            for (var e = this._children, i = 0, n = e.length; i < n; i++) e[i].setClosed(t)
        },
        getFirstSegment: function() {
            var t = this.getFirstChild();
            return t && t.getFirstSegment()
        },
        getLastSegment: function() {
            var t = this.getLastChild();
            return t && t.getLastSegment()
        },
        getCurves: function() {
            for (var t = this._children, e = [], i = 0, n = t.length; i < n; i++) e.push.apply(e, t[i].getCurves());
            return e
        },
        getFirstCurve: function() {
            var t = this.getFirstChild();
            return t && t.getFirstCurve()
        },
        getLastCurve: function() {
            var t = this.getLastChild();
            return t && t.getLastCurve()
        },
        getArea: function() {
            for (var t = this._children, e = 0, i = 0, n = t.length; i < n; i++) e += t[i].getArea();
            return e
        },
        getLength: function() {
            for (var t = this._children, e = 0, i = 0, n = t.length; i < n; i++) e += t[i].getLength();
            return e
        },
        getPathData: function(t, e) {
            for (var i = this._children, n = [], r = 0, s = i.length; r < s; r++) {
                var o = i[r],
                    a = o._matrix;
                n.push(o.getPathData(t && !a.isIdentity() ? t.appended(a) : t, e))
            }
            return n.join("")
        },
        _hitTestChildren: function t(e, i, n) {
            return t.base.call(this, e, i.class === O || "path" === i.type ? i : r.set({}, i, {
                fill: !1
            }), n)
        },
        _draw: function(t, e, i, n) {
            var r = this._children;
            if (r.length) {
                e = e.extend({
                    dontStart: !0,
                    dontFinish: !0
                }), t.beginPath();
                for (var s = 0, o = r.length; s < o; s++) r[s].draw(t, e, n);
                if (!e.clip) {
                    this._setStyles(t, e, i);
                    var a = this._style;
                    a.hasFill() && (t.fill(a.getFillRule()), t.shadowColor = "rgba(0,0,0,0)"), a.hasStroke() && t.stroke()
                }
            }
        },
        _drawSelected: function(t, e, i) {
            for (var n = this._children, r = 0, s = n.length; r < s; r++) {
                var o = n[r],
                    a = o._matrix;
                i[o._id] || o._drawSelected(t, a.isIdentity() ? e : e.appended(a))
            }
        }
    }, new function() {
        function t(t, e) {
            var i = t._children;
            if (e && !i.length) throw new Error("Use a moveTo() command first");
            return i[i.length - 1]
        }
        return r.each(["lineTo", "cubicCurveTo", "quadraticCurveTo", "curveTo", "arcTo", "lineBy", "cubicCurveBy", "quadraticCurveBy", "curveBy", "arcBy"], function(e) {
            this[e] = function() {
                var i = t(this, !0);
                i[e].apply(i, arguments)
            }
        }, {
            moveTo: function() {
                var e = t(this),
                    i = e && e.isEmpty() ? e : new O(w.NO_INSERT);
                i !== e && this.addChild(i), i.moveTo.apply(i, arguments)
            },
            moveBy: function() {
                var e = t(this, !0),
                    i = e && e.getLastSegment(),
                    n = c.read(arguments);
                this.moveTo(i ? n.add(i._point) : n)
            },
            closePath: function(e) {
                t(this, !0).closePath(e)
            }
        })
    }, r.each(["reverse", "flatten", "simplify", "smooth"], function(t) {
        this[t] = function(e) {
            for (var i, n = this._children, r = 0, s = n.length; r < s; r++) i = n[r][t](e) || i;
            return i
        }
    }, {}));
    M.inject(new function() {
        function t(t, e) {
            var i = t.clone(!1).reduce({
                simplify: !0
            }).transform(null, !0, !0);
            return e ? i.resolveCrossings().reorient("nonzero" === i.getFillRule(), !0) : i
        }

        function i(t, e, i, n, r) {
            var s = new L(w.NO_INSERT);
            return s.addChildren(t, !0), s = s.reduce({
                simplify: e
            }), r && 0 == r.insert || s.insertAbove(n && i.isSibling(n) && i.getIndex() < n.getIndex() ? n : i), s.copyAttributes(i, !0), s
        }

        function n(e, n, r, o) {
            function a(t) {
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    w.push.apply(w, n._segments), x.push.apply(x, n.getCurves()), n._overlapsOnly = !0
                }
            }
            if (o && (0 == o.trace || o.stroke) && /^(subtract|intersect)$/.test(r)) return s(e, n, r);
            var u = t(e, !0),
                c = n && e !== n && t(n, !0),
                g = _[r];
            g[r] = !0, c && (g.subtract || g.exclude) ^ c.isClockwise() ^ u.isClockwise() && c.reverse();
            var p, v = l(P.expand(u.getCrossings(c))),
                m = u._children || [u],
                y = c && (c._children || [c]),
                w = [],
                x = [];
            if (v.length) {
                a(m), y && a(y);
                for (var b = 0, S = v.length; b < S; b++) d(v[b]._segment, u, c, x, g);
                for (var b = 0, S = w.length; b < S; b++) {
                    var C = w[b],
                        T = C._intersection;
                    C._winding || d(C, u, c, x, g), T && T._overlap || (C._path._overlapsOnly = !1)
                }
                p = f(w, g)
            } else p = h(y ? m.concat(y) : m.slice(), function(t) {
                return !!g[t]
            });
            return i(p, !0, e, n, o)
        }

        function s(e, n, r) {
            function s(t) {
                if (!c[t._id] && (l || a.contains(t.getPointAt(t.getLength() / 2)) ^ u)) return d.unshift(t), c[t._id] = !0
            }
            for (var o = t(e), a = t(n), h = o.getCrossings(a), u = "subtract" === r, l = "divide" === r, c = {}, d = [], f = h.length - 1; f >= 0; f--) {
                var g = h[f].split();
                g && (s(g) && g.getFirstSegment().setHandleIn(0, 0), o.getLastSegment().setHandleOut(0, 0))
            }
            return s(o), i(d, !1, e, n)
        }

        function o(t, e) {
            for (var i = t; i;) {
                if (i === e) return;
                i = i._previous
            }
            for (; t._next && t._next !== e;) t = t._next;
            if (!t._next) {
                for (; e._previous;) e = e._previous;
                t._next = e, e._previous = t
            }
        }

        function a(t) {
            for (var e = t.length - 1; e >= 0; e--) t[e].clearHandles()
        }

        function h(t, e, i) {
            var n = t && t.length;
            if (n) {
                var s = r.each(t, function(t, e) {
                        this[t._id] = {
                            container: null,
                            winding: t.isClockwise() ? 1 : -1,
                            index: e
                        }
                    }, {}),
                    o = t.slice().sort(function(t, e) {
                        return v(e.getArea()) - v(t.getArea())
                    }),
                    a = o[0];
                null == i && (i = a.isClockwise());
                for (var h = 0; h < n; h++) {
                    for (var u = o[h], l = s[u._id], c = u.getInteriorPoint(), d = 0, f = h - 1; f >= 0; f--) {
                        var g = o[f];
                        if (g.contains(c)) {
                            var p = s[g._id];
                            d = p.winding, l.winding += d, l.container = p.exclude ? p.container : g;
                            break
                        }
                    }
                    if (e(l.winding) === e(d)) l.exclude = !0, t[l.index] = null;
                    else {
                        var _ = l.container;
                        u.setClockwise(_ ? !_.isClockwise() : i)
                    }
                }
            }
            return t
        }

        function l(t, e, i) {
            function n(t) {
                return t._path._id + "." + t._segment1._index
            }
            for (var r, s, h, u = e && [], l = !1, c = i || [], d = i && {}, f = (i && i.length) - 1; f >= 0; f--) {
                var g = i[f];
                g._path && (d[n(g)] = !0)
            }
            for (var f = t.length - 1; f >= 0; f--) {
                var p, v = t[f],
                    _ = v._time,
                    m = _,
                    y = e && !e(v),
                    g = v._curve;
                if (g && (g !== s ? (l = !g.hasHandles() || d && d[n(g)], r = [], h = null, s = g) : h >= 1e-8 && (_ /= h)), y) r && r.push(v);
                else {
                    if (e && u.unshift(v), h = m, _ < 1e-8) p = g._segment1;
                    else if (_ > 1 - 1e-8) p = g._segment2;
                    else {
                        var w = g.divideAtTime(_, !0);
                        l && c.push(g, w), p = w._segment1;
                        for (var x = r.length - 1; x >= 0; x--) {
                            var b = r[x];
                            b._time = (b._time - _) / (1 - _)
                        }
                    }
                    v._setSegment(p);
                    var S = p._intersection,
                        C = v._intersection;
                    if (S) {
                        o(S, C);
                        for (var T = S; T;) o(T._intersection, S), T = T._next
                    } else p._intersection = C
                }
            }
            return i || a(c), u || t
        }

        function c(t, e, i, n, r) {
            function s(s) {
                var o = s[l + 0],
                    h = s[l + 6];
                if (!(_ < g(o, h) || _ > p(o, h))) {
                    var d = s[u + 0],
                        v = s[u + 2],
                        x = s[u + 4],
                        b = s[u + 6];
                    if (o === h) return void((d < w && b > y || b < w && d > y) && (T = !0));
                    var E = _ === o ? 0 : _ === h ? 1 : y > p(d, v, x, b) || w < g(d, v, x, b) ? 1 : A.solveCubic(s, l, _, k, 0, 1) > 0 ? k[0] : 1,
                        I = 0 === E ? d : 1 === E ? b : A.getPoint(s, E)[i ? "y" : "x"],
                        P = o > h ? 1 : -1,
                        M = a[l] > a[l + 6] ? 1 : -1,
                        O = a[u + 6];
                    return _ !== o ? (I < y ? S += P : I > w ? C += P : T = !0, I > f - m && I < f + m && (z /= 2)) : (P !== M ? d < y ? S += P : d > w && (C += P) : d != O && (O < w && I > w ? (C += P, T = !0) : O > y && I < y && (S += P, T = !0)), z = 0), a = s, !r && I > y && I < w && 0 === A.getTangent(s, E)[i ? "x" : "y"] && c(t, e, !i, n, !0)
                }
            }

            function o(t) {
                var e = t[l + 0],
                    n = t[l + 2],
                    r = t[l + 4],
                    o = t[l + 6];
                if (_ <= p(e, n, r, o) && _ >= g(e, n, r, o))
                    for (var a, h = t[u + 0], c = t[u + 2], d = t[u + 4], f = t[u + 6], v = y > p(h, c, d, f) || w < g(h, c, d, f) ? [t] : A.getMonoCurves(t, i), m = 0, x = v.length; m < x; m++)
                        if (a = s(v[m])) return a
            }
            for (var a, h, u = i ? 1 : 0, l = 1 ^ u, d = [t.x, t.y], f = d[u], _ = d[l], m = 1e-6, y = f - 1e-9, w = f + 1e-9, x = 0, b = 0, S = 0, C = 0, T = !1, E = !1, z = 1, k = [], I = 0, P = e.length; I < P; I++) {
                var M, O = e[I],
                    L = O._path,
                    N = O.getValues();
                if (!(I && e[I - 1]._path === L || (a = null, L._closed || (h = A.getValues(L.getLastCurve().getSegment2(), O.getSegment1(), null, !n), h[l] !== h[l + 6] && (a = h)), a))) {
                    a = N;
                    for (var F = L.getLastCurve(); F && F !== O;) {
                        var D = F.getValues();
                        if (D[l] !== D[l + 6]) {
                            a = D;
                            break
                        }
                        F = F.getPrevious()
                    }
                }
                if (M = o(N)) return M;
                if (I + 1 === P || e[I + 1]._path !== L) {
                    if (h && (M = o(h))) return M;
                    !T || S || C || (S = C = L.isClockwise(n) ^ i ? 1 : -1), x += S, b += C, S = C = 0, T && (E = !0, T = !1), h = null
                }
            }
            return x = v(x), b = v(b), {
                winding: p(x, b),
                windingL: x,
                windingR: b,
                quality: z,
                onPath: E
            }
        }

        function d(t, e, i, n, r) {
            var s, o = [],
                a = t,
                h = 0;
            do {
                var l = t.getCurve(),
                    d = l.getLength();
                o.push({
                    segment: t,
                    curve: l,
                    length: d
                }), h += d, t = t.getNext()
            } while (t && !t._intersection && t !== a);
            for (var f = [.5, .25, .75], s = {
                    winding: 0,
                    quality: -1
                }, g = 0; g < f.length && s.quality < .5; g++)
                for (var d = h * f[g], p = 0, _ = o.length; p < _; p++) {
                    var m = o[p],
                        y = m.length;
                    if (d <= y) {
                        var l = m.curve,
                            w = l._path,
                            x = w._parent,
                            b = x instanceof L ? x : w,
                            S = u.clamp(l.getTimeAt(d), 1e-8, 1 - 1e-8),
                            C = l.getPointAtTime(S),
                            T = v(l.getTangentAtTime(S).y) < Math.SQRT1_2,
                            E = r.subtract && i && (b === e && i._getWinding(C, T, !0).winding || b === i && !e._getWinding(C, T, !0).winding) ? {
                                winding: 0,
                                quality: 1
                            } : c(C, n, T, !0);
                        E.quality > s.quality && (s = E);
                        break
                    }
                    d -= y
                }
            for (var p = o.length - 1; p >= 0; p--) o[p].segment._winding = s
        }

        function f(t, e) {
            function i(t) {
                var i;
                return !(!t || t._visited || e && (!e[(i = t._winding || {}).winding] || e.unite && 2 === i.winding && i.windingL && i.windingR))
            }

            function n(t) {
                if (t)
                    for (var e = 0, i = s.length; e < i; e++)
                        if (t === s[e]) return !0;
                return !1
            }

            function r(t) {
                for (var e = t._segments, i = 0, n = e.length; i < n; i++) e[i]._visited = !0
            }
            var s, o = [];
            t.sort(function(t, e) {
                var i = t._intersection,
                    n = e._intersection,
                    r = !(!i || !i._overlap),
                    s = !(!n || !n._overlap),
                    o = t._path,
                    a = e._path;
                return r ^ s ? r ? 1 : -1 : !i ^ !n ? i ? 1 : -1 : o !== a ? o._id - a._id : t._index - e._index
            });
            for (var a = 0, h = t.length; a < h; a++) {
                var u, l, c, d = t[a],
                    f = i(d),
                    g = null,
                    p = !1,
                    v = !0,
                    _ = [];
                if (f && d._path._overlapsOnly) {
                    var m = d._path,
                        y = d._intersection._segment._path;
                    m.compare(y) && (m.getArea() && o.push(m.clone(!1)), r(m), r(y), f = !1)
                }
                for (; f;) {
                    var x = !g,
                        b = function(t, e) {
                            function r(r, o) {
                                for (; r && r !== o;) {
                                    var a = r._segment,
                                        u = a._path,
                                        l = a.getNext() || u && u.getFirstSegment(),
                                        c = l && l._intersection;
                                    a !== t && (n(a) || n(l) || l && i(a) && (i(l) || c && i(c._segment))) && h.push(a), e && s.push(a), r = r._next
                                }
                            }
                            var o = t._intersection,
                                a = o,
                                h = [];
                            if (e && (s = [t]), o) {
                                for (r(o); o && o._prev;) o = o._prev;
                                r(o, a)
                            }
                            return h
                        }(d, x),
                        S = b.shift(),
                        p = !x && (n(d) || n(S)),
                        C = !p && S;
                    if (x && (g = new O(w.NO_INSERT), u = null), p) {
                        (d.isFirst() || d.isLast()) && (v = d._path._closed), d._visited = !0;
                        break
                    }
                    if (C && u && (_.push(u), u = null), u || (C && b.push(d), u = {
                            start: g._segments.length,
                            crossings: b,
                            visited: l = [],
                            handleIn: c
                        }), C && (d = S), !i(d)) {
                        g.removeSegments(u.start);
                        for (var T = 0, E = l.length; T < E; T++) l[T]._visited = !1;
                        l.length = 0;
                        do {
                            (d = u && u.crossings.shift()) || (u = _.pop()) && (l = u.visited, c = u.handleIn)
                        } while (u && !i(d));
                        if (!d) break
                    }
                    var z = d.getNext();
                    g.add(new k(d._point, c, z && d._handleOut)), d._visited = !0, l.push(d), d = z || d._path.getFirstSegment(), c = z && z._handleIn
                }
                p && (v && (g.firstSegment.setHandleIn(c), g.setClosed(v)), 0 !== g.getArea() && o.push(g))
            }
            return o
        }
        var g = Math.min,
            p = Math.max,
            v = Math.abs,
            _ = {
                unite: {
                    1: !0,
                    2: !0
                },
                intersect: {
                    2: !0
                },
                subtract: {
                    1: !0
                },
                exclude: {
                    1: !0,
                    "-1": !0
                }
            };
        return {
            _getWinding: function(t, e, i) {
                return c(t, this.getCurves(), e, i)
            },
            unite: function(t, e) {
                return n(this, t, "unite", e)
            },
            intersect: function(t, e) {
                return n(this, t, "intersect", e)
            },
            subtract: function(t, e) {
                return n(this, t, "subtract", e)
            },
            exclude: function(t, e) {
                return n(this, t, "exclude", e)
            },
            divide: function(t, e) {
                return e && (0 == e.trace || e.stroke) ? s(this, t, "divide") : i([this.subtract(t, e), this.intersect(t, e)], !0, this, t, e)
            },
            resolveCrossings: function() {
                function t(t) {
                    var e = t && t._intersection;
                    return e && e._overlap
                }
                var e = this._children,
                    i = e || [this],
                    n = !1,
                    s = !1,
                    o = this.getIntersections(null, function(t) {
                        return t.hasOverlap() && (n = !0) || t.isCrossing() && (s = !0)
                    }),
                    h = n && s && [];
                if (o = P.expand(o), n)
                    for (var u = l(o, function(t) {
                            return t.hasOverlap()
                        }, h), c = u.length - 1; c >= 0; c--) {
                        var d = u[c]._segment,
                            g = d.getPrevious(),
                            p = d.getNext();
                        t(g) && t(p) && (d.remove(), g._handleOut._set(0, 0), p._handleIn._set(0, 0), g === d || g.getCurve().hasLength() || (p._handleIn.set(g._handleIn), g.remove()))
                    }
                s && (l(o, n && function(t) {
                    var e = t.getCurve(),
                        i = t.getSegment(),
                        n = t._intersection,
                        r = n._curve,
                        s = n._segment;
                    if (e && r && e._path && r._path) return !0;
                    i && (i._intersection = null), s && (s._intersection = null)
                }, h), h && a(h), i = f(r.each(i, function(t) {
                    this.push.apply(this, t._segments)
                }, [])));
                var v, _ = i.length;
                return _ > 1 && e ? (i !== e && this.setChildren(i), v = this) : 1 !== _ || e || (i[0] !== this && this.setSegments(i[0].removeSegments()), v = this), v || (v = new L(w.NO_INSERT), v.addChildren(i), v = v.reduce(), v.copyAttributes(this), this.replaceWith(v)), v
            },
            reorient: function(t, i) {
                var n = this._children;
                return n && n.length ? this.setChildren(h(this.removeChildren(), function(e) {
                    return !!(t ? e : 1 & e)
                }, i)) : i !== e && this.setClockwise(i), this
            },
            getInteriorPoint: function() {
                var t = this.getBounds(),
                    e = t.getCenter(!0);
                if (!this.contains(e)) {
                    for (var i = this.getCurves(), n = e.y, r = [], s = [], o = 0, a = i.length; o < a; o++) {
                        var h = i[o].getValues(),
                            u = h[1],
                            l = h[3],
                            c = h[5],
                            d = h[7];
                        if (n >= g(u, l, c, d) && n <= p(u, l, c, d))
                            for (var f = A.getMonoCurves(h), v = 0, _ = f.length; v < _; v++) {
                                var m = f[v],
                                    y = m[1],
                                    w = m[7];
                                if (y !== w && (n >= y && n <= w || n >= w && n <= y)) {
                                    var x = n === y ? m[0] : n === w ? m[6] : 1 === A.solveCubic(m, 1, n, s, 0, 1) ? A.getPoint(m, s[0]).x : (m[0] + m[6]) / 2;
                                    r.push(x)
                                }
                            }
                    }
                    r.length > 1 && (r.sort(function(t, e) {
                        return t - e
                    }), e.x = (r[0] + r[1]) / 2)
                }
                return e
            }
        }
    });
    var N = r.extend({
            _class: "PathFlattener",
            initialize: function(t, e, i, n, r) {
                function s(t, e) {
                    var i = A.getValues(t, e, r);
                    h.push(i), o(i, t._index, 0, 1)
                }

                function o(t, i, r, s) {
                    if (!(s - r > c) || n && A.isStraight(t) || A.isFlatEnough(t, e || .25)) {
                        var a = t[6] - t[0],
                            h = t[7] - t[1],
                            d = Math.sqrt(a * a + h * h);
                        d > 0 && (l += d, u.push({
                            offset: l,
                            curve: t,
                            index: i,
                            time: s
                        }))
                    } else {
                        var f = A.subdivide(t, .5),
                            g = (r + s) / 2;
                        o(f[0], i, r, g), o(f[1], i, g, s)
                    }
                }
                for (var a, h = [], u = [], l = 0, c = 1 / (i || 32), d = t._segments, f = d[0], g = 1, p = d.length; g < p; g++) a = d[g], s(f, a), f = a;
                t._closed && s(a, d[0]), this.curves = h, this.parts = u, this.length = l, this.index = 0
            },
            _get: function(t) {
                for (var e, i = this.parts, n = i.length, r = this.index; e = r, r && !(i[--r].offset < t););
                for (; e < n; e++) {
                    var s = i[e];
                    if (s.offset >= t) {
                        this.index = e;
                        var o = i[e - 1],
                            a = o && o.index === s.index ? o.time : 0,
                            h = o ? o.offset : 0;
                        return {
                            index: s.index,
                            time: a + (s.time - a) * (t - h) / (s.offset - h)
                        }
                    }
                }
                return {
                    index: i[n - 1].index,
                    time: 1
                }
            },
            drawPart: function(t, e, i) {
                for (var n = this._get(e), r = this._get(i), s = n.index, o = r.index; s <= o; s++) {
                    var a = A.getPart(this.curves[s], s === n.index ? n.time : 0, s === r.index ? r.time : 1);
                    s === n.index && t.moveTo(a[0], a[1]), t.bezierCurveTo.apply(t, a.slice(2))
                }
            }
        }, r.each(A._evaluateMethods, function(t) {
            this[t + "At"] = function(e) {
                var i = this._get(e);
                return A[t](this.curves[i.index], i.time)
            }
        }, {})),
        F = r.extend({
            initialize: function(t) {
                for (var e, i = this.points = [], n = t._segments, r = t._closed, s = 0, o = n.length; s < o; s++) {
                    var a = n[s].point;
                    e && e.equals(a) || i.push(e = a.clone())
                }
                r && (i.unshift(i[i.length - 1]), i.push(i[1])), this.closed = r
            },
            fit: function(t) {
                var e = this.points,
                    i = e.length,
                    n = null;
                return i > 0 && (n = [new k(e[0])], i > 1 && (this.fitCubic(n, t, 0, i - 1, e[1].subtract(e[0]), e[i - 2].subtract(e[i - 1])), this.closed && (n.shift(), n.pop()))), n
            },
            fitCubic: function(t, e, i, n, r, s) {
                var o = this.points;
                if (n - i == 1) {
                    var a = o[i],
                        h = o[n],
                        u = a.getDistance(h) / 3;
                    return void this.addCurve(t, [a, a.add(r.normalize(u)), h.add(s.normalize(u)), h])
                }
                for (var l, c = this.chordLengthParameterize(i, n), d = Math.max(e, e * e), f = !0, g = 0; g <= 4; g++) {
                    var p = this.generateBezier(i, n, c, r, s),
                        v = this.findMaxError(i, n, p, c);
                    if (v.error < e && f) return void this.addCurve(t, p);
                    if (l = v.index, v.error >= d) break;
                    f = this.reparameterize(i, n, c, p), d = v.error
                }
                var _ = o[l - 1].subtract(o[l + 1]);
                this.fitCubic(t, e, i, l, r, _), this.fitCubic(t, e, l, n, _.negate(), s)
            },
            addCurve: function(t, e) {
                t[t.length - 1].setHandleOut(e[1].subtract(e[0])), t.push(new k(e[3], e[2].subtract(e[3])))
            },
            generateBezier: function(t, e, i, n, r) {
                for (var s = Math.abs, o = this.points, a = o[t], h = o[e], u = [
                        [0, 0],
                        [0, 0]
                    ], l = [0, 0], c = 0, d = e - t + 1; c < d; c++) {
                    var f = i[c],
                        g = 1 - f,
                        p = 3 * f * g,
                        v = g * g * g,
                        _ = p * g,
                        m = p * f,
                        y = f * f * f,
                        w = n.normalize(_),
                        x = r.normalize(m),
                        b = o[t + c].subtract(a.multiply(v + _)).subtract(h.multiply(m + y));
                    u[0][0] += w.dot(w), u[0][1] += w.dot(x), u[1][0] = u[0][1], u[1][1] += x.dot(x), l[0] += w.dot(b), l[1] += x.dot(b)
                }
                var S, C, T = u[0][0] * u[1][1] - u[1][0] * u[0][1];
                if (s(T) > 1e-12) {
                    var E = u[0][0] * l[1] - u[1][0] * l[0];
                    S = (l[0] * u[1][1] - l[1] * u[0][1]) / T, C = E / T
                } else {
                    var z = u[0][0] + u[0][1],
                        k = u[1][0] + u[1][1];
                    S = C = s(z) > 1e-12 ? l[0] / z : s(k) > 1e-12 ? l[1] / k : 0
                }
                var I, A, P = h.getDistance(a),
                    M = 1e-12 * P;
                if (S < M || C < M) S = C = P / 3;
                else {
                    var O = h.subtract(a);
                    I = n.normalize(S), A = r.normalize(C), I.dot(O) - A.dot(O) > P * P && (S = C = P / 3, I = A = null)
                }
                return [a, a.add(I || n.normalize(S)), h.add(A || r.normalize(C)), h]
            },
            reparameterize: function(t, e, i, n) {
                for (var r = t; r <= e; r++) i[r - t] = this.findRoot(n, this.points[r], i[r - t]);
                for (var r = 1, s = i.length; r < s; r++)
                    if (i[r] <= i[r - 1]) return !1;
                return !0
            },
            findRoot: function(t, e, i) {
                for (var n = [], r = [], s = 0; s <= 2; s++) n[s] = t[s + 1].subtract(t[s]).multiply(3);
                for (var s = 0; s <= 1; s++) r[s] = n[s + 1].subtract(n[s]).multiply(2);
                var o = this.evaluate(3, t, i),
                    a = this.evaluate(2, n, i),
                    h = this.evaluate(1, r, i),
                    l = o.subtract(e),
                    c = a.dot(a) + l.dot(h);
                return u.isZero(c) ? i : i - l.dot(a) / c
            },
            evaluate: function(t, e, i) {
                for (var n = e.slice(), r = 1; r <= t; r++)
                    for (var s = 0; s <= t - r; s++) n[s] = n[s].multiply(1 - i).add(n[s + 1].multiply(i));
                return n[0]
            },
            chordLengthParameterize: function(t, e) {
                for (var i = [0], n = t + 1; n <= e; n++) i[n - t] = i[n - t - 1] + this.points[n].getDistance(this.points[n - 1]);
                for (var n = 1, r = e - t; n <= r; n++) i[n] /= i[r];
                return i
            },
            findMaxError: function(t, e, i, n) {
                for (var r = Math.floor((e - t + 1) / 2), s = 0, o = t + 1; o < e; o++) {
                    var a = this.evaluate(3, i, n[o - t]),
                        h = a.subtract(this.points[o]),
                        u = h.x * h.x + h.y * h.y;
                    u >= s && (s = u, r = o)
                }
                return {
                    error: s,
                    index: r
                }
            }
        }),
        D = w.extend({
            _class: "TextItem",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _serializeFields: {
                content: null
            },
            _boundsOptions: {
                stroke: !1,
                handle: !1
            },
            initialize: function(t) {
                this._content = "", this._lines = [];
                var i = t && r.isPlainObject(t) && t.x === e && t.y === e;
                this._initialize(i && t, !i && c.read(arguments))
            },
            _equals: function(t) {
                return this._content === t._content
            },
            copyContent: function(t) {
                this.setContent(t._content)
            },
            getContent: function() {
                return this._content
            },
            setContent: function(t) {
                this._content = "" + t, this._lines = this._content.split(/\r\n|\n|\r/gm), this._changed(265)
            },
            isEmpty: function() {
                return !this._content
            },
            getCharacterStyle: "#getStyle",
            setCharacterStyle: "#setStyle",
            getParagraphStyle: "#getStyle",
            setParagraphStyle: "#setStyle"
        }),
        R = D.extend({
            _class: "PointText",
            initialize: function() {
                D.apply(this, arguments)
            },
            getPoint: function() {
                var t = this._matrix.getTranslation();
                return new d(t.x, t.y, this, "setPoint")
            },
            setPoint: function() {
                var t = c.read(arguments);
                this.translate(t.subtract(this._matrix.getTranslation()))
            },
            _draw: function(t, e, i) {
                if (this._content) {
                    this._setStyles(t, e, i);
                    var n = this._lines,
                        r = this._style,
                        s = r.hasFill(),
                        o = r.hasStroke(),
                        a = r.getLeading(),
                        h = t.shadowColor;
                    t.font = r.getFontStyle(), t.textAlign = r.getJustification();
                    for (var u = 0, l = n.length; u < l; u++) {
                        t.shadowColor = h;
                        var c = n[u];
                        s && (t.fillText(c, 0, 0), t.shadowColor = "rgba(0,0,0,0)"), o && t.strokeText(c, 0, 0), t.translate(0, a)
                    }
                }
            },
            _getBounds: function(t, e) {
                var i = this._style,
                    n = this._lines,
                    r = n.length,
                    s = i.getJustification(),
                    o = i.getLeading(),
                    a = this.getView().getTextWidth(i.getFontStyle(), n),
                    h = 0;
                "left" !== s && (h -= a / ("center" === s ? 2 : 1));
                var u = new p(h, r ? -.75 * o : 0, a, r * o);
                return t ? t._transformBounds(u, u) : u
            }
        }),
        B = r.extend(new function() {
            function t(t) {
                var n, r = t.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/);
                if (r) {
                    n = [0, 0, 0];
                    for (var s = 0; s < 3; s++) {
                        var a = r[s + 1];
                        n[s] = parseInt(1 == a.length ? a + a : a, 16) / 255
                    }
                } else if (r = t.match(/^rgba?\((.*)\)$/)) {
                    n = r[1].split(",");
                    for (var s = 0, h = n.length; s < h; s++) {
                        var a = +n[s];
                        n[s] = s < 3 ? a / 255 : a
                    }
                } else if (i) {
                    var u = o[t];
                    if (!u) {
                        e || (e = tt.getContext(1, 1), e.globalCompositeOperation = "copy"), e.fillStyle = "rgba(0,0,0,0)", e.fillStyle = t, e.fillRect(0, 0, 1, 1);
                        var l = e.getImageData(0, 0, 1, 1).data;
                        u = o[t] = [l[0] / 255, l[1] / 255, l[2] / 255]
                    }
                    n = u.slice()
                } else n = [0, 0, 0];
                return n
            }
            var e, n = {
                    gray: ["gray"],
                    rgb: ["red", "green", "blue"],
                    hsb: ["hue", "saturation", "brightness"],
                    hsl: ["hue", "saturation", "lightness"],
                    gradient: ["gradient", "origin", "destination", "highlight"]
                },
                s = {},
                o = {},
                a = [
                    [0, 3, 1],
                    [2, 0, 1],
                    [1, 0, 3],
                    [1, 2, 0],
                    [3, 1, 0],
                    [0, 1, 2]
                ],
                u = {
                    "rgb-hsb": function(t, e, i) {
                        var n = Math.max(t, e, i),
                            r = Math.min(t, e, i),
                            s = n - r;
                        return [0 === s ? 0 : 60 * (n == t ? (e - i) / s + (e < i ? 6 : 0) : n == e ? (i - t) / s + 2 : (t - e) / s + 4), 0 === n ? 0 : s / n, n]
                    },
                    "hsb-rgb": function(t, e, i) {
                        t = (t / 60 % 6 + 6) % 6;
                        var n = Math.floor(t),
                            r = t - n,
                            n = a[n],
                            s = [i, i * (1 - e), i * (1 - e * r), i * (1 - e * (1 - r))];
                        return [s[n[0]], s[n[1]], s[n[2]]]
                    },
                    "rgb-hsl": function(t, e, i) {
                        var n = Math.max(t, e, i),
                            r = Math.min(t, e, i),
                            s = n - r,
                            o = 0 === s,
                            a = o ? 0 : 60 * (n == t ? (e - i) / s + (e < i ? 6 : 0) : n == e ? (i - t) / s + 2 : (t - e) / s + 4),
                            h = (n + r) / 2;
                        return [a, o ? 0 : h < .5 ? s / (n + r) : s / (2 - n - r), h]
                    },
                    "hsl-rgb": function(t, e, i) {
                        if (t = (t / 360 % 1 + 1) % 1, 0 === e) return [i, i, i];
                        for (var n = [t + 1 / 3, t, t - 1 / 3], r = i < .5 ? i * (1 + e) : i + e - i * e, s = 2 * i - r, o = [], a = 0; a < 3; a++) {
                            var h = n[a];
                            h < 0 && (h += 1), h > 1 && (h -= 1), o[a] = 6 * h < 1 ? s + 6 * (r - s) * h : 2 * h < 1 ? r : 3 * h < 2 ? s + (r - s) * (2 / 3 - h) * 6 : s
                        }
                        return o
                    },
                    "rgb-gray": function(t, e, i) {
                        return [.2989 * t + .587 * e + .114 * i]
                    },
                    "gray-rgb": function(t) {
                        return [t, t, t]
                    },
                    "gray-hsb": function(t) {
                        return [0, 0, t]
                    },
                    "gray-hsl": function(t) {
                        return [0, 0, t]
                    },
                    "gradient-rgb": function() {
                        return []
                    },
                    "rgb-gradient": function() {
                        return []
                    }
                };
            return r.each(n, function(t, e) {
                s[e] = [], r.each(t, function(t, i) {
                    var o = r.capitalize(t),
                        a = /^(hue|saturation)$/.test(t),
                        h = s[e][i] = "gradient" === t ? function(t) {
                            var e = this._components[0];
                            return t = j.read(Array.isArray(t) ? t : arguments, 0, {
                                readNull: !0
                            }), e !== t && (e && e._removeOwner(this), t && t._addOwner(this)), t
                        } : "gradient" === e ? function() {
                            return c.read(arguments, 0, {
                                readNull: "highlight" === t,
                                clone: !0
                            })
                        } : function(t) {
                            return null == t || isNaN(t) ? 0 : t
                        };
                    this["get" + o] = function() {
                        return this._type === e || a && /^hs[bl]$/.test(this._type) ? this._components[i] : this._convert(e)[i]
                    }, this["set" + o] = function(t) {
                        this._type === e || a && /^hs[bl]$/.test(this._type) || (this._components = this._convert(e), this._properties = n[e], this._type = e), this._components[i] = h.call(this, t), this._changed()
                    }
                }, this)
            }, {
                _class: "Color",
                _readIndex: !0,
                initialize: function e(i) {
                    var o, a, h, u, l = arguments,
                        c = this.__read,
                        d = 0;
                    Array.isArray(i) && (l = i, i = l[0]);
                    var f = null != i && typeof i;
                    if ("string" === f && i in n && (o = i, i = l[1], Array.isArray(i) ? (a = i, h = l[2]) : (c && (d = 1), l = r.slice(l, 1), f = typeof i)), !a) {
                        if (u = "number" === f ? l : "object" === f && null != i.length ? i : null) {
                            o || (o = u.length >= 3 ? "rgb" : "gray");
                            var g = n[o].length;
                            h = u[g], c && (d += u === arguments ? g + (null != h ? 1 : 0) : 1), u.length > g && (u = r.slice(u, 0, g))
                        } else if ("string" === f) o = "rgb", a = t(i), 4 === a.length && (h = a[3], a.length--);
                        else if ("object" === f)
                            if (i.constructor === e) {
                                if (o = i._type, a = i._components.slice(), h = i._alpha, "gradient" === o)
                                    for (var p = 1, v = a.length; p < v; p++) {
                                        var _ = a[p];
                                        _ && (a[p] = _.clone())
                                    }
                            } else if (i.constructor === j) o = "gradient", u = l;
                        else {
                            o = "hue" in i ? "lightness" in i ? "hsl" : "hsb" : "gradient" in i || "stops" in i || "radial" in i ? "gradient" : "gray" in i ? "gray" : "rgb";
                            var m = n[o],
                                y = s[o];
                            this._components = a = [];
                            for (var p = 0, v = m.length; p < v; p++) {
                                var w = i[m[p]];
                                null == w && !p && "gradient" === o && "stops" in i && (w = {
                                    stops: i.stops,
                                    radial: i.radial
                                }), w = y[p].call(this, w), null != w && (a[p] = w)
                            }
                            h = i.alpha
                        }
                        c && o && (d = 1)
                    }
                    if (this._type = o || "rgb", !a) {
                        this._components = a = [];
                        for (var y = s[this._type], p = 0, v = y.length; p < v; p++) {
                            var w = y[p].call(this, u && u[p]);
                            null != w && (a[p] = w)
                        }
                    }
                    return this._components = a, this._properties = n[this._type], this._alpha = h, c && (this.__read = d), this
                },
                set: "#initialize",
                _serialize: function(t, e) {
                    var i = this.getComponents();
                    return r.serialize(/^(gray|rgb)$/.test(this._type) ? i : [this._type].concat(i), t, !0, e)
                },
                _changed: function() {
                    this._canvasStyle = null, this._owner && this._owner._changed(65)
                },
                _convert: function(t) {
                    var e;
                    return this._type === t ? this._components.slice() : (e = u[this._type + "-" + t]) ? e.apply(this, this._components) : u["rgb-" + t].apply(this, u[this._type + "-rgb"].apply(this, this._components))
                },
                convert: function(t) {
                    return new B(t, this._convert(t), this._alpha)
                },
                getType: function() {
                    return this._type
                },
                setType: function(t) {
                    this._components = this._convert(t), this._properties = n[t], this._type = t
                },
                getComponents: function() {
                    var t = this._components.slice();
                    return null != this._alpha && t.push(this._alpha), t
                },
                getAlpha: function() {
                    return null != this._alpha ? this._alpha : 1
                },
                setAlpha: function(t) {
                    this._alpha = null == t ? null : Math.min(Math.max(t, 0), 1), this._changed()
                },
                hasAlpha: function() {
                    return null != this._alpha
                },
                equals: function(t) {
                    var e = r.isPlainValue(t, !0) ? B.read(arguments) : t;
                    return e === this || e && this._class === e._class && this._type === e._type && this.getAlpha() === e.getAlpha() && r.equals(this._components, e._components) || !1
                },
                toString: function() {
                    for (var t = this._properties, e = [], i = "gradient" === this._type, n = h.instance, r = 0, s = t.length; r < s; r++) {
                        var o = this._components[r];
                        null != o && e.push(t[r] + ": " + (i ? o : n.number(o)))
                    }
                    return null != this._alpha && e.push("alpha: " + n.number(this._alpha)), "{ " + e.join(", ") + " }"
                },
                toCSS: function(t) {
                    function e(t) {
                        return Math.round(255 * (t < 0 ? 0 : t > 1 ? 1 : t))
                    }
                    var i = this._convert("rgb"),
                        n = t || null == this._alpha ? 1 : this._alpha;
                    return i = [e(i[0]), e(i[1]), e(i[2])], n < 1 && i.push(n < 0 ? 0 : n), t ? "#" + ((1 << 24) + (i[0] << 16) + (i[1] << 8) + i[2]).toString(16).slice(1) : (4 == i.length ? "rgba(" : "rgb(") + i.join(",") + ")"
                },
                toCanvasStyle: function(t, e) {
                    if (this._canvasStyle) return this._canvasStyle;
                    if ("gradient" !== this._type) return this._canvasStyle = this.toCSS();
                    var i, n = this._components,
                        r = n[0],
                        s = r._stops,
                        o = n[1],
                        a = n[2],
                        h = n[3],
                        u = e && e.inverted();
                    if (u && (o = u._transformPoint(o), a = u._transformPoint(a), h && (h = u._transformPoint(h))), r._radial) {
                        var l = a.getDistance(o);
                        if (h) {
                            var c = h.subtract(o);
                            c.getLength() > l && (h = o.add(c.normalize(l - .1)))
                        }
                        var d = h || o;
                        i = t.createRadialGradient(d.x, d.y, 0, o.x, o.y, l)
                    } else i = t.createLinearGradient(o.x, o.y, a.x, a.y);
                    for (var f = 0, g = s.length; f < g; f++) {
                        var p = s[f],
                            v = p._offset;
                        i.addColorStop(null == v ? f / (g - 1) : v, p._color.toCanvasStyle())
                    }
                    return this._canvasStyle = i
                },
                transform: function(t) {
                    if ("gradient" === this._type) {
                        for (var e = this._components, i = 1, n = e.length; i < n; i++) {
                            var r = e[i];
                            t._transformPoint(r, r, !0)
                        }
                        this._changed()
                    }
                },
                statics: {
                    _types: n,
                    random: function() {
                        var t = Math.random;
                        return new B(t(), t(), t())
                    }
                }
            })
        }, new function() {
            var t = {
                add: function(t, e) {
                    return t + e
                },
                subtract: function(t, e) {
                    return t - e
                },
                multiply: function(t, e) {
                    return t * e
                },
                divide: function(t, e) {
                    return t / e
                }
            };
            return r.each(t, function(t, e) {
                this[e] = function(e) {
                    e = B.read(arguments);
                    for (var i = this._type, n = this._components, r = e._convert(i), s = 0, o = n.length; s < o; s++) r[s] = t(n[s], r[s]);
                    return new B(i, r, null != this._alpha ? t(this._alpha, e.getAlpha()) : null)
                }
            }, {})
        }),
        j = r.extend({
            _class: "Gradient",
            initialize: function(t, e) {
                this._id = l.get(), t && r.isPlainObject(t) && (this.set(t), t = e = null), null == this._stops && this.setStops(t || ["white", "black"]), null == this._radial && this.setRadial("string" == typeof e && "radial" === e || e || !1)
            },
            _serialize: function(t, e) {
                return e.add(this, function() {
                    return r.serialize([this._stops, this._radial], t, !0, e)
                })
            },
            _changed: function() {
                for (var t = 0, e = this._owners && this._owners.length; t < e; t++) this._owners[t]._changed()
            },
            _addOwner: function(t) {
                this._owners || (this._owners = []), this._owners.push(t)
            },
            _removeOwner: function(t) {
                var i = this._owners ? this._owners.indexOf(t) : -1; - 1 != i && (this._owners.splice(i, 1), this._owners.length || (this._owners = e))
            },
            clone: function() {
                for (var t = [], e = 0, i = this._stops.length; e < i; e++) t[e] = this._stops[e].clone();
                return new j(t, this._radial)
            },
            getStops: function() {
                return this._stops
            },
            setStops: function(t) {
                if (t.length < 2) throw new Error("Gradient stop list needs to contain at least two stops.");
                var i = this._stops;
                if (i)
                    for (var n = 0, r = i.length; n < r; n++) i[n]._owner = e;
                i = this._stops = q.readList(t, 0, {
                    clone: !0
                });
                for (var n = 0, r = i.length; n < r; n++) i[n]._owner = this;
                this._changed()
            },
            getRadial: function() {
                return this._radial
            },
            setRadial: function(t) {
                this._radial = t, this._changed()
            },
            equals: function(t) {
                if (t === this) return !0;
                if (t && this._class === t._class) {
                    var e = this._stops,
                        i = t._stops,
                        n = e.length;
                    if (n === i.length) {
                        for (var r = 0; r < n; r++)
                            if (!e[r].equals(i[r])) return !1;
                        return !0
                    }
                }
                return !1
            }
        }),
        q = r.extend({
            _class: "GradientStop",
            initialize: function(t, i) {
                var n = t,
                    r = i;
                "object" == typeof t && i === e && (Array.isArray(t) && "number" != typeof t[0] ? (n = t[0], r = t[1]) : ("color" in t || "offset" in t || "rampPoint" in t) && (n = t.color, r = t.offset || t.rampPoint || 0)), this.setColor(n), this.setOffset(r)
            },
            clone: function() {
                return new q(this._color.clone(), this._offset)
            },
            _serialize: function(t, e) {
                var i = this._color,
                    n = this._offset;
                return r.serialize(null == n ? [i] : [i, n], t, !0, e)
            },
            _changed: function() {
                this._owner && this._owner._changed(65)
            },
            getOffset: function() {
                return this._offset
            },
            setOffset: function(t) {
                this._offset = t, this._changed()
            },
            getRampPoint: "#getOffset",
            setRampPoint: "#setOffset",
            getColor: function() {
                return this._color
            },
            setColor: function() {
                var t = B.read(arguments, 0, {
                    clone: !0
                });
                t && (t._owner = this), this._color = t, this._changed()
            },
            equals: function(t) {
                return t === this || t && this._class === t._class && this._color.equals(t._color) && this._offset == t._offset || !1
            }
        }),
        H = r.extend(new function() {
            var t = {
                    fillColor: null,
                    fillRule: "nonzero",
                    strokeColor: null,
                    strokeWidth: 1,
                    strokeCap: "butt",
                    strokeJoin: "miter",
                    strokeScaling: !0,
                    miterLimit: 10,
                    dashOffset: 0,
                    dashArray: [],
                    shadowColor: null,
                    shadowBlur: 0,
                    shadowOffset: new c,
                    selectedColor: null
                },
                i = r.set({}, t, {
                    fontFamily: "sans-serif",
                    fontWeight: "normal",
                    fontSize: 12,
                    leading: null,
                    justification: "left"
                }),
                n = r.set({}, i, {
                    fillColor: new B
                }),
                s = {
                    strokeWidth: 97,
                    strokeCap: 97,
                    strokeJoin: 97,
                    strokeScaling: 105,
                    miterLimit: 97,
                    fontFamily: 9,
                    fontWeight: 9,
                    fontSize: 9,
                    font: 9,
                    leading: 9,
                    justification: 9
                },
                o = {
                    beans: !0
                },
                a = {
                    _class: "Style",
                    beans: !0,
                    initialize: function(e, r, s) {
                        this._values = {}, this._owner = r, this._project = r && r._project || s || paper.project, this._defaults = !r || r instanceof x ? i : r instanceof D ? n : t, e && this.set(e)
                    }
                };
            return r.each(i, function(t, i) {
                var n = /Color$/.test(i),
                    h = "shadowOffset" === i,
                    u = r.capitalize(i),
                    l = s[i],
                    d = "set" + u,
                    f = "get" + u;
                a[d] = function(t) {
                    var r = this._owner,
                        s = r && r._children;
                    if (s && s.length > 0 && !(r instanceof L))
                        for (var o = 0, a = s.length; o < a; o++) s[o]._style[d](t);
                    else if (i in this._defaults) {
                        var h = this._values[i];
                        h !== t && (n && (h && h._owner !== e && (h._owner = e), t && t.constructor === B && (t._owner && (t = t.clone()), t._owner = r)), this._values[i] = t, r && r._changed(l || 65))
                    }
                }, a[f] = function(t) {
                    var s, o = this._owner,
                        a = o && o._children;
                    if (i in this._defaults && (!a || !a.length || t || o instanceof L)) {
                        var s = this._values[i];
                        if (s === e)(s = this._defaults[i]) && s.clone && (s = s.clone());
                        else {
                            var u = n ? B : h ? c : null;
                            !u || s && s.constructor === u || (this._values[i] = s = u.read([s], 0, {
                                readNull: !0,
                                clone: !0
                            }), s && n && (s._owner = o))
                        }
                    } else if (a)
                        for (var l = 0, d = a.length; l < d; l++) {
                            var g = a[l]._style[f]();
                            if (l) {
                                if (!r.equals(s, g)) return e
                            } else s = g
                        }
                    return s
                }, o[f] = function(t) {
                    return this._style[f](t)
                }, o[d] = function(t) {
                    this._style[d](t)
                }
            }), r.each({
                Font: "FontFamily",
                WindingRule: "FillRule"
            }, function(t, e) {
                var i = "get" + e,
                    n = "set" + e;
                a[i] = o[i] = "#get" + t, a[n] = o[n] = "#set" + t
            }), w.inject(o), a
        }, {
            set: function(t) {
                var e = t instanceof H,
                    i = e ? t._values : t;
                if (i)
                    for (var n in i)
                        if (n in this._defaults) {
                            var r = i[n];
                            this[n] = r && e && r.clone ? r.clone() : r
                        }
            },
            equals: function(t) {
                function i(t, i, n) {
                    var s = t._values,
                        o = i._values,
                        a = i._defaults;
                    for (var h in s) {
                        var u = s[h],
                            l = o[h];
                        if (!(n && h in o || r.equals(u, l === e ? a[h] : l))) return !1
                    }
                    return !0
                }
                return t === this || t && this._class === t._class && i(this, t) && i(t, this, !0) || !1
            },
            hasFill: function() {
                var t = this.getFillColor();
                return !!t && t.alpha > 0
            },
            hasStroke: function() {
                var t = this.getStrokeColor();
                return !!t && t.alpha > 0 && this.getStrokeWidth() > 0
            },
            hasShadow: function() {
                var t = this.getShadowColor();
                return !!t && t.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero())
            },
            getView: function() {
                return this._project._view
            },
            getFontStyle: function() {
                var t = this.getFontSize();
                return this.getFontWeight() + " " + t + (/[a-z]/i.test(t + "") ? " " : "px ") + this.getFontFamily()
            },
            getFont: "#getFontFamily",
            setFont: "#setFontFamily",
            getLeading: function t() {
                var e = t.base.call(this),
                    i = this.getFontSize();
                return /pt|em|%|px/.test(i) && (i = this.getView().getPixelSize(i)), null != e ? e : 1.2 * i
            }
        }),
        W = new function() {
            function t(t, e, i, n) {
                for (var r = ["", "webkit", "moz", "Moz", "ms", "o"], s = e[0].toUpperCase() + e.substring(1), o = 0; o < 6; o++) {
                    var a = r[o],
                        h = a ? a + s : e;
                    if (h in t) {
                        if (!i) return t[h];
                        t[h] = n;
                        break
                    }
                }
            }
            return {
                getStyles: function(t) {
                    var e = t && 9 !== t.nodeType ? t.ownerDocument : t,
                        i = e && e.defaultView;
                    return i && i.getComputedStyle(t, "")
                },
                getBounds: function(t, e) {
                    var i, n = t.ownerDocument,
                        r = n.body,
                        s = n.documentElement;
                    try {
                        i = t.getBoundingClientRect()
                    } catch (t) {
                        i = {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        }
                    }
                    var o = i.left - (s.clientLeft || r.clientLeft || 0),
                        a = i.top - (s.clientTop || r.clientTop || 0);
                    if (!e) {
                        var h = n.defaultView;
                        o += h.pageXOffset || s.scrollLeft || r.scrollLeft, a += h.pageYOffset || s.scrollTop || r.scrollTop
                    }
                    return new p(o, a, i.width, i.height)
                },
                getViewportBounds: function(t) {
                    var e = t.ownerDocument,
                        i = e.defaultView,
                        n = e.documentElement;
                    return new p(0, 0, i.innerWidth || n.clientWidth, i.innerHeight || n.clientHeight)
                },
                getOffset: function(t, e) {
                    return W.getBounds(t, e).getPoint()
                },
                getSize: function(t) {
                    return W.getBounds(t, !0).getSize()
                },
                isInvisible: function(t) {
                    return W.getSize(t).equals(new f(0, 0))
                },
                isInView: function(t) {
                    return !W.isInvisible(t) && W.getViewportBounds(t).intersects(W.getBounds(t, !0))
                },
                isInserted: function(t) {
                    return n.body.contains(t)
                },
                getPrefixed: function(e, i) {
                    return e && t(e, i)
                },
                setPrefixed: function(e, i, n) {
                    if ("object" == typeof i)
                        for (var r in i) t(e, r, !0, i[r]);
                    else t(e, i, !0, n)
                }
            }
        },
        V = {
            add: function(t, e) {
                if (t)
                    for (var i in e)
                        for (var n = e[i], r = i.split(/[\s,]+/g), s = 0, o = r.length; s < o; s++) t.addEventListener(r[s], n, !1)
            },
            remove: function(t, e) {
                if (t)
                    for (var i in e)
                        for (var n = e[i], r = i.split(/[\s,]+/g), s = 0, o = r.length; s < o; s++) t.removeEventListener(r[s], n, !1)
            },
            getPoint: function(t) {
                var e = t.targetTouches ? t.targetTouches.length ? t.targetTouches[0] : t.changedTouches[0] : t;
                return new c(e.pageX || e.clientX + n.documentElement.scrollLeft, e.pageY || e.clientY + n.documentElement.scrollTop)
            },
            getTarget: function(t) {
                return t.target || t.srcElement
            },
            getRelatedTarget: function(t) {
                return t.relatedTarget || t.toElement
            },
            getOffset: function(t, e) {
                return V.getPoint(t).subtract(W.getOffset(e || V.getTarget(t)))
            }
        };
    V.requestAnimationFrame = new function() {
        function t() {
            var e = s;
            s = [];
            for (var i = 0, o = e.length; i < o; i++) e[i]();
            (r = n && s.length) && n(t)
        }
        var e, n = W.getPrefixed(i, "requestAnimationFrame"),
            r = !1,
            s = [];
        return function(i) {
            s.push(i), n ? r || (n(t), r = !0) : e || (e = setInterval(t, 1e3 / 60))
        }
    };
    var U = r.extend(s, {
            _class: "View",
            initialize: function t(e, r) {
                function s(t) {
                    return r[t] || parseInt(r.getAttribute(t), 10)
                }

                function a() {
                    var t = W.getSize(r);
                    return t.isNaN() || t.isZero() ? new f(s("width"), s("height")) : t
                }
                var h;
                if (i && r) {
                    this._id = r.getAttribute("id"), null == this._id && r.setAttribute("id", this._id = "view-" + t._id++), V.add(r, this._viewEvents);
                    if (W.setPrefixed(r.style, {
                            userDrag: "none",
                            userSelect: "none",
                            touchCallout: "none",
                            contentZooming: "none",
                            tapHighlightColor: "rgba(0,0,0,0)"
                        }), o.hasAttribute(r, "resize")) {
                        var u = this;
                        V.add(i, this._windowEvents = {
                            resize: function() {
                                u.setViewSize(a())
                            }
                        })
                    }
                    if (h = a(), o.hasAttribute(r, "stats") && "undefined" != typeof Stats) {
                        this._stats = new Stats;
                        var l = this._stats.domElement,
                            c = l.style,
                            d = W.getOffset(r);
                        c.position = "absolute", c.left = d.x + "px", c.top = d.y + "px", n.body.appendChild(l)
                    }
                } else h = new f(r), r = null;
                this._project = e, this._scope = e._scope, this._element = r, this._pixelRatio || (this._pixelRatio = i && i.devicePixelRatio || 1), this._setElementSize(h.width, h.height), this._viewSize = h, t._views.push(this), t._viewsById[this._id] = this, (this._matrix = new _)._owner = this, t._focused || (t._focused = this), this._frameItems = {}, this._frameItemCount = 0, this._itemEvents = {
                    native: {},
                    virtual: {}
                }, this._autoUpdate = !paper.agent.node, this._needsUpdate = !1
            },
            remove: function() {
                if (!this._project) return !1;
                U._focused === this && (U._focused = null), U._views.splice(U._views.indexOf(this), 1), delete U._viewsById[this._id];
                var t = this._project;
                return t._view === this && (t._view = null), V.remove(this._element, this._viewEvents), V.remove(i, this._windowEvents), this._element = this._project = null, this.off("frame"), this._animate = !1, this._frameItems = {}, !0
            },
            _events: r.each(w._itemHandlers.concat(["onResize", "onKeyDown", "onKeyUp"]), function(t) {
                this[t] = {}
            }, {
                onFrame: {
                    install: function() {
                        this.play()
                    },
                    uninstall: function() {
                        this.pause()
                    }
                }
            }),
            _animate: !1,
            _time: 0,
            _count: 0,
            getAutoUpdate: function() {
                return this._autoUpdate
            },
            setAutoUpdate: function(t) {
                this._autoUpdate = t, t && this.requestUpdate()
            },
            update: function() {},
            draw: function() {
                this.update()
            },
            requestUpdate: function() {
                if (!this._requested) {
                    var t = this;
                    V.requestAnimationFrame(function() {
                        if (t._requested = !1, t._animate) {
                            t.requestUpdate();
                            var e = t._element;
                            W.getPrefixed(n, "hidden") && "true" !== o.getAttribute(e, "keepalive") || !W.isInView(e) || t._handleFrame()
                        }
                        t._autoUpdate && t.update()
                    }), this._requested = !0
                }
            },
            play: function() {
                this._animate = !0, this.requestUpdate()
            },
            pause: function() {
                this._animate = !1
            },
            _handleFrame: function() {
                paper = this._scope;
                var t = Date.now() / 1e3,
                    e = this._last ? t - this._last : 0;
                this._last = t, this.emit("frame", new r({
                    delta: e,
                    time: this._time += e,
                    count: this._count++
                })), this._stats && this._stats.update()
            },
            _animateItem: function(t, e) {
                var i = this._frameItems;
                e ? (i[t._id] = {
                    item: t,
                    time: 0,
                    count: 0
                }, 1 == ++this._frameItemCount && this.on("frame", this._handleFrameItems)) : (delete i[t._id], 0 == --this._frameItemCount && this.off("frame", this._handleFrameItems))
            },
            _handleFrameItems: function(t) {
                for (var e in this._frameItems) {
                    var i = this._frameItems[e];
                    i.item.emit("frame", new r(t, {
                        time: i.time += t.delta,
                        count: i.count++
                    }))
                }
            },
            _changed: function() {
                this._project._changed(2049), this._bounds = this._decomposed = e
            },
            getElement: function() {
                return this._element
            },
            getPixelRatio: function() {
                return this._pixelRatio
            },
            getResolution: function() {
                return 72 * this._pixelRatio
            },
            getViewSize: function() {
                var t = this._viewSize;
                return new g(t.width, t.height, this, "setViewSize")
            },
            setViewSize: function() {
                var t = f.read(arguments),
                    e = t.subtract(this._viewSize);
                e.isZero() || (this._setElementSize(t.width, t.height), this._viewSize.set(t), this._changed(), this.emit("resize", {
                    size: t,
                    delta: e
                }), this._autoUpdate && this.update())
            },
            _setElementSize: function(t, e) {
                var i = this._element;
                i && (i.width !== t && (i.width = t), i.height !== e && (i.height = e))
            },
            getBounds: function() {
                return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(new p(new c, this._viewSize))), this._bounds
            },
            getSize: function() {
                return this.getBounds().getSize()
            },
            isVisible: function() {
                return W.isInView(this._element)
            },
            isInserted: function() {
                return W.isInserted(this._element)
            },
            getPixelSize: function(t) {
                var e, i = this._element;
                if (i) {
                    var r = i.parentNode,
                        s = n.createElement("div");
                    s.style.fontSize = t, r.appendChild(s), e = parseFloat(W.getStyles(s).fontSize), r.removeChild(s)
                } else e = parseFloat(e);
                return e
            },
            getTextWidth: function(t, e) {
                return 0
            }
        }, r.each(["rotate", "scale", "shear", "skew"], function(t) {
            var e = "rotate" === t;
            this[t] = function() {
                var i = (e ? r : c).read(arguments),
                    n = c.read(arguments, 0, {
                        readNull: !0
                    });
                return this.transform((new _)[t](i, n || this.getCenter(!0)))
            }
        }, {
            _decompose: function() {
                return this._decomposed || (this._decomposed = this._matrix.decompose())
            },
            translate: function() {
                var t = new _;
                return this.transform(t.translate.apply(t, arguments))
            },
            getCenter: function() {
                return this.getBounds().getCenter()
            },
            setCenter: function() {
                var t = c.read(arguments);
                this.translate(this.getCenter().subtract(t))
            },
            getZoom: function() {
                var t = this._decompose(),
                    e = t && t.scaling;
                return e ? (e.x + e.y) / 2 : 0
            },
            setZoom: function(t) {
                this.transform((new _).scale(t / this.getZoom(), this.getCenter()))
            },
            getRotation: function() {
                var t = this._decompose();
                return t && t.rotation
            },
            setRotation: function(t) {
                var e = this.getRotation();
                null != e && null != t && this.rotate(t - e)
            },
            getScaling: function() {
                var t = this._decompose(),
                    i = t && t.scaling;
                return i ? new d(i.x, i.y, this, "setScaling") : e
            },
            setScaling: function() {
                var t = this.getScaling(),
                    e = c.read(arguments, 0, {
                        clone: !0,
                        readNull: !0
                    });
                t && e && this.scale(e.x / t.x, e.y / t.y)
            },
            getMatrix: function() {
                return this._matrix
            },
            setMatrix: function() {
                var t = this._matrix;
                t.initialize.apply(t, arguments)
            },
            transform: function(t) {
                this._matrix.append(t)
            },
            scrollBy: function() {
                this.translate(c.read(arguments).negate())
            }
        }), {
            projectToView: function() {
                return this._matrix._transformPoint(c.read(arguments))
            },
            viewToProject: function() {
                return this._matrix._inverseTransform(c.read(arguments))
            },
            getEventPoint: function(t) {
                return this.viewToProject(V.getOffset(t, this._element))
            }
        }, {
            statics: {
                _views: [],
                _viewsById: {},
                _id: 0,
                create: function(t, e) {
                    return n && "string" == typeof e && (e = n.getElementById(e)), new(i ? Y : U)(t, e)
                }
            }
        }, new function() {
            function t(t) {
                var e = V.getTarget(t);
                return e.getAttribute && U._viewsById[e.getAttribute("id")]
            }

            function e() {
                var t = U._focused;
                if (!t || !t.isVisible())
                    for (var e = 0, i = U._views.length; e < i; e++)
                        if ((t = U._views[e]).isVisible()) {
                            U._focused = h = t;
                            break
                        }
            }

            function r(t, e, i) {
                t._handleMouseEvent("mousemove", e, i)
            }

            function s(t, e, i, n, r, s, o) {
                function a(t, i) {
                    if (t.responds(i)) {
                        if (h || (h = new $(i, n, r, e || t, s ? r.subtract(s) : null)), t.emit(i, h) && (E = !0, h.prevented && (z = !0), h.stopped)) return u = !0
                    } else {
                        var o = k[i];
                        if (o) return a(t, o)
                    }
                }
                for (var h, u = !1; t && t !== o && !a(t, i);) t = t._parent;
                return u
            }

            function o(t, e, i, n, r, o) {
                return t._project.removeOn(i), z = E = !1, b && s(b, null, i, n, r, o) || e && e !== b && !e.isDescendant(b) && s(e, null, i, n, r, o, b) || s(t, b || e || t, i, n, r, o)
            }
            if (i) {
                var a, h, u, l, c, d = !1,
                    f = !1,
                    g = i.navigator;
                g.pointerEnabled || g.msPointerEnabled ? (u = "pointerdown MSPointerDown", l = "pointermove MSPointerMove", c = "pointerup pointercancel MSPointerUp MSPointerCancel") : (u = "touchstart", l = "touchmove", c = "touchend touchcancel", "ontouchstart" in i && g.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i) || (u += " mousedown", l += " mousemove", c += " mouseup"));
                var p = {},
                    v = {
                        mouseout: function(t) {
                            var e = U._focused,
                                i = V.getRelatedTarget(t);
                            if (e && (!i || "HTML" === i.nodeName)) {
                                var n = V.getOffset(t, e._element),
                                    s = n.x,
                                    o = Math.abs,
                                    a = o(s),
                                    h = a - (1 << 25);
                                n.x = o(h) < a ? h * (s < 0 ? -1 : 1) : s, r(e, t, e.viewToProject(n))
                            }
                        },
                        scroll: e
                    };
                p[u] = function(e) {
                    var i = U._focused = t(e);
                    d || (d = !0, i._handleMouseEvent("mousedown", e))
                }, v[l] = function(i) {
                    var n = U._focused;
                    if (!f) {
                        var s = t(i);
                        s ? n !== s && (n && r(n, i), a || (a = n), n = U._focused = h = s) : h && h === n && (a && !a.isInserted() && (a = null), n = U._focused = a, a = null, e())
                    }
                    n && r(n, i)
                }, v[u] = function() {
                    f = !0
                }, v[c] = function(t) {
                    var e = U._focused;
                    e && d && e._handleMouseEvent("mouseup", t), f = d = !1
                }, V.add(n, v), V.add(i, {
                    load: e
                });
                var _, m, y, w, x, b, S, C, T, E = !1,
                    z = !1,
                    k = {
                        doubleclick: "click",
                        mousedrag: "mousemove"
                    },
                    I = !1,
                    A = {
                        mousedown: {
                            mousedown: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mouseup: {
                            mouseup: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mousemove: {
                            mousedrag: 1,
                            mousemove: 1,
                            mouseenter: 1,
                            mouseleave: 1
                        }
                    };
                return {
                    _viewEvents: p,
                    _handleMouseEvent: function(t, e, i) {
                        function n(t) {
                            return r.virtual[t] || l.responds(t) || u && u.responds(t)
                        }
                        var r = this._itemEvents,
                            a = r.native[t],
                            h = "mousemove" === t,
                            u = this._scope.tool,
                            l = this;
                        h && d && n("mousedrag") && (t = "mousedrag"), i || (i = this.getEventPoint(e));
                        var c = this.getBounds().contains(i),
                            f = a && c && l._project.hitTest(i, {
                                tolerance: 0,
                                fill: !0,
                                stroke: !0
                            }),
                            g = f && f.item || null,
                            p = !1,
                            v = {};
                        if (v[t.substr(5)] = !0, a && g !== x && (x && s(x, null, "mouseleave", e, i), g && s(g, null, "mouseenter", e, i), x = g), I ^ c && (s(this, null, c ? "mouseenter" : "mouseleave", e, i), _ = c ? this : null, p = !0), !c && !v.drag || i.equals(y) || (o(this, g, h ? t : "mousemove", e, i, y), p = !0), I = c, v.down && c || v.up && m) {
                            if (o(this, g, t, e, i, m), v.down) {
                                if (T = g === S && Date.now() - C < 300, w = S = g, !z && g) {
                                    for (var k = g; k && !k.responds("mousedrag");) k = k._parent;
                                    k && (b = g)
                                }
                                m = i
                            } else v.up && (z || g !== w || (C = Date.now(), o(this, g, T ? "doubleclick" : "click", e, i, m), T = !1), w = b = null);
                            I = !1, p = !0
                        }
                        y = i, p && u && (E = u._handleMouseEvent(t, e, i, v) || E), (E && !v.move || v.down && n("mouseup")) && e.preventDefault()
                    },
                    _handleKeyEvent: function(t, e, i, n) {
                        function r(r) {
                            r.responds(t) && (paper = o, r.emit(t, s = s || new Z(t, e, i, n)))
                        }
                        var s, o = this._scope,
                            a = o.tool;
                        this.isVisible() && (r(this), a && a.responds(t) && r(a))
                    },
                    _countItemEvent: function(t, e) {
                        var i = this._itemEvents,
                            n = i.native,
                            r = i.virtual;
                        for (var s in A) n[s] = (n[s] || 0) + (A[s][t] || 0) * e;
                        r[t] = (r[t] || 0) + e
                    },
                    statics: {
                        updateFocus: e
                    }
                }
            }
        }),
        Y = U.extend({
            _class: "CanvasView",
            initialize: function(t, e) {
                if (!(e instanceof i.HTMLCanvasElement)) {
                    var n = f.read(arguments, 1);
                    if (n.isZero()) throw new Error("Cannot create CanvasView with the provided argument: " + r.slice(arguments, 1));
                    e = tt.getCanvas(n)
                }
                var s = this._context = e.getContext("2d");
                if (s.save(), this._pixelRatio = 1, !/^off|false$/.test(o.getAttribute(e, "hidpi"))) {
                    var a = i.devicePixelRatio || 1,
                        h = W.getPrefixed(s, "backingStorePixelRatio") || 1;
                    this._pixelRatio = a / h
                }
                U.call(this, t, e), this._needsUpdate = !0
            },
            remove: function t() {
                return this._context.restore(), t.base.call(this)
            },
            _setElementSize: function t(e, i) {
                var n = this._pixelRatio;
                if (t.base.call(this, e * n, i * n), 1 !== n) {
                    var r = this._element,
                        s = this._context;
                    if (!o.hasAttribute(r, "resize")) {
                        var a = r.style;
                        a.width = e + "px", a.height = i + "px"
                    }
                    s.restore(), s.save(), s.scale(n, n)
                }
            },
            getPixelSize: function t(e) {
                var i, n = paper.agent;
                if (n && n.firefox) i = t.base.call(this, e);
                else {
                    var r = this._context,
                        s = r.font;
                    r.font = e + " serif", i = parseFloat(r.font), r.font = s
                }
                return i
            },
            getTextWidth: function(t, e) {
                var i = this._context,
                    n = i.font,
                    r = 0;
                i.font = t;
                for (var s = 0, o = e.length; s < o; s++) r = Math.max(r, i.measureText(e[s]).width);
                return i.font = n, r
            },
            update: function() {
                if (!this._needsUpdate) return !1;
                var t = this._project,
                    e = this._context,
                    i = this._viewSize;
                return e.clearRect(0, 0, i.width + 1, i.height + 1), t && t.draw(e, this._matrix, this._pixelRatio), this._needsUpdate = !1, !0
            }
        }),
        X = r.extend({
            _class: "Event",
            initialize: function(t) {
                this.event = t, this.type = t && t.type
            },
            prevented: !1,
            stopped: !1,
            preventDefault: function() {
                this.prevented = !0, this.event.preventDefault()
            },
            stopPropagation: function() {
                this.stopped = !0, this.event.stopPropagation()
            },
            stop: function() {
                this.stopPropagation(), this.preventDefault()
            },
            getTimeStamp: function() {
                return this.event.timeStamp
            },
            getModifiers: function() {
                return G.modifiers
            }
        }),
        Z = X.extend({
            _class: "KeyEvent",
            initialize: function(t, e, i, n) {
                this.type = t, this.event = e, this.key = i, this.character = n
            },
            toString: function() {
                return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }"
            }
        }),
        G = new function() {
            function t(t) {
                var e = t.key || t.keyIdentifier;
                return e = /^U\+/.test(e) ? String.fromCharCode(parseInt(e.substr(2), 16)) : /^Arrow[A-Z]/.test(e) ? e.substr(5) : "Unidentified" === e ? String.fromCharCode(t.keyCode) : e, a[e] || (e.length > 1 ? r.hyphenate(e) : e.toLowerCase())
            }

            function e(t, i, n, o) {
                var a, h = U._focused;
                if (u[i] = t, t ? l[i] = n : delete l[i], i.length > 1 && (a = r.camelize(i)) in c) {
                    c[a] = t;
                    var d = paper && paper.agent;
                    if ("meta" === a && d && d.mac)
                        if (t) s = {};
                        else {
                            for (var f in s) f in l && e(!1, f, s[f], o);
                            s = null
                        }
                } else t && s && (s[i] = n);
                h && h._handleKeyEvent(t ? "keydown" : "keyup", o, i, n)
            }
            var s, o, a = {
                    "\t": "tab",
                    " ": "space",
                    "\b": "backspace",
                    "": "delete",
                    Spacebar: "space",
                    Del: "delete",
                    Win: "meta",
                    Esc: "escape"
                },
                h = {
                    tab: "\t",
                    space: " ",
                    enter: "\r"
                },
                u = {},
                l = {},
                c = new r({
                    shift: !1,
                    control: !1,
                    alt: !1,
                    meta: !1,
                    capsLock: !1,
                    space: !1
                }).inject({
                    option: {
                        get: function() {
                            return this.alt
                        }
                    },
                    command: {
                        get: function() {
                            var t = paper && paper.agent;
                            return t && t.mac ? this.meta : this.control
                        }
                    }
                });
            return V.add(n, {
                keydown: function(i) {
                    var n = t(i),
                        r = paper && paper.agent;
                    n.length > 1 || r && r.chrome && (i.altKey || r.mac && i.metaKey || !r.mac && i.ctrlKey) ? e(!0, n, h[n] || (n.length > 1 ? "" : n), i) : o = n
                },
                keypress: function(i) {
                    if (o) {
                        var n = t(i),
                            r = i.charCode,
                            s = r >= 32 ? String.fromCharCode(r) : n.length > 1 ? "" : n;
                        n !== o && (n = s.toLowerCase()), e(!0, n, s, i), o = null
                    }
                },
                keyup: function(i) {
                    var n = t(i);
                    n in l && e(!1, n, l[n], i)
                }
            }), V.add(i, {
                blur: function(t) {
                    for (var i in l) e(!1, i, l[i], t)
                }
            }), {
                modifiers: c,
                isDown: function(t) {
                    return !!u[t]
                }
            }
        },
        $ = X.extend({
            _class: "MouseEvent",
            initialize: function(t, e, i, n, r) {
                this.type = t, this.event = e, this.point = i, this.target = n, this.delta = r
            },
            toString: function() {
                return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }"
            }
        }),
        J = X.extend({
            _class: "ToolEvent",
            _item: null,
            initialize: function(t, e, i) {
                this.tool = t, this.type = e, this.event = i
            },
            _choosePoint: function(t, e) {
                return t || (e ? e.clone() : null)
            },
            getPoint: function() {
                return this._choosePoint(this._point, this.tool._point)
            },
            setPoint: function(t) {
                this._point = t
            },
            getLastPoint: function() {
                return this._choosePoint(this._lastPoint, this.tool._lastPoint)
            },
            setLastPoint: function(t) {
                this._lastPoint = t
            },
            getDownPoint: function() {
                return this._choosePoint(this._downPoint, this.tool._downPoint)
            },
            setDownPoint: function(t) {
                this._downPoint = t
            },
            getMiddlePoint: function() {
                return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint
            },
            setMiddlePoint: function(t) {
                this._middlePoint = t
            },
            getDelta: function() {
                return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta
            },
            setDelta: function(t) {
                this._delta = t
            },
            getCount: function() {
                return this.tool[/^mouse(down|up)$/.test(this.type) ? "_downCount" : "_moveCount"]
            },
            setCount: function(t) {
                this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = t
            },
            getItem: function() {
                if (!this._item) {
                    var t = this.tool._scope.project.hitTest(this.getPoint());
                    if (t) {
                        for (var e = t.item, i = e._parent;
                            /^(Group|CompoundPath)$/.test(i._class);) e = i, i = i._parent;
                        this._item = e
                    }
                }
                return this._item
            },
            setItem: function(t) {
                this._item = t
            },
            toString: function() {
                return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }"
            }
        }),
        Q = a.extend({
            _class: "Tool",
            _list: "tools",
            _reference: "tool",
            _events: ["onMouseDown", "onMouseUp", "onMouseDrag", "onMouseMove", "onActivate", "onDeactivate", "onEditOptions", "onKeyDown", "onKeyUp"],
            initialize: function(t) {
                a.call(this), this._moveCount = -1, this._downCount = -1, this.set(t)
            },
            getMinDistance: function() {
                return this._minDistance
            },
            setMinDistance: function(t) {
                this._minDistance = t, null != t && null != this._maxDistance && t > this._maxDistance && (this._maxDistance = t)
            },
            getMaxDistance: function() {
                return this._maxDistance
            },
            setMaxDistance: function(t) {
                this._maxDistance = t, null != this._minDistance && null != t && t < this._minDistance && (this._minDistance = t)
            },
            getFixedDistance: function() {
                return this._minDistance == this._maxDistance ? this._minDistance : null
            },
            setFixedDistance: function(t) {
                this._minDistance = this._maxDistance = t
            },
            _handleMouseEvent: function(t, e, i, n) {
                function r(t, e) {
                    var r = i,
                        s = o ? c._point : c._downPoint || r;
                    if (o) {
                        if (c._moveCount && r.equals(s)) return !1;
                        if (s && (null != t || null != e)) {
                            var a = r.subtract(s),
                                h = a.getLength();
                            if (h < (t || 0)) return !1;
                            e && (r = s.add(a.normalize(Math.min(h, e))))
                        }
                        c._moveCount++
                    }
                    return c._point = r, c._lastPoint = s || r, n.down && (c._moveCount = -1, c._downPoint = r, c._downCount++), !0
                }

                function s() {
                    a && (l = c.emit(t, new J(c, t, e)) || l)
                }
                paper = this._scope, n.drag && !this.responds(t) && (t = "mousemove");
                var o = n.move || n.drag,
                    a = this.responds(t),
                    h = this.minDistance,
                    u = this.maxDistance,
                    l = !1,
                    c = this;
                if (n.down) r(), s();
                else if (n.up) r(null, u), s();
                else if (a)
                    for (; r(h, u);) s();
                return l
            }
        }),
        K = {
            request: function(e) {
                var i = new t.XMLHttpRequest;
                return i.open((e.method || "get").toUpperCase(), e.url, r.pick(e.async, !0)), e.mimeType && i.overrideMimeType(e.mimeType), i.onload = function() {
                    var t = i.status;
                    0 === t || 200 === t ? e.onLoad && e.onLoad.call(i, i.responseText) : i.onerror()
                }, i.onerror = function() {
                    var t = i.status,
                        n = 'Could not load "' + e.url + '" (Status: ' + t + ")";
                    if (!e.onError) throw new Error(n);
                    e.onError(n, t)
                }, i.send(null)
            }
        },
        tt = {
            canvases: [],
            getCanvas: function(t, e) {
                if (!i) return null;
                var r, s = !0;
                "object" == typeof t && (e = t.height, t = t.width), this.canvases.length ? r = this.canvases.pop() : (r = n.createElement("canvas"), s = !1);
                var o = r.getContext("2d");
                if (!o) throw new Error("Canvas " + r + " is unable to provide a 2D context.");
                return r.width === t && r.height === e ? s && o.clearRect(0, 0, t + 1, e + 1) : (r.width = t, r.height = e), o.save(), r
            },
            getContext: function(t, e) {
                var i = this.getCanvas(t, e);
                return i ? i.getContext("2d") : null
            },
            release: function(t) {
                var e = t && t.canvas ? t.canvas : t;
                e && e.getContext && (e.getContext("2d").restore(), this.canvases.push(e))
            }
        },
        et = new function() {
            function t(t, e, i) {
                return .2989 * t + .587 * e + .114 * i
            }

            function e(e, i, n, r) {
                var s = r - t(e, i, n);
                f = e + s, g = i + s, p = n + s;
                var r = t(f, g, p),
                    o = v(f, g, p),
                    a = _(f, g, p);
                if (o < 0) {
                    var h = r - o;
                    f = r + (f - r) * r / h, g = r + (g - r) * r / h, p = r + (p - r) * r / h
                }
                if (a > 255) {
                    var u = 255 - r,
                        l = a - r;
                    f = r + (f - r) * u / l, g = r + (g - r) * u / l, p = r + (p - r) * u / l
                }
            }

            function i(t, e, i) {
                return _(t, e, i) - v(t, e, i)
            }

            function n(t, e, i, n) {
                var r, s = [t, e, i],
                    o = _(t, e, i),
                    a = v(t, e, i);
                a = a === t ? 0 : a === e ? 1 : 2, o = o === t ? 0 : o === e ? 1 : 2, r = 0 === v(a, o) ? 1 === _(a, o) ? 2 : 1 : 0, s[o] > s[a] ? (s[r] = (s[r] - s[a]) * n / (s[o] - s[a]), s[o] = n) : s[r] = s[o] = 0, s[a] = 0, f = s[0], g = s[1], p = s[2]
            }
            var s, o, a, h, u, l, c, d, f, g, p, v = Math.min,
                _ = Math.max,
                m = Math.abs,
                y = {
                    multiply: function() {
                        f = u * s / 255, g = l * o / 255, p = c * a / 255
                    },
                    screen: function() {
                        f = u + s - u * s / 255, g = l + o - l * o / 255, p = c + a - c * a / 255
                    },
                    overlay: function() {
                        f = u < 128 ? 2 * u * s / 255 : 255 - 2 * (255 - u) * (255 - s) / 255, g = l < 128 ? 2 * l * o / 255 : 255 - 2 * (255 - l) * (255 - o) / 255, p = c < 128 ? 2 * c * a / 255 : 255 - 2 * (255 - c) * (255 - a) / 255
                    },
                    "soft-light": function() {
                        var t = s * u / 255;
                        f = t + u * (255 - (255 - u) * (255 - s) / 255 - t) / 255, t = o * l / 255, g = t + l * (255 - (255 - l) * (255 - o) / 255 - t) / 255, t = a * c / 255, p = t + c * (255 - (255 - c) * (255 - a) / 255 - t) / 255
                    },
                    "hard-light": function() {
                        f = s < 128 ? 2 * s * u / 255 : 255 - 2 * (255 - s) * (255 - u) / 255, g = o < 128 ? 2 * o * l / 255 : 255 - 2 * (255 - o) * (255 - l) / 255, p = a < 128 ? 2 * a * c / 255 : 255 - 2 * (255 - a) * (255 - c) / 255
                    },
                    "color-dodge": function() {
                        f = 0 === u ? 0 : 255 === s ? 255 : v(255, 255 * u / (255 - s)), g = 0 === l ? 0 : 255 === o ? 255 : v(255, 255 * l / (255 - o)), p = 0 === c ? 0 : 255 === a ? 255 : v(255, 255 * c / (255 - a))
                    },
                    "color-burn": function() {
                        f = 255 === u ? 255 : 0 === s ? 0 : _(0, 255 - 255 * (255 - u) / s), g = 255 === l ? 255 : 0 === o ? 0 : _(0, 255 - 255 * (255 - l) / o), p = 255 === c ? 255 : 0 === a ? 0 : _(0, 255 - 255 * (255 - c) / a)
                    },
                    darken: function() {
                        f = u < s ? u : s, g = l < o ? l : o, p = c < a ? c : a
                    },
                    lighten: function() {
                        f = u > s ? u : s, g = l > o ? l : o, p = c > a ? c : a
                    },
                    difference: function() {
                        f = u - s, f < 0 && (f = -f), g = l - o, g < 0 && (g = -g), (p = c - a) < 0 && (p = -p)
                    },
                    exclusion: function() {
                        f = u + s * (255 - u - u) / 255, g = l + o * (255 - l - l) / 255, p = c + a * (255 - c - c) / 255
                    },
                    hue: function() {
                        n(s, o, a, i(u, l, c)), e(f, g, p, t(u, l, c))
                    },
                    saturation: function() {
                        n(u, l, c, i(s, o, a)), e(f, g, p, t(u, l, c))
                    },
                    luminosity: function() {
                        e(u, l, c, t(s, o, a))
                    },
                    color: function() {
                        e(s, o, a, t(u, l, c))
                    },
                    add: function() {
                        f = v(u + s, 255), g = v(l + o, 255), p = v(c + a, 255)
                    },
                    subtract: function() {
                        f = _(u - s, 0), g = _(l - o, 0), p = _(c - a, 0)
                    },
                    average: function() {
                        f = (u + s) / 2, g = (l + o) / 2, p = (c + a) / 2
                    },
                    negation: function() {
                        f = 255 - m(255 - s - u), g = 255 - m(255 - o - l), p = 255 - m(255 - a - c)
                    }
                },
                w = this.nativeModes = r.each(["source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "lighter", "darker", "copy", "xor"], function(t) {
                    this[t] = !0
                }, {}),
                x = tt.getContext(1, 1);
            x && (r.each(y, function(t, e) {
                var i = "darken" === e,
                    n = !1;
                x.save();
                try {
                    x.fillStyle = i ? "#300" : "#a00", x.fillRect(0, 0, 1, 1), x.globalCompositeOperation = e, x.globalCompositeOperation === e && (x.fillStyle = i ? "#a00" : "#300", x.fillRect(0, 0, 1, 1), n = x.getImageData(0, 0, 1, 1).data[0] !== i ? 170 : 51)
                } catch (t) {}
                x.restore(), w[e] = n
            }), tt.release(x)), this.process = function(t, e, i, n, r) {
                var v = e.canvas,
                    _ = "normal" === t;
                if (_ || w[t]) i.save(), i.setTransform(1, 0, 0, 1, 0, 0), i.globalAlpha = n, _ || (i.globalCompositeOperation = t), i.drawImage(v, r.x, r.y), i.restore();
                else {
                    var m = y[t];
                    if (!m) return;
                    for (var x = i.getImageData(r.x, r.y, v.width, v.height), b = x.data, S = e.getImageData(0, 0, v.width, v.height).data, C = 0, T = b.length; C < T; C += 4) {
                        s = S[C], u = b[C], o = S[C + 1], l = b[C + 1], a = S[C + 2], c = b[C + 2], h = S[C + 3], d = b[C + 3], m();
                        var E = h * n / 255,
                            z = 1 - E;
                        b[C] = E * f + z * u, b[C + 1] = E * g + z * l, b[C + 2] = E * p + z * c, b[C + 3] = h * n + z * d
                    }
                    i.putImageData(x, r.x, r.y)
                }
            }
        },
        it = new function() {
            function t(t, e, s) {
                return i(n.createElementNS(r, t), e, s)
            }

            function e(t, e) {
                var i = a[e],
                    n = i ? t.getAttributeNS(i, e) : t.getAttribute(e);
                return "null" === n ? null : n
            }

            function i(t, e, i) {
                for (var n in e) {
                    var r = e[n],
                        s = a[n];
                    "number" == typeof r && i && (r = i.number(r)), s ? t.setAttributeNS(s, n, r) : t.setAttribute(n, r)
                }
                return t
            }
            var r = "http://www.w3.org/2000/svg",
                s = "http://www.w3.org/2000/xmlns",
                o = "http://www.w3.org/1999/xlink",
                a = {
                    href: o,
                    xlink: s,
                    xmlns: s + "/",
                    "xmlns:xlink": s + "/"
                };
            return {
                svg: r,
                xmlns: s,
                xlink: o,
                create: t,
                get: e,
                set: i
            }
        },
        nt = r.each({
            fillColor: ["fill", "color"],
            fillRule: ["fill-rule", "string"],
            strokeColor: ["stroke", "color"],
            strokeWidth: ["stroke-width", "number"],
            strokeCap: ["stroke-linecap", "string"],
            strokeJoin: ["stroke-linejoin", "string"],
            strokeScaling: ["vector-effect", "lookup", {
                true: "none",
                false: "non-scaling-stroke"
            }, function(t, e) {
                return !e && (t instanceof M || t instanceof S || t instanceof D)
            }],
            miterLimit: ["stroke-miterlimit", "number"],
            dashArray: ["stroke-dasharray", "array"],
            dashOffset: ["stroke-dashoffset", "number"],
            fontFamily: ["font-family", "string"],
            fontWeight: ["font-weight", "string"],
            fontSize: ["font-size", "number"],
            justification: ["text-anchor", "lookup", {
                left: "start",
                center: "middle",
                right: "end"
            }],
            opacity: ["opacity", "number"],
            blendMode: ["mix-blend-mode", "style"]
        }, function(t, e) {
            var i = r.capitalize(e),
                n = t[2];
            this[e] = {
                type: t[1],
                property: e,
                attribute: t[0],
                toSVG: n,
                fromSVG: n && r.each(n, function(t, e) {
                    this[t] = e
                }, {}),
                exportFilter: t[3],
                get: "get" + i,
                set: "set" + i
            }
        }, {});
    return new function() {
        function e(t, e, i) {
            var n = new r,
                s = t.getTranslation();
            if (e) {
                t = t._shiftless();
                var o = t._inverseTransform(s);
                n[i ? "cx" : "x"] = o.x, n[i ? "cy" : "y"] = o.y, s = null
            }
            if (!t.isIdentity()) {
                var a = t.decompose();
                if (a) {
                    var h = [],
                        l = a.rotation,
                        c = a.scaling,
                        d = a.skewing;
                    s && !s.isZero() && h.push("translate(" + C.point(s) + ")"), l && h.push("rotate(" + C.number(l) + ")"), u.isZero(c.x - 1) && u.isZero(c.y - 1) || h.push("scale(" + C.point(c) + ")"), d.x && h.push("skewX(" + C.number(d.x) + ")"), d.y && h.push("skewY(" + C.number(d.y) + ")"), n.transform = h.join(" ")
                } else n.transform = "matrix(" + t.getValues().join(",") + ")"
            }
            return n
        }

        function i(t, i) {
            for (var n = e(t._matrix), r = t._children, s = it.create("g", n, C), o = 0, a = r.length; o < a; o++) {
                var h = r[o],
                    u = b(h, i);
                if (u)
                    if (h.isClipMask()) {
                        var l = it.create("clipPath");
                        l.appendChild(u), m(h, l, "clip"), it.set(s, {
                            "clip-path": "url(#" + l.id + ")"
                        })
                    } else s.appendChild(u)
            }
            return s
        }

        function n(t, i) {
            var n = e(t._matrix, !0),
                r = t.getSize(),
                s = t.getImage();
            return n.x -= r.width / 2, n.y -= r.height / 2, n.width = r.width, n.height = r.height, n.href = 0 == i.embedImages && s && s.src || t.toDataURL(), it.create("image", n, C)
        }

        function s(t, i) {
            var n = i.matchShapes;
            if (n) {
                var r = t.toShape(!1);
                if (r) return o(r)
            }
            var s, a = t._segments,
                h = a.length,
                u = e(t._matrix);
            if (n && h >= 2 && !t.hasHandles())
                if (h > 2) {
                    s = t._closed ? "polygon" : "polyline";
                    for (var l = [], c = 0; c < h; c++) l.push(C.point(a[c]._point));
                    u.points = l.join(" ")
                } else {
                    s = "line";
                    var d = a[0]._point,
                        f = a[1]._point;
                    u.set({
                        x1: d.x,
                        y1: d.y,
                        x2: f.x,
                        y2: f.y
                    })
                }
            else s = "path", u.d = t.getPathData(null, i.precision);
            return it.create(s, u, C)
        }

        function o(t) {
            var i = t._type,
                n = t._radius,
                r = e(t._matrix, !0, "rectangle" !== i);
            if ("rectangle" === i) {
                i = "rect";
                var s = t._size,
                    o = s.width,
                    a = s.height;
                r.x -= o / 2, r.y -= a / 2, r.width = o, r.height = a, n.isZero() && (n = null)
            }
            return n && ("circle" === i ? r.r = n : (r.rx = n.width, r.ry = n.height)), it.create(i, r, C)
        }

        function a(t, i) {
            var n = e(t._matrix),
                r = t.getPathData(null, i.precision);
            return r && (n.d = r), it.create("path", n, C)
        }

        function c(t, i) {
            var n = e(t._matrix, !0),
                r = t._definition,
                s = v(r, "symbol"),
                o = r._item,
                a = o.getBounds();
            return s || (s = it.create("symbol", {
                viewBox: C.rectangle(a)
            }), s.appendChild(b(o, i)), m(r, s, "symbol")), n.href = "#" + s.id, n.x += a.x, n.y += a.y, n.width = a.width, n.height = a.height, n.overflow = "visible", it.create("use", n, C)
        }

        function d(t) {
            var e = v(t, "color");
            if (!e) {
                var i, n = t.getGradient(),
                    r = n._radial,
                    s = t.getOrigin(),
                    o = t.getDestination();
                if (r) {
                    i = {
                        cx: s.x,
                        cy: s.y,
                        r: s.getDistance(o)
                    };
                    var a = t.getHighlight();
                    a && (i.fx = a.x, i.fy = a.y)
                } else i = {
                    x1: s.x,
                    y1: s.y,
                    x2: o.x,
                    y2: o.y
                };
                i.gradientUnits = "userSpaceOnUse", e = it.create((r ? "radial" : "linear") + "Gradient", i, C);
                for (var h = n._stops, u = 0, l = h.length; u < l; u++) {
                    var c = h[u],
                        d = c._color,
                        f = d.getAlpha(),
                        g = c._offset;
                    i = {
                        offset: null == g ? u / (l - 1) : g
                    }, d && (i["stop-color"] = d.toCSS(!0)), f < 1 && (i["stop-opacity"] = f), e.appendChild(it.create("stop", i, C))
                }
                m(t, e, "color")
            }
            return "url(#" + e.id + ")"
        }

        function f(t) {
            var i = it.create("text", e(t._matrix, !0), C);
            return i.textContent = t._content, i
        }

        function g(t, e, i) {
            var n = {},
                s = !i && t.getParent(),
                o = [];
            return null != t._name && (n.id = t._name), r.each(nt, function(e) {
                var i = e.get,
                    a = e.type,
                    h = t[i]();
                if (e.exportFilter ? e.exportFilter(t, h) : !s || !r.equals(s[i](), h)) {
                    if ("color" === a && null != h) {
                        var u = h.getAlpha();
                        u < 1 && (n[e.attribute + "-opacity"] = u)
                    }
                    "style" === a ? o.push(e.attribute + ": " + h) : n[e.attribute] = null == h ? "none" : "color" === a ? h.gradient ? d(h, t) : h.toCSS(!0) : "array" === a ? h.join(",") : "lookup" === a ? e.toSVG[h] : h
                }
            }), o.length && (n.style = o.join(";")), 1 === n.opacity && delete n.opacity, t._visible || (n.visibility = "hidden"), it.set(e, n, C)
        }

        function v(t, e) {
            return T || (T = {
                ids: {},
                svgs: {}
            }), t && T.svgs[e + "-" + (t._id || t.__id || (t.__id = l.get("svg")))]
        }

        function m(t, e, i) {
            T || v();
            var n = T.ids[i] = (T.ids[i] || 0) + 1;
            e.id = i + "-" + n, T.svgs[i + "-" + (t._id || t.__id)] = e
        }

        function x(e, i) {
            var n = e,
                r = null;
            if (T) {
                n = "svg" === e.nodeName.toLowerCase() && e;
                for (var s in T.svgs) r || (n || (n = it.create("svg"), n.appendChild(e)), r = n.insertBefore(it.create("defs"), n.firstChild)), r.appendChild(T.svgs[s]);
                T = null
            }
            return i.asString ? (new t.XMLSerializer).serializeToString(n) : n
        }

        function b(t, e, i) {
            var n = E[t._class],
                r = n && n(t, e);
            if (r) {
                var s = e.onExport;
                s && (r = s(t, r, e) || r);
                var o = JSON.stringify(t._data);
                o && "{}" !== o && "null" !== o && r.setAttribute("data-paper-data", o)
            }
            return r && g(t, r, i)
        }

        function S(t) {
            return t || (t = {}), C = new h(t.precision), t
        }
        var C, T, E = {
            Group: i,
            Layer: i,
            Raster: n,
            Path: s,
            Shape: o,
            CompoundPath: a,
            SymbolItem: c,
            PointText: f
        };
        w.inject({
            exportSVG: function(t) {
                return t = S(t), x(b(this, t, !0), t)
            }
        }), y.inject({
            exportSVG: function(t) {
                t = S(t);
                var i = this._children,
                    n = this.getView(),
                    s = r.pick(t.bounds, "view"),
                    o = t.matrix || "view" === s && n._matrix,
                    a = o && _.read([o]),
                    h = "view" === s ? new p([0, 0], n.getViewSize()) : "content" === s ? w._getBounds(i, a, {
                        stroke: !0
                    }).rect : p.read([s], 0, {
                        readNull: !0
                    }),
                    u = {
                        version: "1.1",
                        xmlns: it.svg,
                        "xmlns:xlink": it.xlink
                    };
                h && (u.width = h.width, u.height = h.height, (h.x || h.y) && (u.viewBox = C.rectangle(h)));
                var l = it.create("svg", u, C),
                    c = l;
                a && !a.isIdentity() && (c = l.appendChild(it.create("g", e(a), C)));
                for (var d = 0, f = i.length; d < f; d++) c.appendChild(b(i[d], t, !0));
                return x(l, t)
            }
        })
    }, new function() {
        function s(t, e, i, n, r) {
            var s = it.get(t, e),
                o = null == s ? n ? null : i ? "" : 0 : i ? s : parseFloat(s);
            return /%\s*$/.test(s) ? o / 100 * (r ? 1 : A[/x|^width/.test(e) ? "width" : "height"]) : o
        }

        function o(t, e, i, n, r) {
            return e = s(t, e || "x", !1, n, r), i = s(t, i || "y", !1, n, r), !n || null != e && null != i ? new c(e, i) : null
        }

        function a(t, e, i, n, r) {
            return e = s(t, e || "width", !1, n, r), i = s(t, i || "height", !1, n, r), !n || null != e && null != i ? new f(e, i) : null
        }

        function h(t, e, i) {
            return "none" === t ? null : "number" === e ? parseFloat(t) : "array" === e ? t ? t.split(/[\s,]+/g).map(parseFloat) : [] : "color" === e ? z(t) || t : "lookup" === e ? i[t] : t
        }

        function u(t, e, i, n) {
            var r = t.childNodes,
                s = "clippath" === e,
                o = "defs" === e,
                a = new x,
                h = a._project,
                u = h._currentStyle,
                l = [];
            if (s || o || (a = T(a, t, n), h._currentStyle = a._style.clone()), n)
                for (var c = t.querySelectorAll("defs"), d = 0, f = c.length; d < f; d++) k(c[d], i, !1);
            for (var d = 0, f = r.length; d < f; d++) {
                var g, p = r[d];
                1 !== p.nodeType || /^defs$/i.test(p.nodeName) || !(g = k(p, i, !1)) || g instanceof E || l.push(g)
            }
            return a.addChildren(l), s && (a = T(a.reduce(), t, n)), h._currentStyle = u, (s || o) && (a.remove(), a = null), a
        }

        function l(t, e) {
            for (var i = t.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), n = [], r = 0, s = i.length; r < s; r += 2) n.push(new c(parseFloat(i[r]), parseFloat(i[r + 1])));
            var o = new O(n);
            return "polygon" === e && o.closePath(), o
        }

        function d(t) {
            return M.create(t.getAttribute("d"))
        }

        function g(t, e) {
            var i, n = (s(t, "href", !0) || "").substring(1),
                r = "radialgradient" === e;
            if (n) i = P[n].getGradient(), i._radial ^ r && (i = i.clone(), i._radial = r);
            else {
                for (var a = t.childNodes, h = [], u = 0, l = a.length; u < l; u++) {
                    var c = a[u];
                    1 === c.nodeType && h.push(T(new q, c))
                }
                i = new j(h, r)
            }
            var d, f, g, p = "userSpaceOnUse" !== s(t, "gradientUnits", !0);
            return r ? (d = o(t, "cx", "cy", !1, p), f = d.add(s(t, "r", !1, !1, p), 0), g = o(t, "fx", "fy", !0, p)) : (d = o(t, "x1", "y1", !1, p), f = o(t, "x2", "y2", !1, p)), T(new B(i, d, f, g), t)._scaleToBounds = p, null
        }

        function v(t, e, i, n) {
            if (t.transform) {
                for (var r = (n.getAttribute(i) || "").split(/\)\s*/g), s = new _, o = 0, a = r.length; o < a; o++) {
                    var h = r[o];
                    if (!h) break;
                    for (var u = h.split(/\(\s*/), l = u[0], c = u[1].split(/[\s,]+/g), d = 0, f = c.length; d < f; d++) c[d] = parseFloat(c[d]);
                    switch (l) {
                        case "matrix":
                            s.append(new _(c[0], c[1], c[2], c[3], c[4], c[5]));
                            break;
                        case "rotate":
                            s.rotate(c[0], c[1], c[2]);
                            break;
                        case "translate":
                            s.translate(c[0], c[1]);
                            break;
                        case "scale":
                            s.scale(c);
                            break;
                        case "skewX":
                            s.skew(c[0], 0);
                            break;
                        case "skewY":
                            s.skew(0, c[0])
                    }
                }
                t.transform(s)
            }
        }

        function m(t, e, i) {
            var n = "fill-opacity" === i ? "getFillColor" : "getStrokeColor",
                r = t[n] && t[n]();
            r && r.setAlpha(parseFloat(e))
        }

        function b(t, i, n) {
            var s = t.attributes[i],
                o = s && s.value;
            if (!o) {
                var a = r.camelize(i);
                o = t.style[a], o || n.node[a] === n.parent[a] || (o = n.node[a])
            }
            return o ? "none" === o ? null : o : e
        }

        function T(t, i, n) {
            if (i.style) {
                var s = i.parentNode,
                    o = {
                        node: W.getStyles(i) || {},
                        parent: !n && !/^defs$/i.test(s.tagName) && W.getStyles(s) || {}
                    };
                r.each(N, function(n, r) {
                    var s = b(i, r, o);
                    t = s !== e && n(t, s, r, i, o) || t
                })
            }
            return t
        }

        function z(t) {
            var e = t && t.match(/\((?:["'#]*)([^"')]+)/),
                n = e && e[1],
                r = n && P[i ? n.replace(i.location.href.split("#")[0] + "#", "") : n];
            return r && r._scaleToBounds && (r = r.clone(), r._scaleToBounds = !0), r
        }

        function k(t, e, i) {
            var s, o, h, u = t.nodeName.toLowerCase(),
                l = "#document" !== u,
                c = n.body;
            i && l && (A = paper.getView().getSize(), A = a(t, null, null, !0) || A, s = it.create("svg", {
                style: "stroke-width: 1px; stroke-miterlimit: 10"
            }), o = t.parentNode, h = t.nextSibling, s.appendChild(t), c.appendChild(s));
            var d = paper.settings,
                f = d.applyMatrix,
                g = d.insertItems;
            d.applyMatrix = !1, d.insertItems = !1;
            var p = L[u],
                v = p && p(t, u, e, i) || null;
            if (d.insertItems = g, d.applyMatrix = f, v) {
                !l || v instanceof x || (v = T(v, t, i));
                var _ = e.onImport,
                    m = l && t.getAttribute("data-paper-data");
                _ && (v = _(t, v, e) || v), e.expandShapes && v instanceof S && (v.remove(), v = v.toPath()), m && (v._data = JSON.parse(m))
            }
            return s && (c.removeChild(s), o && (h ? o.insertBefore(t, h) : o.appendChild(t))), i && (P = {}, v && r.pick(e.applyMatrix, f) && v.matrix.apply(!0, !0)), v
        }

        function I(i, r, s) {
            function o(n) {
                try {
                    var o = "object" == typeof n ? n : (new t.DOMParser).parseFromString(n, "image/svg+xml");
                    if (!o.nodeName) throw o = null, new Error("Unsupported SVG source: " + i);
                    paper = h, u = k(o, r, !0), r && !1 === r.insert || s._insertItem(e, u);
                    var l = r.onLoad;
                    l && l(u, n)
                } catch (t) {
                    a(t)
                }
            }

            function a(t, e) {
                var i = r.onError;
                if (!i) throw new Error(t);
                i(t, e)
            }
            if (!i) return null;
            r = "function" == typeof r ? {
                onLoad: r
            } : r || {};
            var h = paper,
                u = null;
            if ("string" != typeof i || /^.*</.test(i)) {
                if ("undefined" != typeof File && i instanceof File) {
                    var l = new FileReader;
                    return l.onload = function() {
                        o(l.result)
                    }, l.onerror = function() {
                        a(l.error)
                    }, l.readAsText(i)
                }
                o(i)
            } else {
                var c = n.getElementById(i);
                c ? o(c) : K.request({
                    url: i,
                    async: !0,
                    onLoad: o,
                    onError: a
                })
            }
            return u
        }
        var A, P = {},
            L = {
                "#document": function(t, e, i, n) {
                    for (var r = t.childNodes, s = 0, o = r.length; s < o; s++) {
                        var a = r[s];
                        if (1 === a.nodeType) return k(a, i, n)
                    }
                },
                g: u,
                svg: u,
                clippath: u,
                polygon: l,
                polyline: l,
                path: d,
                lineargradient: g,
                radialgradient: g,
                image: function(t) {
                    var e = new C(s(t, "href", !0));
                    return e.on("load", function() {
                        var e = a(t);
                        this.setSize(e);
                        var i = this._matrix._transformPoint(o(t).add(e.divide(2)));
                        this.translate(i)
                    }), e
                },
                symbol: function(t, e, i, n) {
                    return new E(u(t, e, i, n), !0)
                },
                defs: u,
                use: function(t) {
                    var e = (s(t, "href", !0) || "").substring(1),
                        i = P[e],
                        n = o(t);
                    return i ? i instanceof E ? i.place(n) : i.clone().translate(n) : null
                },
                circle: function(t) {
                    return new S.Circle(o(t, "cx", "cy"), s(t, "r"))
                },
                ellipse: function(t) {
                    return new S.Ellipse({
                        center: o(t, "cx", "cy"),
                        radius: a(t, "rx", "ry")
                    })
                },
                rect: function(t) {
                    return new S.Rectangle(new p(o(t), a(t)), a(t, "rx", "ry"))
                },
                line: function(t) {
                    return new O.Line(o(t, "x1", "y1"), o(t, "x2", "y2"))
                },
                text: function(t) {
                    var e = new R(o(t).add(o(t, "dx", "dy")));
                    return e.setContent(t.textContent.trim() || ""), e
                }
            },
            N = r.set(r.each(nt, function(t) {
                this[t.attribute] = function(e, i) {
                    if (e[t.set] && (e[t.set](h(i, t.type, t.fromSVG)), "color" === t.type)) {
                        var n = e[t.get]();
                        if (n && n._scaleToBounds) {
                            var r = e.getBounds();
                            n.transform((new _).translate(r.getPoint()).scale(r.getSize()))
                        }
                    }
                }
            }, {}), {
                id: function(t, e) {
                    P[e] = t, t.setName && t.setName(e)
                },
                "clip-path": function(t, e) {
                    var i = z(e);
                    if (i) {
                        if (i = i.clone(), i.setClipMask(!0), !(t instanceof x)) return new x(i, t);
                        t.insertChild(0, i)
                    }
                },
                gradientTransform: v,
                transform: v,
                "fill-opacity": m,
                "stroke-opacity": m,
                visibility: function(t, e) {
                    t.setVisible && t.setVisible("visible" === e)
                },
                display: function(t, e) {
                    t.setVisible && t.setVisible(null !== e)
                },
                "stop-color": function(t, e) {
                    t.setColor && t.setColor(e)
                },
                "stop-opacity": function(t, e) {
                    t._color && t._color.setAlpha(parseFloat(e))
                },
                offset: function(t, e) {
                    if (t.setOffset) {
                        var i = e.match(/(.*)%$/);
                        t.setOffset(i ? i[1] / 100 : parseFloat(e))
                    }
                },
                viewBox: function(t, e, i, n, r) {
                    var s, o, u = new p(h(e, "array")),
                        l = a(n, null, null, !0);
                    if (t instanceof x) {
                        var c = l ? l.divide(u.getSize()) : 1,
                            o = (new _).scale(c).translate(u.getPoint().negate());
                        s = t
                    } else t instanceof E && (l && u.setSize(l), s = t._item);
                    if (s) {
                        if ("visible" !== b(n, "overflow", r)) {
                            var d = new S.Rectangle(u);
                            d.setClipMask(!0), s.addChild(d)
                        }
                        o && s.transform(o)
                    }
                }
            });
        w.inject({
            importSVG: function(t, e) {
                return I(t, e, this)
            }
        }), y.inject({
            importSVG: function(t, e) {
                return this.activate(), I(t, e, this)
            }
        })
    }, r.exports.PaperScript = function() {
        function e(t, e) {
            return (p.acorn || v).parse(t, e)
        }

        function s(t, e, i) {
            var n = y[e];
            if (t && t[n]) {
                var r = t[n](i);
                return "!=" === e ? !r : r
            }
            switch (e) {
                case "+":
                    return t + i;
                case "-":
                    return t - i;
                case "*":
                    return t * i;
                case "/":
                    return t / i;
                case "%":
                    return t % i;
                case "==":
                    return t == i;
                case "!=":
                    return t != i
            }
        }

        function a(t, e) {
            var i = w[t];
            if (e && e[i]) return e[i]();
            switch (t) {
                case "+":
                    return +e;
                case "-":
                    return -e
            }
        }

        function h(r, s) {
            function o(t) {
                for (var e = 0, i = d.length; e < i; e++) {
                    var n = d[e];
                    if (n[0] >= t) break;
                    t += n[1]
                }
                return t
            }

            function a(t) {
                return r.substring(o(t.range[0]), o(t.range[1]))
            }

            function h(t, e) {
                return r.substring(o(t.range[1]), o(e.range[0]))
            }

            function u(t, e) {
                for (var i = o(t.range[0]), n = o(t.range[1]), s = 0, a = d.length - 1; a >= 0; a--)
                    if (i > d[a][0]) {
                        s = a + 1;
                        break
                    }
                d.splice(s, 0, [i, e.length - n + i]), r = r.substring(0, i) + e + r.substring(n)
            }

            function l(t, e) {
                if (t) {
                    for (var i in t)
                        if ("range" !== i && "loc" !== i) {
                            var n = t[i];
                            if (Array.isArray(n))
                                for (var r = 0, s = n.length; r < s; r++) l(n[r], t);
                            else n && "object" == typeof n && l(n, t)
                        }
                    switch (t.type) {
                        case "UnaryExpression":
                            if (t.operator in w && "Literal" !== t.argument.type) {
                                var o = a(t.argument);
                                u(t, '$__("' + t.operator + '", ' + o + ")")
                            }
                            break;
                        case "BinaryExpression":
                            if (t.operator in y && "Literal" !== t.left.type) {
                                var c = a(t.left),
                                    d = a(t.right),
                                    f = h(t.left, t.right),
                                    g = t.operator;
                                u(t, "__$__(" + c + "," + f.replace(new RegExp("\\" + g), '"' + g + '"') + ", " + d + ")")
                            }
                            break;
                        case "UpdateExpression":
                        case "AssignmentExpression":
                            var p = e && e.type;
                            if (!("ForStatement" === p || "BinaryExpression" === p && /^[=!<>]/.test(e.operator) || "MemberExpression" === p && e.computed))
                                if ("UpdateExpression" === t.type) {
                                    var o = a(t.argument),
                                        v = "__$__(" + o + ', "' + t.operator[0] + '", 1)',
                                        _ = o + " = " + v;
                                    t.prefix || "AssignmentExpression" !== p && "VariableDeclarator" !== p || (a(e.left || e.id) === o && (_ = v), _ = o + "; " + _), u(t, _)
                                } else if (/^.=$/.test(t.operator) && "Literal" !== t.left.type) {
                                var c = a(t.left),
                                    d = a(t.right),
                                    v = c + " = __$__(" + c + ', "' + t.operator[0] + '", ' + d + ")";
                                u(t, /^\(.*\)$/.test(a(t)) ? "(" + v + ")" : v)
                            }
                    }
                }
            }
            if (!r) return "";
            s = s || {};
            var c, d = [],
                f = s.url || "",
                g = paper.agent,
                p = g.versionNumber,
                v = !1,
                _ = s.sourceMaps,
                m = s.source || r,
                x = /\r\n|\n|\r/gm,
                b = s.offset || 0;
            if (_ && (g.chrome && p >= 30 || g.webkit && p >= 537.76 || g.firefox && p >= 23 || g.node)) {
                if (g.node) b -= 2;
                else if (i && f && !i.location.href.indexOf(f)) {
                    var S = n.getElementsByTagName("html")[0].innerHTML;
                    b = S.substr(0, S.indexOf(r) + 1).match(x).length + 1
                }
                v = b > 0 && !(g.chrome && p >= 36 || g.safari && p >= 600 || g.firefox && p >= 40 || g.node);
                var C = ["AA" + function(t) {
                    var e = "";
                    for (t = (Math.abs(t) << 1) + (t < 0 ? 1 : 0); t || !e;) {
                        var i = 31 & t;
                        t >>= 5, t && (i |= 32), e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [i]
                    }
                    return e
                }(v ? 0 : b) + "A"];
                C.length = (r.match(x) || []).length + 1 + (v ? b : 0), c = {
                    version: 3,
                    file: f,
                    names: [],
                    mappings: C.join(";AACA"),
                    sourceRoot: "",
                    sources: [f],
                    sourcesContent: [m]
                }
            }
            return l(e(r, {
                ranges: !0,
                preserveParens: !0
            })), c && (v && (r = new Array(b + 1).join("\n") + r), /^(inline|both)$/.test(_) && (r += "\n//# sourceMappingURL=data:application/json;base64," + t.btoa(unescape(encodeURIComponent(JSON.stringify(c))))), r += "\n//# sourceURL=" + (f || "paperscript")), {
                url: f,
                source: m,
                code: r,
                map: c
            }
        }

        function u(t, e, i) {
            function o(e, i) {
                for (var n in e) !i && /^_/.test(n) || !new RegExp("([\\b\\s\\W]|^)" + n.replace(/\$/g, "\\$") + "\\b").test(t) || (p.push(n), v.push(e[n]))
            }
            paper = e;
            var u, l = e.getView(),
                d = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(t) && !/\bnew\s+Tool\b/.test(t) ? new Q : null,
                f = d ? d._events : [],
                g = ["onFrame", "onResize"].concat(f),
                p = [],
                v = [],
                _ = "object" == typeof t ? t : h(t, i);
            t = _.code, o({
                __$__: s,
                $__: a,
                paper: e,
                view: l,
                tool: d
            }, !0), o(e), (g = r.each(g, function(e) {
                new RegExp("\\s+" + e + "\\b").test(t) && (p.push(e), this.push(e + ": " + e))
            }, []).join(", ")) && (t += "\nreturn { " + g + " };");
            var m = paper.agent;
            if (n && (m.chrome || m.firefox && m.versionNumber < 40)) {
                var y = n.createElement("script"),
                    w = n.head || n.getElementsByTagName("head")[0];
                m.firefox && (t = "\n" + t), y.appendChild(n.createTextNode("paper._execute = function(" + p + ") {" + t + "\n}")), w.appendChild(y), u = paper._execute, delete paper._execute, w.removeChild(y)
            } else u = Function(p, t);
            var x = u.apply(e, v) || {};
            return r.each(f, function(t) {
                var e = x[t];
                e && (d[t] = e)
            }), l && (x.onResize && l.setOnResize(x.onResize), l.emit("resize", {
                size: l.size,
                delta: new c
            }), x.onFrame && l.setOnFrame(x.onFrame), l.requestUpdate()), _
        }

        function l(t) {
            if (/^text\/(?:x-|)paperscript$/.test(t.type) && "true" !== o.getAttribute(t, "ignore")) {
                var e = o.getAttribute(t, "canvas"),
                    i = n.getElementById(e),
                    r = t.src || t.getAttribute("data-src"),
                    s = o.hasAttribute(t, "async");
                if (!i) throw new Error('Unable to find canvas with id "' + e + '"');
                var a = o.get(i.getAttribute("data-paper-scope")) || (new o).setup(i);
                return i.setAttribute("data-paper-scope", a._id), r ? K.request({
                    url: r,
                    async: s,
                    mimeType: "text/plain",
                    onLoad: function(t) {
                        u(t, a, r)
                    }
                }) : u(t.innerHTML, a, t.baseURI), t.setAttribute("data-paper-ignore", "true"), a
            }
        }

        function d() {
            r.each(n && n.getElementsByTagName("script"), l)
        }

        function g(t) {
            return t ? l(t) : d()
        }
        var p = this,
            v = p.acorn;
        if (!v && "undefined" != typeof require) try {
            v = require("acorn")
        } catch (t) {}
        if (!v) {
            var _, m;
            v = _ = m = {},
                function(t, e) {
                    "object" == typeof _ && "object" == typeof m ? e(_) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.acorn || (t.acorn = {}))
                }(this, function(t) {
                    "use strict";

                    function e(t) {
                        ct = t || {};
                        for (var e in pt) Object.prototype.hasOwnProperty.call(ct, e) || (ct[e] = pt[e]);
                        gt = ct.sourceFile || null
                    }

                    function i(t, e) {
                        var i = vt(dt, t);
                        e += " (" + i.line + ":" + i.column + ")";
                        var n = new SyntaxError(e);
                        throw n.pos = t, n.loc = i, n.raisedAt = _t, n
                    }

                    function n(t) {
                        function e(t) {
                            if (1 == t.length) return i += "return str === " + JSON.stringify(t[0]) + ";";
                            i += "switch(str){";
                            for (var e = 0; e < t.length; ++e) i += "case " + JSON.stringify(t[e]) + ":";
                            i += "return true}return false;"
                        }
                        t = t.split(" ");
                        var i = "",
                            n = [];
                        t: for (var r = 0; r < t.length; ++r) {
                            for (var s = 0; s < n.length; ++s)
                                if (n[s][0].length == t[r].length) {
                                    n[s].push(t[r]);
                                    continue t
                                }
                            n.push([t[r]])
                        }
                        if (n.length > 3) {
                            n.sort(function(t, e) {
                                return e.length - t.length
                            }), i += "switch(str.length){";
                            for (var r = 0; r < n.length; ++r) {
                                var o = n[r];
                                i += "case " + o[0].length + ":", e(o)
                            }
                            i += "}"
                        } else e(t);
                        return new Function("str", i)
                    }

                    function r() {
                        this.line = Tt, this.column = _t - Et
                    }

                    function s() {
                        Tt = 1, _t = Et = 0, Ct = !0, u()
                    }

                    function o(t, e) {
                        yt = _t, ct.locations && (xt = new r), bt = t, u(), St = e, Ct = t.beforeExpr
                    }

                    function a() {
                        var t = ct.onComment && ct.locations && new r,
                            e = _t,
                            n = dt.indexOf("*/", _t += 2);
                        if (-1 === n && i(_t - 2, "Unterminated comment"), _t = n + 2, ct.locations) {
                            Ge.lastIndex = e;
                            for (var s;
                                (s = Ge.exec(dt)) && s.index < _t;) ++Tt, Et = s.index + s[0].length
                        }
                        ct.onComment && ct.onComment(!0, dt.slice(e + 2, n), e, _t, t, ct.locations && new r)
                    }

                    function h() {
                        for (var t = _t, e = ct.onComment && ct.locations && new r, i = dt.charCodeAt(_t += 2); _t < ft && 10 !== i && 13 !== i && 8232 !== i && 8233 !== i;) ++_t, i = dt.charCodeAt(_t);
                        ct.onComment && ct.onComment(!1, dt.slice(t + 2, _t), t, _t, e, ct.locations && new r)
                    }

                    function u() {
                        for (; _t < ft;) {
                            var t = dt.charCodeAt(_t);
                            if (32 === t) ++_t;
                            else if (13 === t) {
                                ++_t;
                                var e = dt.charCodeAt(_t);
                                10 === e && ++_t, ct.locations && (++Tt, Et = _t)
                            } else if (10 === t || 8232 === t || 8233 === t) ++_t, ct.locations && (++Tt, Et = _t);
                            else if (t > 8 && t < 14) ++_t;
                            else if (47 === t) {
                                var e = dt.charCodeAt(_t + 1);
                                if (42 === e) a();
                                else {
                                    if (47 !== e) break;
                                    h()
                                }
                            } else if (160 === t) ++_t;
                            else {
                                if (!(t >= 5760 && Ve.test(String.fromCharCode(t)))) break;
                                ++_t
                            }
                        }
                    }

                    function l() {
                        var t = dt.charCodeAt(_t + 1);
                        return t >= 48 && t <= 57 ? C(!0) : (++_t, o(we))
                    }

                    function c() {
                        var t = dt.charCodeAt(_t + 1);
                        return Ct ? (++_t, x()) : 61 === t ? w(Ce, 2) : w(be, 1)
                    }

                    function d() {
                        return 61 === dt.charCodeAt(_t + 1) ? w(Ce, 2) : w(Fe, 1)
                    }

                    function f(t) {
                        var e = dt.charCodeAt(_t + 1);
                        return e === t ? w(124 === t ? ze : ke, 2) : 61 === e ? w(Ce, 2) : w(124 === t ? Ie : Pe, 1)
                    }

                    function g() {
                        return 61 === dt.charCodeAt(_t + 1) ? w(Ce, 2) : w(Ae, 1)
                    }

                    function p(t) {
                        var e = dt.charCodeAt(_t + 1);
                        return e === t ? 45 == e && 62 == dt.charCodeAt(_t + 2) && Ze.test(dt.slice(kt, _t)) ? (_t += 3, h(), u(), y()) : w(Te, 2) : 61 === e ? w(Ce, 2) : w(Ne, 1)
                    }

                    function v(t) {
                        var e = dt.charCodeAt(_t + 1),
                            i = 1;
                        return e === t ? (i = 62 === t && 62 === dt.charCodeAt(_t + 2) ? 3 : 2, 61 === dt.charCodeAt(_t + i) ? w(Ce, i + 1) : w(Le, i)) : 33 == e && 60 == t && 45 == dt.charCodeAt(_t + 2) && 45 == dt.charCodeAt(_t + 3) ? (_t += 4, h(), u(), y()) : (61 === e && (i = 61 === dt.charCodeAt(_t + 2) ? 3 : 2), w(Oe, i))
                    }

                    function _(t) {
                        return 61 === dt.charCodeAt(_t + 1) ? w(Me, 61 === dt.charCodeAt(_t + 2) ? 3 : 2) : w(61 === t ? Se : Ee, 1)
                    }

                    function m(t) {
                        switch (t) {
                            case 46:
                                return l();
                            case 40:
                                return ++_t, o(pe);
                            case 41:
                                return ++_t, o(ve);
                            case 59:
                                return ++_t, o(me);
                            case 44:
                                return ++_t, o(_e);
                            case 91:
                                return ++_t, o(ce);
                            case 93:
                                return ++_t, o(de);
                            case 123:
                                return ++_t, o(fe);
                            case 125:
                                return ++_t, o(ge);
                            case 58:
                                return ++_t, o(ye);
                            case 63:
                                return ++_t, o(xe);
                            case 48:
                                var e = dt.charCodeAt(_t + 1);
                                if (120 === e || 88 === e) return S();
                            case 49:
                            case 50:
                            case 51:
                            case 52:
                            case 53:
                            case 54:
                            case 55:
                            case 56:
                            case 57:
                                return C(!1);
                            case 34:
                            case 39:
                                return T(t);
                            case 47:
                                return c(t);
                            case 37:
                            case 42:
                                return d();
                            case 124:
                            case 38:
                                return f(t);
                            case 94:
                                return g();
                            case 43:
                            case 45:
                                return p(t);
                            case 60:
                            case 62:
                                return v(t);
                            case 61:
                            case 33:
                                return _(t);
                            case 126:
                                return w(Ee, 1)
                        }
                        return !1
                    }

                    function y(t) {
                        if (t ? _t = mt + 1 : mt = _t, ct.locations && (wt = new r), t) return x();
                        if (_t >= ft) return o(Rt);
                        var e = dt.charCodeAt(_t);
                        if ($e(e) || 92 === e) return k();
                        var n = m(e);
                        if (!1 === n) {
                            var s = String.fromCharCode(e);
                            if ("\\" === s || Ye.test(s)) return k();
                            i(_t, "Unexpected character '" + s + "'")
                        }
                        return n
                    }

                    function w(t, e) {
                        var i = dt.slice(_t, _t + e);
                        _t += e, o(t, i)
                    }

                    function x() {
                        for (var t, e, n = "", r = _t;;) {
                            _t >= ft && i(r, "Unterminated regular expression");
                            var s = dt.charAt(_t);
                            if (Ze.test(s) && i(r, "Unterminated regular expression"), t) t = !1;
                            else {
                                if ("[" === s) e = !0;
                                else if ("]" === s && e) e = !1;
                                else if ("/" === s && !e) break;
                                t = "\\" === s
                            }++_t
                        }
                        var n = dt.slice(r, _t);
                        ++_t;
                        var a = z();
                        a && !/^[gmsiy]*$/.test(a) && i(r, "Invalid regexp flag");
                        try {
                            var h = new RegExp(n, a)
                        } catch (t) {
                            t instanceof SyntaxError && i(r, t.message), i(t)
                        }
                        return o(Nt, h)
                    }

                    function b(t, e) {
                        for (var i = _t, n = 0, r = 0, s = null == e ? 1 / 0 : e; r < s; ++r) {
                            var o, a = dt.charCodeAt(_t);
                            if ((o = a >= 97 ? a - 97 + 10 : a >= 65 ? a - 65 + 10 : a >= 48 && a <= 57 ? a - 48 : 1 / 0) >= t) break;
                            ++_t, n = n * t + o
                        }
                        return _t === i || null != e && _t - i !== e ? null : n
                    }

                    function S() {
                        _t += 2;
                        var t = b(16);
                        return null == t && i(mt + 2, "Expected hexadecimal number"), $e(dt.charCodeAt(_t)) && i(_t, "Identifier directly after number"), o(Lt, t)
                    }

                    function C(t) {
                        var e = _t,
                            n = !1,
                            r = 48 === dt.charCodeAt(_t);
                        t || null !== b(10) || i(e, "Invalid number"), 46 === dt.charCodeAt(_t) && (++_t, b(10), n = !0);
                        var s = dt.charCodeAt(_t);
                        69 !== s && 101 !== s || (s = dt.charCodeAt(++_t), 43 !== s && 45 !== s || ++_t, null === b(10) && i(e, "Invalid number"), n = !0), $e(dt.charCodeAt(_t)) && i(_t, "Identifier directly after number");
                        var a, h = dt.slice(e, _t);
                        return n ? a = parseFloat(h) : r && 1 !== h.length ? /[89]/.test(h) || Mt ? i(e, "Invalid number") : a = parseInt(h, 8) : a = parseInt(h, 10), o(Lt, a)
                    }

                    function T(t) {
                        _t++;
                        for (var e = "";;) {
                            _t >= ft && i(mt, "Unterminated string constant");
                            var n = dt.charCodeAt(_t);
                            if (n === t) return ++_t, o(Ft, e);
                            if (92 === n) {
                                n = dt.charCodeAt(++_t);
                                var r = /^[0-7]+/.exec(dt.slice(_t, _t + 3));
                                for (r && (r = r[0]); r && parseInt(r, 8) > 255;) r = r.slice(0, -1);
                                if ("0" === r && (r = null), ++_t, r) Mt && i(_t - 2, "Octal literal in strict mode"), e += String.fromCharCode(parseInt(r, 8)), _t += r.length - 1;
                                else switch (n) {
                                    case 110:
                                        e += "\n";
                                        break;
                                    case 114:
                                        e += "\r";
                                        break;
                                    case 120:
                                        e += String.fromCharCode(E(2));
                                        break;
                                    case 117:
                                        e += String.fromCharCode(E(4));
                                        break;
                                    case 85:
                                        e += String.fromCharCode(E(8));
                                        break;
                                    case 116:
                                        e += "\t";
                                        break;
                                    case 98:
                                        e += "\b";
                                        break;
                                    case 118:
                                        e += "\v";
                                        break;
                                    case 102:
                                        e += "\f";
                                        break;
                                    case 48:
                                        e += "\0";
                                        break;
                                    case 13:
                                        10 === dt.charCodeAt(_t) && ++_t;
                                    case 10:
                                        ct.locations && (Et = _t, ++Tt);
                                        break;
                                    default:
                                        e += String.fromCharCode(n)
                                }
                            } else 13 !== n && 10 !== n && 8232 !== n && 8233 !== n || i(mt, "Unterminated string constant"), e += String.fromCharCode(n), ++_t
                        }
                    }

                    function E(t) {
                        var e = b(16, t);
                        return null === e && i(mt, "Bad character escape sequence"), e
                    }

                    function z() {
                        Re = !1;
                        for (var t, e = !0, n = _t;;) {
                            var r = dt.charCodeAt(_t);
                            if (Je(r)) Re && (t += dt.charAt(_t)), ++_t;
                            else {
                                if (92 !== r) break;
                                Re || (t = dt.slice(n, _t)), Re = !0, 117 != dt.charCodeAt(++_t) && i(_t, "Expecting Unicode escape sequence \\uXXXX"), ++_t;
                                var s = E(4),
                                    o = String.fromCharCode(s);
                                o || i(_t - 1, "Invalid Unicode escape"), (e ? $e(s) : Je(s)) || i(_t - 4, "Invalid Unicode escape"), t += o
                            }
                            e = !1
                        }
                        return Re ? t : dt.slice(n, _t)
                    }

                    function k() {
                        var t = z(),
                            e = Dt;
                        return !Re && We(t) && (e = le[t]), o(e, t)
                    }

                    function I() {
                        zt = mt, kt = yt, It = xt, y()
                    }

                    function A(t) {
                        if (Mt = t, _t = mt, ct.locations)
                            for (; _t < Et;) Et = dt.lastIndexOf("\n", Et - 2) + 1, --Tt;
                        u(), y()
                    }

                    function P() {
                        this.type = null, this.start = mt,
                            this.end = null
                    }

                    function M() {
                        this.start = wt, this.end = null, null !== gt && (this.source = gt)
                    }

                    function O() {
                        var t = new P;
                        return ct.locations && (t.loc = new M), ct.directSourceFile && (t.sourceFile = ct.directSourceFile), ct.ranges && (t.range = [mt, 0]), t
                    }

                    function L(t) {
                        var e = new P;
                        return e.start = t.start, ct.locations && (e.loc = new M, e.loc.start = t.loc.start), ct.ranges && (e.range = [t.range[0], 0]), e
                    }

                    function N(t, e) {
                        return t.type = e, t.end = kt, ct.locations && (t.loc.end = It), ct.ranges && (t.range[1] = kt), t
                    }

                    function F(t) {
                        return ct.ecmaVersion >= 5 && "ExpressionStatement" === t.type && "Literal" === t.expression.type && "use strict" === t.expression.value
                    }

                    function D(t) {
                        if (bt === t) return I(), !0
                    }

                    function R() {
                        return !ct.strictSemicolons && (bt === Rt || bt === ge || Ze.test(dt.slice(kt, mt)))
                    }

                    function B() {
                        D(me) || R() || q()
                    }

                    function j(t) {
                        bt === t ? I() : q()
                    }

                    function q() {
                        i(mt, "Unexpected token")
                    }

                    function H(t) {
                        "Identifier" !== t.type && "MemberExpression" !== t.type && i(t.start, "Assigning to rvalue"), Mt && "Identifier" === t.type && He(t.name) && i(t.start, "Assigning to " + t.name + " in strict mode")
                    }

                    function W(t) {
                        zt = kt = _t, ct.locations && (It = new r), At = Mt = null, Pt = [], y();
                        var e = t || O(),
                            i = !0;
                        for (t || (e.body = []); bt !== Rt;) {
                            var n = V();
                            e.body.push(n), i && F(n) && A(!0), i = !1
                        }
                        return N(e, "Program")
                    }

                    function V() {
                        (bt === be || bt === Ce && "/=" == St) && y(!0);
                        var t = bt,
                            e = O();
                        switch (t) {
                            case Bt:
                            case Ht:
                                I();
                                var n = t === Bt;
                                D(me) || R() ? e.label = null : bt !== Dt ? q() : (e.label = lt(), B());
                                for (var r = 0; r < Pt.length; ++r) {
                                    var s = Pt[r];
                                    if (null == e.label || s.name === e.label.name) {
                                        if (null != s.kind && (n || "loop" === s.kind)) break;
                                        if (e.label && n) break
                                    }
                                }
                                return r === Pt.length && i(e.start, "Unsyntactic " + t.keyword), N(e, n ? "BreakStatement" : "ContinueStatement");
                            case Wt:
                                return I(), B(), N(e, "DebuggerStatement");
                            case Ut:
                                return I(), Pt.push(Qe), e.body = V(), Pt.pop(), j(ie), e.test = U(), B(), N(e, "DoWhileStatement");
                            case Zt:
                                if (I(), Pt.push(Qe), j(pe), bt === me) return X(e, null);
                                if (bt === ee) {
                                    var o = O();
                                    return I(), G(o, !0), N(o, "VariableDeclaration"), 1 === o.declarations.length && D(ue) ? Z(e, o) : X(e, o)
                                }
                                var o = $(!1, !0);
                                return D(ue) ? (H(o), Z(e, o)) : X(e, o);
                            case Gt:
                                return I(), ht(e, !0);
                            case $t:
                                return I(), e.test = U(), e.consequent = V(), e.alternate = D(Yt) ? V() : null, N(e, "IfStatement");
                            case Jt:
                                return At || ct.allowReturnOutsideFunction || i(mt, "'return' outside of function"), I(), D(me) || R() ? e.argument = null : (e.argument = $(), B()), N(e, "ReturnStatement");
                            case Qt:
                                I(), e.discriminant = U(), e.cases = [], j(fe), Pt.push(Ke);
                                for (var a, h; bt != ge;)
                                    if (bt === jt || bt === Vt) {
                                        var u = bt === jt;
                                        a && N(a, "SwitchCase"), e.cases.push(a = O()), a.consequent = [], I(), u ? a.test = $() : (h && i(zt, "Multiple default clauses"), h = !0, a.test = null), j(ye)
                                    } else a || q(), a.consequent.push(V());
                                return a && N(a, "SwitchCase"), I(), Pt.pop(), N(e, "SwitchStatement");
                            case Kt:
                                return I(), Ze.test(dt.slice(kt, mt)) && i(kt, "Illegal newline after throw"), e.argument = $(), B(), N(e, "ThrowStatement");
                            case te:
                                if (I(), e.block = Y(), e.handler = null, bt === qt) {
                                    var l = O();
                                    I(), j(pe), l.param = lt(), Mt && He(l.param.name) && i(l.param.start, "Binding " + l.param.name + " in strict mode"), j(ve), l.guard = null, l.body = Y(), e.handler = N(l, "CatchClause")
                                }
                                return e.guardedHandlers = Ot, e.finalizer = D(Xt) ? Y() : null, e.handler || e.finalizer || i(e.start, "Missing catch or finally clause"), N(e, "TryStatement");
                            case ee:
                                return I(), G(e), B(), N(e, "VariableDeclaration");
                            case ie:
                                return I(), e.test = U(), Pt.push(Qe), e.body = V(), Pt.pop(), N(e, "WhileStatement");
                            case ne:
                                return Mt && i(mt, "'with' in strict mode"), I(), e.object = U(), e.body = V(), N(e, "WithStatement");
                            case fe:
                                return Y();
                            case me:
                                return I(), N(e, "EmptyStatement");
                            default:
                                var c = St,
                                    d = $();
                                if (t === Dt && "Identifier" === d.type && D(ye)) {
                                    for (var r = 0; r < Pt.length; ++r) Pt[r].name === c && i(d.start, "Label '" + c + "' is already declared");
                                    var f = bt.isLoop ? "loop" : bt === Qt ? "switch" : null;
                                    return Pt.push({
                                        name: c,
                                        kind: f
                                    }), e.body = V(), Pt.pop(), e.label = d, N(e, "LabeledStatement")
                                }
                                return e.expression = d, B(), N(e, "ExpressionStatement")
                        }
                    }

                    function U() {
                        j(pe);
                        var t = $();
                        return j(ve), t
                    }

                    function Y(t) {
                        var e, i = O(),
                            n = !0,
                            r = !1;
                        for (i.body = [], j(fe); !D(ge);) {
                            var s = V();
                            i.body.push(s), n && t && F(s) && (e = r, A(r = !0)), n = !1
                        }
                        return r && !e && A(!1), N(i, "BlockStatement")
                    }

                    function X(t, e) {
                        return t.init = e, j(me), t.test = bt === me ? null : $(), j(me), t.update = bt === ve ? null : $(), j(ve), t.body = V(), Pt.pop(), N(t, "ForStatement")
                    }

                    function Z(t, e) {
                        return t.left = e, t.right = $(), j(ve), t.body = V(), Pt.pop(), N(t, "ForInStatement")
                    }

                    function G(t, e) {
                        for (t.declarations = [], t.kind = "var";;) {
                            var n = O();
                            if (n.id = lt(), Mt && He(n.id.name) && i(n.id.start, "Binding " + n.id.name + " in strict mode"), n.init = D(Se) ? $(!0, e) : null, t.declarations.push(N(n, "VariableDeclarator")), !D(_e)) break
                        }
                        return t
                    }

                    function $(t, e) {
                        var i = J(e);
                        if (!t && bt === _e) {
                            var n = L(i);
                            for (n.expressions = [i]; D(_e);) n.expressions.push(J(e));
                            return N(n, "SequenceExpression")
                        }
                        return i
                    }

                    function J(t) {
                        var e = Q(t);
                        if (bt.isAssign) {
                            var i = L(e);
                            return i.operator = St, i.left = e, I(), i.right = J(t), H(e), N(i, "AssignmentExpression")
                        }
                        return e
                    }

                    function Q(t) {
                        var e = K(t);
                        if (D(xe)) {
                            var i = L(e);
                            return i.test = e, i.consequent = $(!0), j(ye), i.alternate = $(!0, t), N(i, "ConditionalExpression")
                        }
                        return e
                    }

                    function K(t) {
                        return tt(et(), -1, t)
                    }

                    function tt(t, e, i) {
                        var n = bt.binop;
                        if (null != n && (!i || bt !== ue) && n > e) {
                            var r = L(t);
                            r.left = t, r.operator = St;
                            var s = bt;
                            I(), r.right = tt(et(), n, i);
                            return tt(N(r, s === ze || s === ke ? "LogicalExpression" : "BinaryExpression"), e, i)
                        }
                        return t
                    }

                    function et() {
                        if (bt.prefix) {
                            var t = O(),
                                e = bt.isUpdate;
                            return t.operator = St, t.prefix = !0, Ct = !0, I(), t.argument = et(), e ? H(t.argument) : Mt && "delete" === t.operator && "Identifier" === t.argument.type && i(t.start, "Deleting local variable in strict mode"), N(t, e ? "UpdateExpression" : "UnaryExpression")
                        }
                        for (var n = it(); bt.postfix && !R();) {
                            var t = L(n);
                            t.operator = St, t.prefix = !1, t.argument = n, H(n), I(), n = N(t, "UpdateExpression")
                        }
                        return n
                    }

                    function it() {
                        return nt(rt())
                    }

                    function nt(t, e) {
                        if (D(we)) {
                            var i = L(t);
                            return i.object = t, i.property = lt(!0), i.computed = !1, nt(N(i, "MemberExpression"), e)
                        }
                        if (D(ce)) {
                            var i = L(t);
                            return i.object = t, i.property = $(), i.computed = !0, j(de), nt(N(i, "MemberExpression"), e)
                        }
                        if (!e && D(pe)) {
                            var i = L(t);
                            return i.callee = t, i.arguments = ut(ve, !1), nt(N(i, "CallExpression"), e)
                        }
                        return t
                    }

                    function rt() {
                        switch (bt) {
                            case se:
                                var t = O();
                                return I(), N(t, "ThisExpression");
                            case Dt:
                                return lt();
                            case Lt:
                            case Ft:
                            case Nt:
                                var t = O();
                                return t.value = St, t.raw = dt.slice(mt, yt), I(), N(t, "Literal");
                            case oe:
                            case ae:
                            case he:
                                var t = O();
                                return t.value = bt.atomValue, t.raw = bt.keyword, I(), N(t, "Literal");
                            case pe:
                                var e = wt,
                                    i = mt;
                                I();
                                var n = $();
                                return n.start = i, n.end = yt, ct.locations && (n.loc.start = e, n.loc.end = xt), ct.ranges && (n.range = [i, yt]), j(ve), n;
                            case ce:
                                var t = O();
                                return I(), t.elements = ut(de, !0, !0), N(t, "ArrayExpression");
                            case fe:
                                return ot();
                            case Gt:
                                var t = O();
                                return I(), ht(t, !1);
                            case re:
                                return st();
                            default:
                                q()
                        }
                    }

                    function st() {
                        var t = O();
                        return I(), t.callee = nt(rt(), !0), D(pe) ? t.arguments = ut(ve, !1) : t.arguments = Ot, N(t, "NewExpression")
                    }

                    function ot() {
                        var t = O(),
                            e = !0,
                            n = !1;
                        for (t.properties = [], I(); !D(ge);) {
                            if (e) e = !1;
                            else if (j(_e), ct.allowTrailingCommas && D(ge)) break;
                            var r, s = {
                                    key: at()
                                },
                                o = !1;
                            if (D(ye) ? (s.value = $(!0), r = s.kind = "init") : ct.ecmaVersion >= 5 && "Identifier" === s.key.type && ("get" === s.key.name || "set" === s.key.name) ? (o = n = !0, r = s.kind = s.key.name, s.key = at(), bt !== pe && q(), s.value = ht(O(), !1)) : q(), "Identifier" === s.key.type && (Mt || n))
                                for (var a = 0; a < t.properties.length; ++a) {
                                    var h = t.properties[a];
                                    if (h.key.name === s.key.name) {
                                        var u = r == h.kind || o && "init" === h.kind || "init" === r && ("get" === h.kind || "set" === h.kind);
                                        u && !Mt && "init" === r && "init" === h.kind && (u = !1), u && i(s.key.start, "Redefinition of property")
                                    }
                                }
                            t.properties.push(s)
                        }
                        return N(t, "ObjectExpression")
                    }

                    function at() {
                        return bt === Lt || bt === Ft ? rt() : lt(!0)
                    }

                    function ht(t, e) {
                        bt === Dt ? t.id = lt() : e ? q() : t.id = null, t.params = [];
                        var n = !0;
                        for (j(pe); !D(ve);) n ? n = !1 : j(_e), t.params.push(lt());
                        var r = At,
                            s = Pt;
                        if (At = !0, Pt = [], t.body = Y(!0), At = r, Pt = s, Mt || t.body.body.length && F(t.body.body[0]))
                            for (var o = t.id ? -1 : 0; o < t.params.length; ++o) {
                                var a = o < 0 ? t.id : t.params[o];
                                if ((qe(a.name) || He(a.name)) && i(a.start, "Defining '" + a.name + "' in strict mode"), o >= 0)
                                    for (var h = 0; h < o; ++h) a.name === t.params[h].name && i(a.start, "Argument name clash in strict mode")
                            }
                        return N(t, e ? "FunctionDeclaration" : "FunctionExpression")
                    }

                    function ut(t, e, i) {
                        for (var n = [], r = !0; !D(t);) {
                            if (r) r = !1;
                            else if (j(_e), e && ct.allowTrailingCommas && D(t)) break;
                            i && bt === _e ? n.push(null) : n.push($(!0))
                        }
                        return n
                    }

                    function lt(t) {
                        var e = O();
                        return t && "everywhere" == ct.forbidReserved && (t = !1), bt === Dt ? (!t && (ct.forbidReserved && (3 === ct.ecmaVersion ? Be : je)(St) || Mt && qe(St)) && -1 == dt.slice(mt, yt).indexOf("\\") && i(mt, "The keyword '" + St + "' is reserved"), e.name = St) : t && bt.keyword ? e.name = bt.keyword : q(), Ct = !1, I(), N(e, "Identifier")
                    }
                    t.version = "0.5.0";
                    var ct, dt, ft, gt;
                    t.parse = function(t, i) {
                        return dt = String(t), ft = dt.length, e(i), s(), W(ct.program)
                    };
                    var pt = t.defaultOptions = {
                            ecmaVersion: 5,
                            strictSemicolons: !1,
                            allowTrailingCommas: !0,
                            forbidReserved: !1,
                            allowReturnOutsideFunction: !1,
                            locations: !1,
                            onComment: null,
                            ranges: !1,
                            program: null,
                            sourceFile: null,
                            directSourceFile: null
                        },
                        vt = t.getLineInfo = function(t, e) {
                            for (var i = 1, n = 0;;) {
                                Ge.lastIndex = n;
                                var r = Ge.exec(t);
                                if (!(r && r.index < e)) break;
                                ++i, n = r.index + r[0].length
                            }
                            return {
                                line: i,
                                column: e - n
                            }
                        };
                    t.tokenize = function(t, i) {
                        function n(t) {
                            return kt = yt, y(t), r.start = mt, r.end = yt, r.startLoc = wt, r.endLoc = xt, r.type = bt, r.value = St, r
                        }
                        dt = String(t), ft = dt.length, e(i), s();
                        var r = {};
                        return n.jumpTo = function(t, e) {
                            if (_t = t, ct.locations) {
                                Tt = 1, Et = Ge.lastIndex = 0;
                                for (var i;
                                    (i = Ge.exec(dt)) && i.index < t;) ++Tt, Et = i.index + i[0].length
                            }
                            Ct = e, u()
                        }, n
                    };
                    var _t, mt, yt, wt, xt, bt, St, Ct, Tt, Et, zt, kt, It, At, Pt, Mt, Ot = [],
                        Lt = {
                            type: "num"
                        },
                        Nt = {
                            type: "regexp"
                        },
                        Ft = {
                            type: "string"
                        },
                        Dt = {
                            type: "name"
                        },
                        Rt = {
                            type: "eof"
                        },
                        Bt = {
                            keyword: "break"
                        },
                        jt = {
                            keyword: "case",
                            beforeExpr: !0
                        },
                        qt = {
                            keyword: "catch"
                        },
                        Ht = {
                            keyword: "continue"
                        },
                        Wt = {
                            keyword: "debugger"
                        },
                        Vt = {
                            keyword: "default"
                        },
                        Ut = {
                            keyword: "do",
                            isLoop: !0
                        },
                        Yt = {
                            keyword: "else",
                            beforeExpr: !0
                        },
                        Xt = {
                            keyword: "finally"
                        },
                        Zt = {
                            keyword: "for",
                            isLoop: !0
                        },
                        Gt = {
                            keyword: "function"
                        },
                        $t = {
                            keyword: "if"
                        },
                        Jt = {
                            keyword: "return",
                            beforeExpr: !0
                        },
                        Qt = {
                            keyword: "switch"
                        },
                        Kt = {
                            keyword: "throw",
                            beforeExpr: !0
                        },
                        te = {
                            keyword: "try"
                        },
                        ee = {
                            keyword: "var"
                        },
                        ie = {
                            keyword: "while",
                            isLoop: !0
                        },
                        ne = {
                            keyword: "with"
                        },
                        re = {
                            keyword: "new",
                            beforeExpr: !0
                        },
                        se = {
                            keyword: "this"
                        },
                        oe = {
                            keyword: "null",
                            atomValue: null
                        },
                        ae = {
                            keyword: "true",
                            atomValue: !0
                        },
                        he = {
                            keyword: "false",
                            atomValue: !1
                        },
                        ue = {
                            keyword: "in",
                            binop: 7,
                            beforeExpr: !0
                        },
                        le = {
                            break: Bt,
                            case: jt,
                            catch: qt,
                            continue: Ht,
                            debugger: Wt,
                            default: Vt,
                            do: Ut,
                            else: Yt,
                            finally: Xt,
                            for: Zt,
                            function: Gt,
                            if: $t,
                            return: Jt,
                            switch: Qt,
                            throw: Kt,
                            try: te,
                            var: ee,
                            while: ie,
                            with: ne,
                            null: oe,
                            true: ae,
                            false: he,
                            new: re,
                            in: ue,
                            instanceof: {
                                keyword: "instanceof",
                                binop: 7,
                                beforeExpr: !0
                            },
                            this: se,
                            typeof: {
                                keyword: "typeof",
                                prefix: !0,
                                beforeExpr: !0
                            },
                            void: {
                                keyword: "void",
                                prefix: !0,
                                beforeExpr: !0
                            },
                            delete: {
                                keyword: "delete",
                                prefix: !0,
                                beforeExpr: !0
                            }
                        },
                        ce = {
                            type: "[",
                            beforeExpr: !0
                        },
                        de = {
                            type: "]"
                        },
                        fe = {
                            type: "{",
                            beforeExpr: !0
                        },
                        ge = {
                            type: "}"
                        },
                        pe = {
                            type: "(",
                            beforeExpr: !0
                        },
                        ve = {
                            type: ")"
                        },
                        _e = {
                            type: ",",
                            beforeExpr: !0
                        },
                        me = {
                            type: ";",
                            beforeExpr: !0
                        },
                        ye = {
                            type: ":",
                            beforeExpr: !0
                        },
                        we = {
                            type: "."
                        },
                        xe = {
                            type: "?",
                            beforeExpr: !0
                        },
                        be = {
                            binop: 10,
                            beforeExpr: !0
                        },
                        Se = {
                            isAssign: !0,
                            beforeExpr: !0
                        },
                        Ce = {
                            isAssign: !0,
                            beforeExpr: !0
                        },
                        Te = {
                            postfix: !0,
                            prefix: !0,
                            isUpdate: !0
                        },
                        Ee = {
                            prefix: !0,
                            beforeExpr: !0
                        },
                        ze = {
                            binop: 1,
                            beforeExpr: !0
                        },
                        ke = {
                            binop: 2,
                            beforeExpr: !0
                        },
                        Ie = {
                            binop: 3,
                            beforeExpr: !0
                        },
                        Ae = {
                            binop: 4,
                            beforeExpr: !0
                        },
                        Pe = {
                            binop: 5,
                            beforeExpr: !0
                        },
                        Me = {
                            binop: 6,
                            beforeExpr: !0
                        },
                        Oe = {
                            binop: 7,
                            beforeExpr: !0
                        },
                        Le = {
                            binop: 8,
                            beforeExpr: !0
                        },
                        Ne = {
                            binop: 9,
                            prefix: !0,
                            beforeExpr: !0
                        },
                        Fe = {
                            binop: 10,
                            beforeExpr: !0
                        };
                    t.tokTypes = {
                        bracketL: ce,
                        bracketR: de,
                        braceL: fe,
                        braceR: ge,
                        parenL: pe,
                        parenR: ve,
                        comma: _e,
                        semi: me,
                        colon: ye,
                        dot: we,
                        question: xe,
                        slash: be,
                        eq: Se,
                        name: Dt,
                        eof: Rt,
                        num: Lt,
                        regexp: Nt,
                        string: Ft
                    };
                    for (var De in le) t.tokTypes["_" + De] = le[De];
                    var Re, Be = n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
                        je = n("class enum extends super const export import"),
                        qe = n("implements interface let package private protected public static yield"),
                        He = n("eval arguments"),
                        We = n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),
                        Ve = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
                        Ue = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
                        Ye = new RegExp("[" + Ue + "]"),
                        Xe = new RegExp("[" + Ue + "------------------------------------------------------------------------------------------------------------------------------------------]"),
                        Ze = /[\n\r\u2028\u2029]/,
                        Ge = /\r\n|[\n\r\u2028\u2029]/g,
                        $e = t.isIdentifierStart = function(t) {
                            return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || t >= 170 && Ye.test(String.fromCharCode(t)))
                        },
                        Je = t.isIdentifierChar = function(t) {
                            return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || t >= 170 && Xe.test(String.fromCharCode(t))))
                        },
                        Qe = {
                            kind: "loop"
                        },
                        Ke = {
                            kind: "switch"
                        }
                }), v.version || (v = null)
        }
        var y = {
                "+": "__add",
                "-": "__subtract",
                "*": "__multiply",
                "/": "__divide",
                "%": "__modulo",
                "==": "__equals",
                "!=": "__equals"
            },
            w = {
                "-": "__negate",
                "+": "__self"
            },
            x = r.each(["add", "subtract", "multiply", "divide", "modulo", "equals", "negate"], function(t) {
                this["__" + t] = "#" + t
            }, {
                __self: function() {
                    return this
                }
            });
        return c.inject(x), f.inject(x), B.inject(x), i && ("complete" === n.readyState ? setTimeout(d) : V.add(i, {
            load: d
        })), {
            compile: h,
            execute: u,
            load: g,
            parse: e
        }
    }.call(this), paper = new(o.inject(r.exports, {
        Base: r,
        Numerical: u,
        Key: G,
        DomEvent: V,
        DomElement: W,
        document: n,
        window: i,
        Symbol: E,
        PlacedSymbol: T
    })), paper.agent.node && require("./node/extend.js")(paper), "function" == typeof define && define.amd ? define("paper", paper) : "object" == typeof module && module && (module.exports = paper), paper
}.call(this, "object" == typeof self ? self : null);
! function(t, e) {
    "use strict";
    "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? module.exports = e() : t.Headroom = e()
}(this, function() {
    "use strict";

    function t(t) {
        this.callback = t, this.ticking = !1
    }

    function e(t) {
        return t && "undefined" != typeof window && (t === window || t.nodeType)
    }

    function i(t) {
        if (arguments.length <= 0) throw new Error("Missing arguments in extend function");
        var n, r, s = t || {};
        for (r = 1; r < arguments.length; r++) {
            var o = arguments[r] || {};
            for (n in o) "object" != typeof s[n] || e(s[n]) ? s[n] = s[n] || o[n] : s[n] = i(s[n], o[n])
        }
        return s
    }

    function n(t) {
        return t === Object(t) ? t : {
            down: t,
            up: t
        }
    }

    function r(t, e) {
        e = i(e, r.options), this.lastKnownScrollY = 0, this.elem = t, this.tolerance = n(e.tolerance), this.classes = e.classes, this.offset = e.offset, this.scroller = e.scroller, this.initialised = !1, this.onPin = e.onPin, this.onUnpin = e.onUnpin, this.onTop = e.onTop, this.onNotTop = e.onNotTop, this.onBottom = e.onBottom, this.onNotBottom = e.onNotBottom
    }
    var s = {
        bind: !! function() {}.bind,
        classList: "classList" in document.documentElement,
        rAF: !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)
    };
    return window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame, t.prototype = {
        constructor: t,
        update: function() {
            this.callback && this.callback(), this.ticking = !1
        },
        requestTick: function() {
            this.ticking || (requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this))), this.ticking = !0)
        },
        handleEvent: function() {
            this.requestTick()
        }
    }, r.prototype = {
        constructor: r,
        init: function() {
            if (r.cutsTheMustard) return this.debouncer = new t(this.update.bind(this)), this.elem.classList.add(this.classes.initial), setTimeout(this.attachEvent.bind(this), 100), this
        },
        destroy: function() {
            var t = this.classes;
            this.initialised = !1, this.elem.classList.remove(t.unpinned, t.pinned, t.top, t.notTop, t.initial), this.scroller.removeEventListener("scroll", this.debouncer, !1)
        },
        attachEvent: function() {
            this.initialised || (this.lastKnownScrollY = this.getScrollY(), this.initialised = !0, this.scroller.addEventListener("scroll", this.debouncer, !1), this.debouncer.handleEvent())
        },
        unpin: function() {
            var t = this.elem.classList,
                e = this.classes;
            !t.contains(e.pinned) && t.contains(e.unpinned) || (t.add(e.unpinned), t.remove(e.pinned), this.onUnpin && this.onUnpin.call(this))
        },
        pin: function() {
            var t = this.elem.classList,
                e = this.classes;
            t.contains(e.unpinned) && (t.remove(e.unpinned), t.add(e.pinned), this.onPin && this.onPin.call(this))
        },
        top: function() {
            var t = this.elem.classList,
                e = this.classes;
            t.contains(e.top) || (t.add(e.top), t.remove(e.notTop), this.onTop && this.onTop.call(this))
        },
        notTop: function() {
            var t = this.elem.classList,
                e = this.classes;
            t.contains(e.notTop) || (t.add(e.notTop), t.remove(e.top), this.onNotTop && this.onNotTop.call(this))
        },
        bottom: function() {
            var t = this.elem.classList,
                e = this.classes;
            t.contains(e.bottom) || (t.add(e.bottom), t.remove(e.notBottom), this.onBottom && this.onBottom.call(this))
        },
        notBottom: function() {
            var t = this.elem.classList,
                e = this.classes;
            t.contains(e.notBottom) || (t.add(e.notBottom), t.remove(e.bottom), this.onNotBottom && this.onNotBottom.call(this))
        },
        getScrollY: function() {
            return void 0 !== this.scroller.pageYOffset ? this.scroller.pageYOffset : void 0 !== this.scroller.scrollTop ? this.scroller.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop
        },
        getViewportHeight: function() {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        },
        getElementPhysicalHeight: function(t) {
            return Math.max(t.offsetHeight, t.clientHeight)
        },
        getScrollerPhysicalHeight: function() {
            return this.scroller === window || this.scroller === document.body ? this.getViewportHeight() : this.getElementPhysicalHeight(this.scroller)
        },
        getDocumentHeight: function() {
            var t = document.body,
                e = document.documentElement;
            return Math.max(t.scrollHeight, e.scrollHeight, t.offsetHeight, e.offsetHeight, t.clientHeight, e.clientHeight)
        },
        getElementHeight: function(t) {
            return Math.max(t.scrollHeight, t.offsetHeight, t.clientHeight)
        },
        getScrollerHeight: function() {
            return this.scroller === window || this.scroller === document.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller)
        },
        isOutOfBounds: function(t) {
            var e = t < 0,
                i = t + this.getScrollerPhysicalHeight() > this.getScrollerHeight();
            return e || i
        },
        toleranceExceeded: function(t, e) {
            return Math.abs(t - this.lastKnownScrollY) >= this.tolerance[e]
        },
        shouldUnpin: function(t, e) {
            var i = t > this.lastKnownScrollY,
                n = t >= this.offset;
            return i && n && e
        },
        shouldPin: function(t, e) {
            var i = t < this.lastKnownScrollY,
                n = t <= this.offset;
            return i && e || n
        },
        update: function() {
            var t = this.getScrollY(),
                e = t > this.lastKnownScrollY ? "down" : "up",
                i = this.toleranceExceeded(t, e);
            this.isOutOfBounds(t) || (t <= this.offset ? this.top() : this.notTop(), t + this.getViewportHeight() >= this.getScrollerHeight() ? this.bottom() : this.notBottom(), this.shouldUnpin(t, i) ? this.unpin() : this.shouldPin(t, i) && this.pin(), this.lastKnownScrollY = t)
        }
    }, r.options = {
        tolerance: {
            up: 0,
            down: 0
        },
        offset: 0,
        scroller: window,
        classes: {
            pinned: "headroom--pinned",
            unpinned: "headroom--unpinned",
            top: "headroom--top",
            notTop: "headroom--not-top",
            bottom: "headroom--bottom",
            notBottom: "headroom--not-bottom",
            initial: "headroom"
        }
    }, r.cutsTheMustard = void 0 !== s && s.rAF && s.bind && s.classList, r
}),
function() {
    var t;
    t = function() {
            function t(t, e) {
                var i, n;
                if (this.options = {
                        target: "instafeed",
                        get: "popular",
                        resolution: "thumbnail",
                        sortBy: "none",
                        links: !0,
                        mock: !1,
                        useHttp: !1
                    }, "object" == typeof t)
                    for (i in t) n = t[i], this.options[i] = n;
                this.context = null != e ? e : this, this.unique = this._genKey()
            }
            return t.prototype.hasNext = function() {
                return "string" == typeof this.context.nextUrl && this.context.nextUrl.length > 0
            }, t.prototype.next = function() {
                return !!this.hasNext() && this.run(this.context.nextUrl)
            }, t.prototype.run = function(e) {
                var i, n, r;
                if ("string" != typeof this.options.clientId && "string" != typeof this.options.accessToken) throw new Error("Missing clientId or accessToken.");
                if ("string" != typeof this.options.accessToken && "string" != typeof this.options.clientId) throw new Error("Missing clientId or accessToken.");
                return null != this.options.before && "function" == typeof this.options.before && this.options.before.call(this), "undefined" != typeof document && null !== document && (r = document.createElement("script"), r.id = "instafeed-fetcher", r.src = e || this._buildUrl(), i = document.getElementsByTagName("head"), i[0].appendChild(r), n = "instafeedCache" + this.unique, window[n] = new t(this.options, this), window[n].unique = this.unique), !0
            }, t.prototype.parse = function(t) {
                var e, i, n, r, s, o, a, h, u, l, c, d, f, g, p, v, _, m, y, w, x, b, S, C, T, E, z, k, I, A, P;
                if ("object" != typeof t) {
                    if (null != this.options.error && "function" == typeof this.options.error) return this.options.error.call(this, "Invalid JSON data"), !1;
                    throw new Error("Invalid JSON response")
                }
                if (200 !== t.meta.code) {
                    if (null != this.options.error && "function" == typeof this.options.error) return this.options.error.call(this, t.meta.error_message), !1;
                    throw new Error("Error from Instagram: " + t.meta.error_message)
                }
                if (0 === t.data.length) {
                    if (null != this.options.error && "function" == typeof this.options.error) return this.options.error.call(this, "No images were returned from Instagram"), !1;
                    throw new Error("No images were returned from Instagram")
                }
                if (null != this.options.success && "function" == typeof this.options.success && this.options.success.call(this, t), this.context.nextUrl = "", null != t.pagination && (this.context.nextUrl = t.pagination.next_url), "none" !== this.options.sortBy) switch (I = "random" === this.options.sortBy ? ["", "random"] : this.options.sortBy.split("-"), k = "least" === I[0], I[1]) {
                    case "random":
                        t.data.sort(function() {
                            return .5 - Math.random()
                        });
                        break;
                    case "recent":
                        t.data = this._sortBy(t.data, "created_time", k);
                        break;
                    case "liked":
                        t.data = this._sortBy(t.data, "likes.count", k);
                        break;
                    case "commented":
                        t.data = this._sortBy(t.data, "comments.count", k);
                        break;
                    default:
                        throw new Error("Invalid option for sortBy: '" + this.options.sortBy + "'.")
                }
                if ("undefined" != typeof document && null !== document && !1 === this.options.mock) {
                    if (p = t.data, z = parseInt(this.options.limit, 10), null != this.options.limit && p.length > z && (p = p.slice(0, z)), o = document.createDocumentFragment(), null != this.options.filter && "function" == typeof this.options.filter && (p = this._filter(p, this.options.filter)), null != this.options.template && "string" == typeof this.options.template) {
                        for (h = "", f = "", "", P = document.createElement("div"), l = 0, S = p.length; l < S; l++) {
                            if (c = p[l], "object" != typeof(d = c.images[this.options.resolution])) throw s = "No image found for resolution: " + this.options.resolution + ".", new Error(s);
                            y = d.width, _ = d.height, m = "square", y > _ && (m = "landscape"), y < _ && (m = "portrait"), g = d.url, u = window.location.protocol.indexOf("http") >= 0, u && !this.options.useHttp && (g = g.replace(/https?:\/\//, "//")), f = this._makeTemplate(this.options.template, {
                                model: c,
                                id: c.id,
                                link: c.link,
                                type: c.type,
                                image: g,
                                width: y,
                                height: _,
                                orientation: m,
                                caption: this._getObjectProperty(c, "caption.text"),
                                likes: c.likes.count,
                                comments: c.comments.count,
                                location: this._getObjectProperty(c, "location.name")
                            }), h += f
                        }
                        for (P.innerHTML = h, r = [], n = 0, i = P.childNodes.length; n < i;) r.push(P.childNodes[n]), n += 1;
                        for (x = 0, C = r.length; x < C; x++) E = r[x], o.appendChild(E)
                    } else
                        for (b = 0, T = p.length; b < T; b++) {
                            if (c = p[b], v = document.createElement("img"), "object" != typeof(d = c.images[this.options.resolution])) throw s = "No image found for resolution: " + this.options.resolution + ".", new Error(s);
                            g = d.url, u = window.location.protocol.indexOf("http") >= 0, u && !this.options.useHttp && (g = g.replace(/https?:\/\//, "//")), v.src = g, !0 === this.options.links ? (e = document.createElement("a"), e.href = c.link, e.appendChild(v), o.appendChild(e)) : o.appendChild(v)
                        }
                    if (A = this.options.target, "string" == typeof A && (A = document.getElementById(A)), null == A) throw s = 'No element with id="' + this.options.target + '" on page.', new Error(s);
                    A.appendChild(o), a = document.getElementsByTagName("head")[0], a.removeChild(document.getElementById("instafeed-fetcher")), w = "instafeedCache" + this.unique, window[w] = void 0;
                    try {
                        delete window[w]
                    } catch (t) {
                        t
                    }
                }
                return null != this.options.after && "function" == typeof this.options.after && this.options.after.call(this), !0
            }, t.prototype._buildUrl = function() {
                var t, e, i;
                switch (t = "https://api.instagram.com/v1", this.options.get) {
                    case "popular":
                        e = "media/popular";
                        break;
                    case "tagged":
                        if (!this.options.tagName) throw new Error("No tag name specified. Use the 'tagName' option.");
                        e = "tags/" + this.options.tagName + "/media/recent";
                        break;
                    case "location":
                        if (!this.options.locationId) throw new Error("No location specified. Use the 'locationId' option.");
                        e = "locations/" + this.options.locationId + "/media/recent";
                        break;
                    case "user":
                        if (!this.options.userId) throw new Error("No user specified. Use the 'userId' option.");
                        e = "users/" + this.options.userId + "/media/recent";
                        break;
                    default:
                        throw new Error("Invalid option for get: '" + this.options.get + "'.")
                }
                return i = t + "/" + e, null != this.options.accessToken ? i += "?access_token=" + this.options.accessToken : i += "?client_id=" + this.options.clientId, null != this.options.limit && (i += "&count=" + this.options.limit), i += "&callback=instafeedCache" + this.unique + ".parse"
            }, t.prototype._genKey = function() {
                var t;
                return "" + (t = function() {
                    return (65536 * (1 + Math.random()) | 0).toString(16).substring(1)
                })() + t() + t() + t()
            }, t.prototype._makeTemplate = function(t, e) {
                var i, n, r, s, o;
                for (n = /(?:\{{2})([\w\[\]\.]+)(?:\}{2})/, i = t; n.test(i);) s = i.match(n)[1], o = null != (r = this._getObjectProperty(e, s)) ? r : "", i = i.replace(n, function() {
                    return "" + o
                });
                return i
            }, t.prototype._getObjectProperty = function(t, e) {
                var i, n;
                for (e = e.replace(/\[(\w+)\]/g, ".$1"), n = e.split("."); n.length;) {
                    if (i = n.shift(), !(null != t && i in t)) return null;
                    t = t[i]
                }
                return t
            }, t.prototype._sortBy = function(t, e, i) {
                var n;
                return n = function(t, n) {
                    var r, s;
                    return r = this._getObjectProperty(t, e), s = this._getObjectProperty(n, e), i ? r > s ? 1 : -1 : r < s ? 1 : -1
                }, t.sort(n.bind(this)), t
            }, t.prototype._filter = function(t, e) {
                var i, n, r, s, o;
                for (i = [], n = function(t) {
                        if (e(t)) return i.push(t)
                    }, r = 0, o = t.length; r < o; r++) s = t[r], n(s);
                return i
            }, t
        }(),
        function(t, e) {
            "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.Instafeed = e()
        }(this, function() {
            return t
        })
}.call(this),
    function(t, e, i, n) {
        "use strict";

        function r(t, e, i) {
            return setTimeout(u(t, i), e)
        }

        function s(t, e, i) {
            return !!Array.isArray(t) && (o(t, i[e], i), !0)
        }

        function o(t, e, i) {
            var r;
            if (t)
                if (t.forEach) t.forEach(e, i);
                else if (t.length !== n)
                for (r = 0; r < t.length;) e.call(i, t[r], r, t), r++;
            else
                for (r in t) t.hasOwnProperty(r) && e.call(i, t[r], r, t)
        }

        function a(e, i, n) {
            var r = "DEPRECATED METHOD: " + i + "\n" + n + " AT \n";
            return function() {
                var i = new Error("get-stack-trace"),
                    n = i && i.stack ? i.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                    s = t.console && (t.console.warn || t.console.log);
                return s && s.call(t.console, r, n), e.apply(this, arguments)
            }
        }

        function h(t, e, i) {
            var n, r = e.prototype;
            n = t.prototype = Object.create(r), n.constructor = t, n._super = r, i && lt(n, i)
        }

        function u(t, e) {
            return function() {
                return t.apply(e, arguments)
            }
        }

        function l(t, e) {
            return typeof t == ft ? t.apply(e ? e[0] || n : n, e) : t
        }

        function c(t, e) {
            return t === n ? e : t
        }

        function d(t, e, i) {
            o(v(e), function(e) {
                t.addEventListener(e, i, !1)
            })
        }

        function f(t, e, i) {
            o(v(e), function(e) {
                t.removeEventListener(e, i, !1)
            })
        }

        function g(t, e) {
            for (; t;) {
                if (t == e) return !0;
                t = t.parentNode
            }
            return !1
        }

        function p(t, e) {
            return t.indexOf(e) > -1
        }

        function v(t) {
            return t.trim().split(/\s+/g)
        }

        function _(t, e, i) {
            if (t.indexOf && !i) return t.indexOf(e);
            for (var n = 0; n < t.length;) {
                if (i && t[n][i] == e || !i && t[n] === e) return n;
                n++
            }
            return -1
        }

        function m(t) {
            return Array.prototype.slice.call(t, 0)
        }

        function y(t, e, i) {
            for (var n = [], r = [], s = 0; s < t.length;) {
                var o = e ? t[s][e] : t[s];
                _(r, o) < 0 && n.push(t[s]), r[s] = o, s++
            }
            return i && (n = e ? n.sort(function(t, i) {
                return t[e] > i[e]
            }) : n.sort()), n
        }

        function w(t, e) {
            for (var i, r, s = e[0].toUpperCase() + e.slice(1), o = 0; o < ct.length;) {
                if (i = ct[o], (r = i ? i + s : e) in t) return r;
                o++
            }
            return n
        }

        function x() {
            return yt++
        }

        function b(e) {
            var i = e.ownerDocument || e;
            return i.defaultView || i.parentWindow || t
        }

        function S(t, e) {
            var i = this;
            this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function(e) {
                l(t.options.enable, [t]) && i.handler(e)
            }, this.init()
        }

        function C(t) {
            var e = t.options.inputClass;
            return new(e || (bt ? R : St ? q : xt ? W : D))(t, T)
        }

        function T(t, e, i) {
            var n = i.pointers.length,
                r = i.changedPointers.length,
                s = e & Tt && n - r == 0,
                o = e & (zt | kt) && n - r == 0;
            i.isFirst = !!s, i.isFinal = !!o, s && (t.session = {}), i.eventType = e, E(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i
        }

        function E(t, e) {
            var i = t.session,
                n = e.pointers,
                r = n.length;
            i.firstInput || (i.firstInput = I(e)), r > 1 && !i.firstMultiple ? i.firstMultiple = I(e) : 1 === r && (i.firstMultiple = !1);
            var s = i.firstInput,
                o = i.firstMultiple,
                a = o ? o.center : s.center,
                h = e.center = A(n);
            e.timeStamp = vt(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = L(a, h), e.distance = O(a, h), z(i, e), e.offsetDirection = M(e.deltaX, e.deltaY);
            var u = P(e.deltaTime, e.deltaX, e.deltaY);
            e.overallVelocityX = u.x, e.overallVelocityY = u.y, e.overallVelocity = pt(u.x) > pt(u.y) ? u.x : u.y, e.scale = o ? F(o.pointers, n) : 1, e.rotation = o ? N(o.pointers, n) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, k(i, e);
            var l = t.element;
            g(e.srcEvent.target, l) && (l = e.srcEvent.target), e.target = l
        }

        function z(t, e) {
            var i = e.center,
                n = t.offsetDelta || {},
                r = t.prevDelta || {},
                s = t.prevInput || {};
            e.eventType !== Tt && s.eventType !== zt || (r = t.prevDelta = {
                x: s.deltaX || 0,
                y: s.deltaY || 0
            }, n = t.offsetDelta = {
                x: i.x,
                y: i.y
            }), e.deltaX = r.x + (i.x - n.x), e.deltaY = r.y + (i.y - n.y)
        }

        function k(t, e) {
            var i, r, s, o, a = t.lastInterval || e,
                h = e.timeStamp - a.timeStamp;
            if (e.eventType != kt && (h > Ct || a.velocity === n)) {
                var u = e.deltaX - a.deltaX,
                    l = e.deltaY - a.deltaY,
                    c = P(h, u, l);
                r = c.x, s = c.y, i = pt(c.x) > pt(c.y) ? c.x : c.y, o = M(u, l), t.lastInterval = e
            } else i = a.velocity, r = a.velocityX, s = a.velocityY, o = a.direction;
            e.velocity = i, e.velocityX = r, e.velocityY = s, e.direction = o
        }

        function I(t) {
            for (var e = [], i = 0; i < t.pointers.length;) e[i] = {
                clientX: gt(t.pointers[i].clientX),
                clientY: gt(t.pointers[i].clientY)
            }, i++;
            return {
                timeStamp: vt(),
                pointers: e,
                center: A(e),
                deltaX: t.deltaX,
                deltaY: t.deltaY
            }
        }

        function A(t) {
            var e = t.length;
            if (1 === e) return {
                x: gt(t[0].clientX),
                y: gt(t[0].clientY)
            };
            for (var i = 0, n = 0, r = 0; r < e;) i += t[r].clientX, n += t[r].clientY, r++;
            return {
                x: gt(i / e),
                y: gt(n / e)
            }
        }

        function P(t, e, i) {
            return {
                x: e / t || 0,
                y: i / t || 0
            }
        }

        function M(t, e) {
            return t === e ? It : pt(t) >= pt(e) ? t < 0 ? At : Pt : e < 0 ? Mt : Ot
        }

        function O(t, e, i) {
            i || (i = Dt);
            var n = e[i[0]] - t[i[0]],
                r = e[i[1]] - t[i[1]];
            return Math.sqrt(n * n + r * r)
        }

        function L(t, e, i) {
            i || (i = Dt);
            var n = e[i[0]] - t[i[0]],
                r = e[i[1]] - t[i[1]];
            return 180 * Math.atan2(r, n) / Math.PI
        }

        function N(t, e) {
            return L(e[1], e[0], Rt) + L(t[1], t[0], Rt)
        }

        function F(t, e) {
            return O(e[0], e[1], Rt) / O(t[0], t[1], Rt)
        }

        function D() {
            this.evEl = jt, this.evWin = qt, this.pressed = !1, S.apply(this, arguments)
        }

        function R() {
            this.evEl = Vt, this.evWin = Ut, S.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
        }

        function B() {
            this.evTarget = Xt, this.evWin = Zt, this.started = !1, S.apply(this, arguments)
        }

        function j(t, e) {
            var i = m(t.touches),
                n = m(t.changedTouches);
            return e & (zt | kt) && (i = y(i.concat(n), "identifier", !0)), [i, n]
        }

        function q() {
            this.evTarget = $t, this.targetIds = {}, S.apply(this, arguments)
        }

        function H(t, e) {
            var i = m(t.touches),
                n = this.targetIds;
            if (e & (Tt | Et) && 1 === i.length) return n[i[0].identifier] = !0, [i, i];
            var r, s, o = m(t.changedTouches),
                a = [],
                h = this.target;
            if (s = i.filter(function(t) {
                    return g(t.target, h)
                }), e === Tt)
                for (r = 0; r < s.length;) n[s[r].identifier] = !0, r++;
            for (r = 0; r < o.length;) n[o[r].identifier] && a.push(o[r]), e & (zt | kt) && delete n[o[r].identifier], r++;
            return a.length ? [y(s.concat(a), "identifier", !0), a] : void 0
        }

        function W() {
            S.apply(this, arguments);
            var t = u(this.handler, this);
            this.touch = new q(this.manager, t), this.mouse = new D(this.manager, t), this.primaryTouch = null, this.lastTouches = []
        }

        function V(t, e) {
            t & Tt ? (this.primaryTouch = e.changedPointers[0].identifier, U.call(this, e)) : t & (zt | kt) && U.call(this, e)
        }

        function U(t) {
            var e = t.changedPointers[0];
            if (e.identifier === this.primaryTouch) {
                var i = {
                    x: e.clientX,
                    y: e.clientY
                };
                this.lastTouches.push(i);
                var n = this.lastTouches,
                    r = function() {
                        var t = n.indexOf(i);
                        t > -1 && n.splice(t, 1)
                    };
                setTimeout(r, Jt)
            }
        }

        function Y(t) {
            for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
                var r = this.lastTouches[n],
                    s = Math.abs(e - r.x),
                    o = Math.abs(i - r.y);
                if (s <= Qt && o <= Qt) return !0
            }
            return !1
        }

        function X(t, e) {
            this.manager = t, this.set(e)
        }

        function Z(t) {
            if (p(t, ne)) return ne;
            var e = p(t, re),
                i = p(t, se);
            return e && i ? ne : e || i ? e ? re : se : p(t, ie) ? ie : ee
        }

        function G(t) {
            this.options = lt({}, this.defaults, t || {}), this.id = x(), this.manager = null, this.options.enable = c(this.options.enable, !0), this.state = ae, this.simultaneous = {}, this.requireFail = []
        }

        function $(t) {
            return t & de ? "cancel" : t & le ? "end" : t & ue ? "move" : t & he ? "start" : ""
        }

        function J(t) {
            return t == Ot ? "down" : t == Mt ? "up" : t == At ? "left" : t == Pt ? "right" : ""
        }

        function Q(t, e) {
            var i = e.manager;
            return i ? i.get(t) : t
        }

        function K() {
            G.apply(this, arguments)
        }

        function tt() {
            K.apply(this, arguments), this.pX = null, this.pY = null
        }

        function et() {
            K.apply(this, arguments)
        }

        function it() {
            G.apply(this, arguments), this._timer = null, this._input = null
        }

        function nt() {
            K.apply(this, arguments)
        }

        function rt() {
            K.apply(this, arguments)
        }

        function st() {
            G.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
        }

        function ot(t, e) {
            return e = e || {}, e.recognizers = c(e.recognizers, ot.defaults.preset), new at(t, e)
        }

        function at(t, e) {
            this.options = lt({}, ot.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = C(this), this.touchAction = new X(this, this.options.touchAction), ht(this, !0), o(this.options.recognizers, function(t) {
                var e = this.add(new t[0](t[1]));
                t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3])
            }, this)
        }

        function ht(t, e) {
            var i = t.element;
            if (i.style) {
                var n;
                o(t.options.cssProps, function(r, s) {
                    n = w(i.style, s), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = t.oldCssProps[n] || ""
                }), e || (t.oldCssProps = {})
            }
        }

        function ut(t, i) {
            var n = e.createEvent("Event");
            n.initEvent(t, !0, !0), n.gesture = i, i.target.dispatchEvent(n)
        }
        var lt, ct = ["", "webkit", "Moz", "MS", "ms", "o"],
            dt = e.createElement("div"),
            ft = "function",
            gt = Math.round,
            pt = Math.abs,
            vt = Date.now;
        lt = "function" != typeof Object.assign ? function(t) {
            if (t === n || null === t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var r = arguments[i];
                if (r !== n && null !== r)
                    for (var s in r) r.hasOwnProperty(s) && (e[s] = r[s])
            }
            return e
        } : Object.assign;
        var _t = a(function(t, e, i) {
                for (var r = Object.keys(e), s = 0; s < r.length;)(!i || i && t[r[s]] === n) && (t[r[s]] = e[r[s]]), s++;
                return t
            }, "extend", "Use `assign`."),
            mt = a(function(t, e) {
                return _t(t, e, !0)
            }, "merge", "Use `assign`."),
            yt = 1,
            wt = /mobile|tablet|ip(ad|hone|od)|android/i,
            xt = "ontouchstart" in t,
            bt = w(t, "PointerEvent") !== n,
            St = xt && wt.test(navigator.userAgent),
            Ct = 25,
            Tt = 1,
            Et = 2,
            zt = 4,
            kt = 8,
            It = 1,
            At = 2,
            Pt = 4,
            Mt = 8,
            Ot = 16,
            Lt = At | Pt,
            Nt = Mt | Ot,
            Ft = Lt | Nt,
            Dt = ["x", "y"],
            Rt = ["clientX", "clientY"];
        S.prototype = {
            handler: function() {},
            init: function() {
                this.evEl && d(this.element, this.evEl, this.domHandler), this.evTarget && d(this.target, this.evTarget, this.domHandler), this.evWin && d(b(this.element), this.evWin, this.domHandler)
            },
            destroy: function() {
                this.evEl && f(this.element, this.evEl, this.domHandler), this.evTarget && f(this.target, this.evTarget, this.domHandler), this.evWin && f(b(this.element), this.evWin, this.domHandler)
            }
        };
        var Bt = {
                mousedown: Tt,
                mousemove: Et,
                mouseup: zt
            },
            jt = "mousedown",
            qt = "mousemove mouseup";
        h(D, S, {
            handler: function(t) {
                var e = Bt[t.type];
                e & Tt && 0 === t.button && (this.pressed = !0), e & Et && 1 !== t.which && (e = zt), this.pressed && (e & zt && (this.pressed = !1), this.callback(this.manager, e, {
                    pointers: [t],
                    changedPointers: [t],
                    pointerType: "mouse",
                    srcEvent: t
                }))
            }
        });
        var Ht = {
                pointerdown: Tt,
                pointermove: Et,
                pointerup: zt,
                pointercancel: kt,
                pointerout: kt
            },
            Wt = {
                2: "touch",
                3: "pen",
                4: "mouse",
                5: "kinect"
            },
            Vt = "pointerdown",
            Ut = "pointermove pointerup pointercancel";
        t.MSPointerEvent && !t.PointerEvent && (Vt = "MSPointerDown", Ut = "MSPointerMove MSPointerUp MSPointerCancel"), h(R, S, {
            handler: function(t) {
                var e = this.store,
                    i = !1,
                    n = t.type.toLowerCase().replace("ms", ""),
                    r = Ht[n],
                    s = Wt[t.pointerType] || t.pointerType,
                    o = "touch" == s,
                    a = _(e, t.pointerId, "pointerId");
                r & Tt && (0 === t.button || o) ? a < 0 && (e.push(t), a = e.length - 1) : r & (zt | kt) && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, r, {
                    pointers: e,
                    changedPointers: [t],
                    pointerType: s,
                    srcEvent: t
                }), i && e.splice(a, 1))
            }
        });
        var Yt = {
                touchstart: Tt,
                touchmove: Et,
                touchend: zt,
                touchcancel: kt
            },
            Xt = "touchstart",
            Zt = "touchstart touchmove touchend touchcancel";
        h(B, S, {
            handler: function(t) {
                var e = Yt[t.type];
                if (e === Tt && (this.started = !0), this.started) {
                    var i = j.call(this, t, e);
                    e & (zt | kt) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
                        pointers: i[0],
                        changedPointers: i[1],
                        pointerType: "touch",
                        srcEvent: t
                    })
                }
            }
        });
        var Gt = {
                touchstart: Tt,
                touchmove: Et,
                touchend: zt,
                touchcancel: kt
            },
            $t = "touchstart touchmove touchend touchcancel";
        h(q, S, {
            handler: function(t) {
                var e = Gt[t.type],
                    i = H.call(this, t, e);
                i && this.callback(this.manager, e, {
                    pointers: i[0],
                    changedPointers: i[1],
                    pointerType: "touch",
                    srcEvent: t
                })
            }
        });
        var Jt = 2500,
            Qt = 25;
        h(W, S, {
            handler: function(t, e, i) {
                var n = "touch" == i.pointerType,
                    r = "mouse" == i.pointerType;
                if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
                    if (n) V.call(this, e, i);
                    else if (r && Y.call(this, i)) return;
                    this.callback(t, e, i)
                }
            },
            destroy: function() {
                this.touch.destroy(), this.mouse.destroy()
            }
        });
        var Kt = w(dt.style, "touchAction"),
            te = Kt !== n,
            ee = "auto",
            ie = "manipulation",
            ne = "none",
            re = "pan-x",
            se = "pan-y",
            oe = function() {
                if (!te) return !1;
                var e = {},
                    i = t.CSS && t.CSS.supports;
                return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(n) {
                    e[n] = !i || t.CSS.supports("touch-action", n)
                }), e
            }();
        X.prototype = {
            set: function(t) {
                "compute" == t && (t = this.compute()), te && this.manager.element.style && oe[t] && (this.manager.element.style[Kt] = t), this.actions = t.toLowerCase().trim()
            },
            update: function() {
                this.set(this.manager.options.touchAction)
            },
            compute: function() {
                var t = [];
                return o(this.manager.recognizers, function(e) {
                    l(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()))
                }), Z(t.join(" "))
            },
            preventDefaults: function(t) {
                var e = t.srcEvent,
                    i = t.offsetDirection;
                if (this.manager.session.prevented) return void e.preventDefault();
                var n = this.actions,
                    r = p(n, ne) && !oe[ne],
                    s = p(n, se) && !oe[se],
                    o = p(n, re) && !oe[re];
                if (r) {
                    var a = 1 === t.pointers.length,
                        h = t.distance < 2,
                        u = t.deltaTime < 250;
                    if (a && h && u) return
                }
                return o && s ? void 0 : r || s && i & Lt || o && i & Nt ? this.preventSrc(e) : void 0
            },
            preventSrc: function(t) {
                this.manager.session.prevented = !0, t.preventDefault()
            }
        };
        var ae = 1,
            he = 2,
            ue = 4,
            le = 8,
            ce = le,
            de = 16;
        G.prototype = {
            defaults: {},
            set: function(t) {
                return lt(this.options, t), this.manager && this.manager.touchAction.update(), this
            },
            recognizeWith: function(t) {
                if (s(t, "recognizeWith", this)) return this;
                var e = this.simultaneous;
                return t = Q(t, this), e[t.id] || (e[t.id] = t, t.recognizeWith(this)), this
            },
            dropRecognizeWith: function(t) {
                return s(t, "dropRecognizeWith", this) ? this : (t = Q(t, this), delete this.simultaneous[t.id], this)
            },
            requireFailure: function(t) {
                if (s(t, "requireFailure", this)) return this;
                var e = this.requireFail;
                return t = Q(t, this), -1 === _(e, t) && (e.push(t), t.requireFailure(this)), this
            },
            dropRequireFailure: function(t) {
                if (s(t, "dropRequireFailure", this)) return this;
                t = Q(t, this);
                var e = _(this.requireFail, t);
                return e > -1 && this.requireFail.splice(e, 1), this
            },
            hasRequireFailures: function() {
                return this.requireFail.length > 0
            },
            canRecognizeWith: function(t) {
                return !!this.simultaneous[t.id]
            },
            emit: function(t) {
                function e(e) {
                    i.manager.emit(e, t)
                }
                var i = this,
                    n = this.state;
                n < le && e(i.options.event + $(n)), e(i.options.event), t.additionalEvent && e(t.additionalEvent), n >= le && e(i.options.event + $(n))
            },
            tryEmit: function(t) {
                if (this.canEmit()) return this.emit(t);
                this.state = 32
            },
            canEmit: function() {
                for (var t = 0; t < this.requireFail.length;) {
                    if (!(this.requireFail[t].state & (32 | ae))) return !1;
                    t++
                }
                return !0
            },
            recognize: function(t) {
                var e = lt({}, t);
                if (!l(this.options.enable, [this, e])) return this.reset(), void(this.state = 32);
                this.state & (ce | de | 32) && (this.state = ae), this.state = this.process(e), this.state & (he | ue | le | de) && this.tryEmit(e)
            },
            process: function(t) {},
            getTouchAction: function() {},
            reset: function() {}
        }, h(K, G, {
            defaults: {
                pointers: 1
            },
            attrTest: function(t) {
                var e = this.options.pointers;
                return 0 === e || t.pointers.length === e
            },
            process: function(t) {
                var e = this.state,
                    i = t.eventType,
                    n = e & (he | ue),
                    r = this.attrTest(t);
                return n && (i & kt || !r) ? e | de : n || r ? i & zt ? e | le : e & he ? e | ue : he : 32
            }
        }), h(tt, K, {
            defaults: {
                event: "pan",
                threshold: 10,
                pointers: 1,
                direction: Ft
            },
            getTouchAction: function() {
                var t = this.options.direction,
                    e = [];
                return t & Lt && e.push(se), t & Nt && e.push(re), e
            },
            directionTest: function(t) {
                var e = this.options,
                    i = !0,
                    n = t.distance,
                    r = t.direction,
                    s = t.deltaX,
                    o = t.deltaY;
                return r & e.direction || (e.direction & Lt ? (r = 0 === s ? It : s < 0 ? At : Pt, i = s != this.pX, n = Math.abs(t.deltaX)) : (r = 0 === o ? It : o < 0 ? Mt : Ot, i = o != this.pY, n = Math.abs(t.deltaY))), t.direction = r, i && n > e.threshold && r & e.direction
            },
            attrTest: function(t) {
                return K.prototype.attrTest.call(this, t) && (this.state & he || !(this.state & he) && this.directionTest(t))
            },
            emit: function(t) {
                this.pX = t.deltaX, this.pY = t.deltaY;
                var e = J(t.direction);
                e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t)
            }
        }), h(et, K, {
            defaults: {
                event: "pinch",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function() {
                return [ne]
            },
            attrTest: function(t) {
                return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || this.state & he)
            },
            emit: function(t) {
                if (1 !== t.scale) {
                    var e = t.scale < 1 ? "in" : "out";
                    t.additionalEvent = this.options.event + e
                }
                this._super.emit.call(this, t)
            }
        }), h(it, G, {
            defaults: {
                event: "press",
                pointers: 1,
                time: 251,
                threshold: 9
            },
            getTouchAction: function() {
                return [ee]
            },
            process: function(t) {
                var e = this.options,
                    i = t.pointers.length === e.pointers,
                    n = t.distance < e.threshold,
                    s = t.deltaTime > e.time;
                if (this._input = t, !n || !i || t.eventType & (zt | kt) && !s) this.reset();
                else if (t.eventType & Tt) this.reset(), this._timer = r(function() {
                    this.state = ce, this.tryEmit()
                }, e.time, this);
                else if (t.eventType & zt) return ce;
                return 32
            },
            reset: function() {
                clearTimeout(this._timer)
            },
            emit: function(t) {
                this.state === ce && (t && t.eventType & zt ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = vt(), this.manager.emit(this.options.event, this._input)))
            }
        }), h(nt, K, {
            defaults: {
                event: "rotate",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function() {
                return [ne]
            },
            attrTest: function(t) {
                return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || this.state & he)
            }
        }), h(rt, K, {
            defaults: {
                event: "swipe",
                threshold: 10,
                velocity: .3,
                direction: Lt | Nt,
                pointers: 1
            },
            getTouchAction: function() {
                return tt.prototype.getTouchAction.call(this)
            },
            attrTest: function(t) {
                var e, i = this.options.direction;
                return i & (Lt | Nt) ? e = t.overallVelocity : i & Lt ? e = t.overallVelocityX : i & Nt && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && pt(e) > this.options.velocity && t.eventType & zt
            },
            emit: function(t) {
                var e = J(t.offsetDirection);
                e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t)
            }
        }), h(st, G, {
            defaults: {
                event: "tap",
                pointers: 1,
                taps: 1,
                interval: 300,
                time: 250,
                threshold: 9,
                posThreshold: 10
            },
            getTouchAction: function() {
                return [ie]
            },
            process: function(t) {
                var e = this.options,
                    i = t.pointers.length === e.pointers,
                    n = t.distance < e.threshold,
                    s = t.deltaTime < e.time;
                if (this.reset(), t.eventType & Tt && 0 === this.count) return this.failTimeout();
                if (n && s && i) {
                    if (t.eventType != zt) return this.failTimeout();
                    var o = !this.pTime || t.timeStamp - this.pTime < e.interval,
                        a = !this.pCenter || O(this.pCenter, t.center) < e.posThreshold;
                    this.pTime = t.timeStamp, this.pCenter = t.center, a && o ? this.count += 1 : this.count = 1, this._input = t;
                    if (0 === this.count % e.taps) return this.hasRequireFailures() ? (this._timer = r(function() {
                        this.state = ce, this.tryEmit()
                    }, e.interval, this), he) : ce
                }
                return 32
            },
            failTimeout: function() {
                return this._timer = r(function() {
                    this.state = 32
                }, this.options.interval, this), 32
            },
            reset: function() {
                clearTimeout(this._timer)
            },
            emit: function() {
                this.state == ce && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
            }
        }), ot.VERSION = "2.0.7", ot.defaults = {
            domEvents: !1,
            touchAction: "compute",
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [
                [nt, {
                    enable: !1
                }],
                [et, {
                        enable: !1
                    },
                    ["rotate"]
                ],
                [rt, {
                    direction: Lt
                }],
                [tt, {
                        direction: Lt
                    },
                    ["swipe"]
                ],
                [st],
                [st, {
                        event: "doubletap",
                        taps: 2
                    },
                    ["tap"]
                ],
                [it]
            ],
            cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
            }
        };
        at.prototype = {
            set: function(t) {
                return lt(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this
            },
            stop: function(t) {
                this.session.stopped = t ? 2 : 1
            },
            recognize: function(t) {
                var e = this.session;
                if (!e.stopped) {
                    this.touchAction.preventDefaults(t);
                    var i, n = this.recognizers,
                        r = e.curRecognizer;
                    (!r || r && r.state & ce) && (r = e.curRecognizer = null);
                    for (var s = 0; s < n.length;) i = n[s], 2 === e.stopped || r && i != r && !i.canRecognizeWith(r) ? i.reset() : i.recognize(t), !r && i.state & (he | ue | le) && (r = e.curRecognizer = i), s++
                }
            },
            get: function(t) {
                if (t instanceof G) return t;
                for (var e = this.recognizers, i = 0; i < e.length; i++)
                    if (e[i].options.event == t) return e[i];
                return null
            },
            add: function(t) {
                if (s(t, "add", this)) return this;
                var e = this.get(t.options.event);
                return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t
            },
            remove: function(t) {
                if (s(t, "remove", this)) return this;
                if (t = this.get(t)) {
                    var e = this.recognizers,
                        i = _(e, t); - 1 !== i && (e.splice(i, 1), this.touchAction.update())
                }
                return this
            },
            on: function(t, e) {
                if (t !== n && e !== n) {
                    var i = this.handlers;
                    return o(v(t), function(t) {
                        i[t] = i[t] || [], i[t].push(e)
                    }), this
                }
            },
            off: function(t, e) {
                if (t !== n) {
                    var i = this.handlers;
                    return o(v(t), function(t) {
                        e ? i[t] && i[t].splice(_(i[t], e), 1) : delete i[t]
                    }), this
                }
            },
            emit: function(t, e) {
                this.options.domEvents && ut(t, e);
                var i = this.handlers[t] && this.handlers[t].slice();
                if (i && i.length) {
                    e.type = t, e.preventDefault = function() {
                        e.srcEvent.preventDefault()
                    };
                    for (var n = 0; n < i.length;) i[n](e), n++
                }
            },
            destroy: function() {
                this.element && ht(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
            }
        }, lt(ot, {
            INPUT_START: Tt,
            INPUT_MOVE: Et,
            INPUT_END: zt,
            INPUT_CANCEL: kt,
            STATE_POSSIBLE: ae,
            STATE_BEGAN: he,
            STATE_CHANGED: ue,
            STATE_ENDED: le,
            STATE_RECOGNIZED: ce,
            STATE_CANCELLED: de,
            STATE_FAILED: 32,
            DIRECTION_NONE: It,
            DIRECTION_LEFT: At,
            DIRECTION_RIGHT: Pt,
            DIRECTION_UP: Mt,
            DIRECTION_DOWN: Ot,
            DIRECTION_HORIZONTAL: Lt,
            DIRECTION_VERTICAL: Nt,
            DIRECTION_ALL: Ft,
            Manager: at,
            Input: S,
            TouchAction: X,
            TouchInput: q,
            MouseInput: D,
            PointerEventInput: R,
            TouchMouseInput: W,
            SingleTouchInput: B,
            Recognizer: G,
            AttrRecognizer: K,
            Tap: st,
            Pan: tt,
            Swipe: rt,
            Pinch: et,
            Rotate: nt,
            Press: it,
            on: d,
            off: f,
            each: o,
            merge: mt,
            extend: _t,
            assign: lt,
            inherit: h,
            bindFn: u,
            prefixed: w
        }), (void 0 !== t ? t : "undefined" != typeof self ? self : {}).Hammer = ot, "function" == typeof define && define.amd ? define(function() {
            return ot
        }) : "undefined" != typeof module && module.exports ? module.exports = ot : t.Hammer = ot
    }(window, document),
    function(t, e) {
        "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], function(i) {
            return e(t, i)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("jquery")) : t.jQueryBridget = e(t, t.jQuery)
    }(window, function(t, e) {
        "use strict";

        function i(i, s, a) {
            function h(t, e, n) {
                var r, s = "$()." + i + '("' + e + '")';
                return t.each(function(t, h) {
                    var u = a.data(h, i);
                    if (!u) return void o(i + " not initialized. Cannot call methods, i.e. " + s);
                    var l = u[e];
                    if (!l || "_" == e.charAt(0)) return void o(s + " is not a valid method");
                    var c = l.apply(u, n);
                    r = void 0 === r ? c : r
                }), void 0 !== r ? r : t
            }

            function u(t, e) {
                t.each(function(t, n) {
                    var r = a.data(n, i);
                    r ? (r.option(e), r._init()) : (r = new s(n, e), a.data(n, i, r))
                })
            }(a = a || e || t.jQuery) && (s.prototype.option || (s.prototype.option = function(t) {
                a.isPlainObject(t) && (this.options = a.extend(!0, this.options, t))
            }), a.fn[i] = function(t) {
                if ("string" == typeof t) {
                    return h(this, t, r.call(arguments, 1))
                }
                return u(this, t), this
            }, n(a))
        }

        function n(t) {
            !t || t && t.bridget || (t.bridget = i)
        }
        var r = Array.prototype.slice,
            s = t.console,
            o = void 0 === s ? function() {} : function(t) {
                s.error(t)
            };
        return n(e || t.jQuery), i
    }),
    function(t, e) {
        "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", e) : "object" == typeof module && module.exports ? module.exports = e() : t.EvEmitter = e()
    }("undefined" != typeof window ? window : this, function() {
        function t() {}
        var e = t.prototype;
        return e.on = function(t, e) {
            if (t && e) {
                var i = this._events = this._events || {},
                    n = i[t] = i[t] || [];
                return -1 == n.indexOf(e) && n.push(e), this
            }
        }, e.once = function(t, e) {
            if (t && e) {
                this.on(t, e);
                var i = this._onceEvents = this._onceEvents || {};
                return (i[t] = i[t] || {})[e] = !0, this
            }
        }, e.off = function(t, e) {
            var i = this._events && this._events[t];
            if (i && i.length) {
                var n = i.indexOf(e);
                return -1 != n && i.splice(n, 1), this
            }
        }, e.emitEvent = function(t, e) {
            var i = this._events && this._events[t];
            if (i && i.length) {
                var n = 0,
                    r = i[n];
                e = e || [];
                for (var s = this._onceEvents && this._onceEvents[t]; r;) {
                    var o = s && s[r];
                    o && (this.off(t, r), delete s[r]), r.apply(this, e), n += o ? 0 : 1, r = i[n]
                }
                return this
            }
        }, t
    }),
    function(t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("get-size/get-size", [], function() {
            return e()
        }) : "object" == typeof module && module.exports ? module.exports = e() : t.getSize = e()
    }(window, function() {
        "use strict";

        function t(t) {
            var e = parseFloat(t);
            return -1 == t.indexOf("%") && !isNaN(e) && e
        }

        function e() {}

        function i() {
            for (var t = {
                    width: 0,
                    height: 0,
                    innerWidth: 0,
                    innerHeight: 0,
                    outerWidth: 0,
                    outerHeight: 0
                }, e = 0; e < u; e++) {
                t[h[e]] = 0
            }
            return t
        }

        function n(t) {
            var e = getComputedStyle(t);
            return e || a("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"), e
        }

        function r() {
            if (!l) {
                l = !0;
                var e = document.createElement("div");
                e.style.width = "200px", e.style.padding = "1px 2px 3px 4px", e.style.borderStyle = "solid", e.style.borderWidth = "1px 2px 3px 4px", e.style.boxSizing = "border-box";
                var i = document.body || document.documentElement;
                i.appendChild(e);
                var r = n(e);
                s.isBoxSizeOuter = o = 200 == t(r.width), i.removeChild(e)
            }
        }

        function s(e) {
            if (r(), "string" == typeof e && (e = document.querySelector(e)), e && "object" == typeof e && e.nodeType) {
                var s = n(e);
                if ("none" == s.display) return i();
                var a = {};
                a.width = e.offsetWidth, a.height = e.offsetHeight;
                for (var l = a.isBorderBox = "border-box" == s.boxSizing, c = 0; c < u; c++) {
                    var d = h[c],
                        f = s[d],
                        g = parseFloat(f);
                    a[d] = isNaN(g) ? 0 : g
                }
                var p = a.paddingLeft + a.paddingRight,
                    v = a.paddingTop + a.paddingBottom,
                    _ = a.marginLeft + a.marginRight,
                    m = a.marginTop + a.marginBottom,
                    y = a.borderLeftWidth + a.borderRightWidth,
                    w = a.borderTopWidth + a.borderBottomWidth,
                    x = l && o,
                    b = t(s.width);
                !1 !== b && (a.width = b + (x ? 0 : p + y));
                var S = t(s.height);
                return !1 !== S && (a.height = S + (x ? 0 : v + w)), a.innerWidth = a.width - (p + y), a.innerHeight = a.height - (v + w), a.outerWidth = a.width + _, a.outerHeight = a.height + m, a
            }
        }
        var o, a = "undefined" == typeof console ? e : function(t) {
                console.error(t)
            },
            h = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
            u = h.length,
            l = !1;
        return s
    }),
    function(t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", e) : "object" == typeof module && module.exports ? module.exports = e() : t.matchesSelector = e()
    }(window, function() {
        "use strict";
        var t = function() {
            var t = window.Element.prototype;
            if (t.matches) return "matches";
            if (t.matchesSelector) return "matchesSelector";
            for (var e = ["webkit", "moz", "ms", "o"], i = 0; i < e.length; i++) {
                var n = e[i],
                    r = n + "MatchesSelector";
                if (t[r]) return r
            }
        }();
        return function(e, i) {
            return e[t](i)
        }
    }),
    function(t, e) {
        "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function(i) {
            return e(t, i)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("desandro-matches-selector")) : t.fizzyUIUtils = e(t, t.matchesSelector)
    }(window, function(t, e) {
        var i = {};
        i.extend = function(t, e) {
            for (var i in e) t[i] = e[i];
            return t
        }, i.modulo = function(t, e) {
            return (t % e + e) % e
        }, i.makeArray = function(t) {
            var e = [];
            if (Array.isArray(t)) e = t;
            else if (t && "object" == typeof t && "number" == typeof t.length)
                for (var i = 0; i < t.length; i++) e.push(t[i]);
            else e.push(t);
            return e
        }, i.removeFrom = function(t, e) {
            var i = t.indexOf(e); - 1 != i && t.splice(i, 1)
        }, i.getParent = function(t, i) {
            for (; t != document.body;)
                if (t = t.parentNode, e(t, i)) return t
        }, i.getQueryElement = function(t) {
            return "string" == typeof t ? document.querySelector(t) : t
        }, i.handleEvent = function(t) {
            var e = "on" + t.type;
            this[e] && this[e](t)
        }, i.filterFindElements = function(t, n) {
            t = i.makeArray(t);
            var r = [];
            return t.forEach(function(t) {
                if (t instanceof HTMLElement) {
                    if (!n) return void r.push(t);
                    e(t, n) && r.push(t);
                    for (var i = t.querySelectorAll(n), s = 0; s < i.length; s++) r.push(i[s])
                }
            }), r
        }, i.debounceMethod = function(t, e, i) {
            var n = t.prototype[e],
                r = e + "Timeout";
            t.prototype[e] = function() {
                var t = this[r];
                t && clearTimeout(t);
                var e = arguments,
                    s = this;
                this[r] = setTimeout(function() {
                    n.apply(s, e), delete s[r]
                }, i || 100)
            }
        }, i.docReady = function(t) {
            var e = document.readyState;
            "complete" == e || "interactive" == e ? setTimeout(t) : document.addEventListener("DOMContentLoaded", t)
        }, i.toDashed = function(t) {
            return t.replace(/(.)([A-Z])/g, function(t, e, i) {
                return e + "-" + i
            }).toLowerCase()
        };
        var n = t.console;
        return i.htmlInit = function(e, r) {
            i.docReady(function() {
                var s = i.toDashed(r),
                    o = "data-" + s,
                    a = document.querySelectorAll("[" + o + "]"),
                    h = document.querySelectorAll(".js-" + s),
                    u = i.makeArray(a).concat(i.makeArray(h)),
                    l = o + "-options",
                    c = t.jQuery;
                u.forEach(function(t) {
                    var i, s = t.getAttribute(o) || t.getAttribute(l);
                    try {
                        i = s && JSON.parse(s)
                    } catch (e) {
                        return void(n && n.error("Error parsing " + o + " on " + t.className + ": " + e))
                    }
                    var a = new e(t, i);
                    c && c.data(t, r, a)
                })
            })
        }, i
    }),
    function(t, e) {
        "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], e) : "object" == typeof module && module.exports ? module.exports = e(require("ev-emitter"), require("get-size")) : (t.Outlayer = {}, t.Outlayer.Item = e(t.EvEmitter, t.getSize))
    }(window, function(t, e) {
        "use strict";

        function i(t) {
            for (var e in t) return !1;
            return null, !0
        }

        function n(t, e) {
            t && (this.element = t, this.layout = e, this.position = {
                x: 0,
                y: 0
            }, this._create())
        }
        var r = document.documentElement.style,
            s = "string" == typeof r.transition ? "transition" : "WebkitTransition",
            o = "string" == typeof r.transform ? "transform" : "WebkitTransform",
            a = {
                WebkitTransition: "webkitTransitionEnd",
                transition: "transitionend"
            }[s],
            h = {
                transform: o,
                transition: s,
                transitionDuration: s + "Duration",
                transitionProperty: s + "Property",
                transitionDelay: s + "Delay"
            },
            u = n.prototype = Object.create(t.prototype);
        u.constructor = n, u._create = function() {
            this._transn = {
                ingProperties: {},
                clean: {},
                onEnd: {}
            }, this.css({
                position: "absolute"
            })
        }, u.handleEvent = function(t) {
            var e = "on" + t.type;
            this[e] && this[e](t)
        }, u.getSize = function() {
            this.size = e(this.element)
        }, u.css = function(t) {
            var e = this.element.style;
            for (var i in t) {
                e[h[i] || i] = t[i]
            }
        }, u.getPosition = function() {
            var t = getComputedStyle(this.element),
                e = this.layout._getOption("originLeft"),
                i = this.layout._getOption("originTop"),
                n = t[e ? "left" : "right"],
                r = t[i ? "top" : "bottom"],
                s = this.layout.size,
                o = -1 != n.indexOf("%") ? parseFloat(n) / 100 * s.width : parseInt(n, 10),
                a = -1 != r.indexOf("%") ? parseFloat(r) / 100 * s.height : parseInt(r, 10);
            o = isNaN(o) ? 0 : o, a = isNaN(a) ? 0 : a, o -= e ? s.paddingLeft : s.paddingRight, a -= i ? s.paddingTop : s.paddingBottom, this.position.x = o, this.position.y = a
        }, u.layoutPosition = function() {
            var t = this.layout.size,
                e = {},
                i = this.layout._getOption("originLeft"),
                n = this.layout._getOption("originTop"),
                r = i ? "paddingLeft" : "paddingRight",
                s = i ? "left" : "right",
                o = i ? "right" : "left",
                a = this.position.x + t[r];
            e[s] = this.getXValue(a), e[o] = "";
            var h = n ? "paddingTop" : "paddingBottom",
                u = n ? "top" : "bottom",
                l = n ? "bottom" : "top",
                c = this.position.y + t[h];
            e[u] = this.getYValue(c), e[l] = "", this.css(e), this.emitEvent("layout", [this])
        }, u.getXValue = function(t) {
            var e = this.layout._getOption("horizontal");
            return this.layout.options.percentPosition && !e ? t / this.layout.size.width * 100 + "%" : t + "px"
        }, u.getYValue = function(t) {
            var e = this.layout._getOption("horizontal");
            return this.layout.options.percentPosition && e ? t / this.layout.size.height * 100 + "%" : t + "px"
        }, u._transitionTo = function(t, e) {
            this.getPosition();
            var i = this.position.x,
                n = this.position.y,
                r = parseInt(t, 10),
                s = parseInt(e, 10),
                o = r === this.position.x && s === this.position.y;
            if (this.setPosition(t, e), o && !this.isTransitioning) return void this.layoutPosition();
            var a = t - i,
                h = e - n,
                u = {};
            u.transform = this.getTranslate(a, h), this.transition({
                to: u,
                onTransitionEnd: {
                    transform: this.layoutPosition
                },
                isCleaning: !0
            })
        }, u.getTranslate = function(t, e) {
            var i = this.layout._getOption("originLeft"),
                n = this.layout._getOption("originTop");
            return t = i ? t : -t, e = n ? e : -e, "translate3d(" + t + "px, " + e + "px, 0)"
        }, u.goTo = function(t, e) {
            this.setPosition(t, e), this.layoutPosition()
        }, u.moveTo = u._transitionTo, u.setPosition = function(t, e) {
            this.position.x = parseInt(t, 10), this.position.y = parseInt(e, 10)
        }, u._nonTransition = function(t) {
            this.css(t.to), t.isCleaning && this._removeStyles(t.to);
            for (var e in t.onTransitionEnd) t.onTransitionEnd[e].call(this)
        }, u.transition = function(t) {
            if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(t);
            var e = this._transn;
            for (var i in t.onTransitionEnd) e.onEnd[i] = t.onTransitionEnd[i];
            for (i in t.to) e.ingProperties[i] = !0, t.isCleaning && (e.clean[i] = !0);
            if (t.from) {
                this.css(t.from);
                this.element.offsetHeight;
                null
            }
            this.enableTransition(t.to), this.css(t.to), this.isTransitioning = !0
        };
        var l = "opacity," + function(t) {
            return t.replace(/([A-Z])/g, function(t) {
                return "-" + t.toLowerCase()
            })
        }(o);
        u.enableTransition = function() {
            if (!this.isTransitioning) {
                var t = this.layout.options.transitionDuration;
                t = "number" == typeof t ? t + "ms" : t, this.css({
                    transitionProperty: l,
                    transitionDuration: t,
                    transitionDelay: this.staggerDelay || 0
                }), this.element.addEventListener(a, this, !1)
            }
        }, u.onwebkitTransitionEnd = function(t) {
            this.ontransitionend(t)
        }, u.onotransitionend = function(t) {
            this.ontransitionend(t)
        };
        var c = {
            "-webkit-transform": "transform"
        };
        u.ontransitionend = function(t) {
            if (t.target === this.element) {
                var e = this._transn,
                    n = c[t.propertyName] || t.propertyName;
                if (delete e.ingProperties[n], i(e.ingProperties) && this.disableTransition(), n in e.clean && (this.element.style[t.propertyName] = "", delete e.clean[n]), n in e.onEnd) {
                    e.onEnd[n].call(this), delete e.onEnd[n]
                }
                this.emitEvent("transitionEnd", [this])
            }
        }, u.disableTransition = function() {
            this.removeTransitionStyles(), this.element.removeEventListener(a, this, !1), this.isTransitioning = !1
        }, u._removeStyles = function(t) {
            var e = {};
            for (var i in t) e[i] = "";
            this.css(e)
        };
        var d = {
            transitionProperty: "",
            transitionDuration: "",
            transitionDelay: ""
        };
        return u.removeTransitionStyles = function() {
            this.css(d)
        }, u.stagger = function(t) {
            t = isNaN(t) ? 0 : t, this.staggerDelay = t + "ms"
        }, u.removeElem = function() {
            this.element.parentNode.removeChild(this.element), this.css({
                display: ""
            }), this.emitEvent("remove", [this])
        }, u.remove = function() {
            if (!s || !parseFloat(this.layout.options.transitionDuration)) return void this.removeElem();
            this.once("transitionEnd", function() {
                this.removeElem()
            }), this.hide()
        }, u.reveal = function() {
            delete this.isHidden, this.css({
                display: ""
            });
            var t = this.layout.options,
                e = {};
            e[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({
                from: t.hiddenStyle,
                to: t.visibleStyle,
                isCleaning: !0,
                onTransitionEnd: e
            })
        }, u.onRevealTransitionEnd = function() {
            this.isHidden || this.emitEvent("reveal")
        }, u.getHideRevealTransitionEndProperty = function(t) {
            var e = this.layout.options[t];
            if (e.opacity) return "opacity";
            for (var i in e) return i
        }, u.hide = function() {
            this.isHidden = !0, this.css({
                display: ""
            });
            var t = this.layout.options,
                e = {};
            e[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({
                from: t.visibleStyle,
                to: t.hiddenStyle,
                isCleaning: !0,
                onTransitionEnd: e
            })
        }, u.onHideTransitionEnd = function() {
            this.isHidden && (this.css({
                display: "none"
            }), this.emitEvent("hide"))
        }, u.destroy = function() {
            this.css({
                position: "",
                left: "",
                right: "",
                top: "",
                bottom: "",
                transition: "",
                transform: ""
            })
        }, n
    }),
    function(t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], function(i, n, r, s) {
            return e(t, i, n, r, s)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : t.Outlayer = e(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item)
    }(window, function(t, e, i, n, r) {
        "use strict";

        function s(t, e) {
            var i = n.getQueryElement(t);
            if (!i) return void(h && h.error("Bad element for " + this.constructor.namespace + ": " + (i || t)));
            this.element = i, u && (this.$element = u(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(e);
            var r = ++c;
            this.element.outlayerGUID = r, d[r] = this, this._create(), this._getOption("initLayout") && this.layout()
        }

        function o(t) {
            function e() {
                t.apply(this, arguments)
            }
            return e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e
        }

        function a(t) {
            if ("number" == typeof t) return t;
            var e = t.match(/(^\d*\.?\d*)(\w*)/),
                i = e && e[1],
                n = e && e[2];
            return i.length ? (i = parseFloat(i)) * (g[n] || 1) : 0
        }
        var h = t.console,
            u = t.jQuery,
            l = function() {},
            c = 0,
            d = {};
        s.namespace = "outlayer", s.Item = r, s.defaults = {
            containerStyle: {
                position: "relative"
            },
            initLayout: !0,
            originLeft: !0,
            originTop: !0,
            resize: !0,
            resizeContainer: !0,
            transitionDuration: "0.4s",
            hiddenStyle: {
                opacity: 0,
                transform: "scale(0.001)"
            },
            visibleStyle: {
                opacity: 1,
                transform: "scale(1)"
            }
        };
        var f = s.prototype;
        n.extend(f, e.prototype), f.option = function(t) {
            n.extend(this.options, t)
        }, f._getOption = function(t) {
            var e = this.constructor.compatOptions[t];
            return e && void 0 !== this.options[e] ? this.options[e] : this.options[t]
        }, s.compatOptions = {
            initLayout: "isInitLayout",
            horizontal: "isHorizontal",
            layoutInstant: "isLayoutInstant",
            originLeft: "isOriginLeft",
            originTop: "isOriginTop",
            resize: "isResizeBound",
            resizeContainer: "isResizingContainer"
        }, f._create = function() {
            this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize()
        }, f.reloadItems = function() {
            this.items = this._itemize(this.element.children)
        }, f._itemize = function(t) {
            for (var e = this._filterFindItemElements(t), i = this.constructor.Item, n = [], r = 0; r < e.length; r++) {
                var s = e[r],
                    o = new i(s, this);
                n.push(o)
            }
            return n
        }, f._filterFindItemElements = function(t) {
            return n.filterFindElements(t, this.options.itemSelector)
        }, f.getItemElements = function() {
            return this.items.map(function(t) {
                return t.element
            })
        }, f.layout = function() {
            this._resetLayout(), this._manageStamps();
            var t = this._getOption("layoutInstant"),
                e = void 0 !== t ? t : !this._isLayoutInited;
            this.layoutItems(this.items, e), this._isLayoutInited = !0
        }, f._init = f.layout, f._resetLayout = function() {
            this.getSize()
        }, f.getSize = function() {
            this.size = i(this.element)
        }, f._getMeasurement = function(t, e) {
            var n, r = this.options[t];
            r ? ("string" == typeof r ? n = this.element.querySelector(r) : r instanceof HTMLElement && (n = r), this[t] = n ? i(n)[e] : r) : this[t] = 0
        }, f.layoutItems = function(t, e) {
            t = this._getItemsForLayout(t), this._layoutItems(t, e), this._postLayout()
        }, f._getItemsForLayout = function(t) {
            return t.filter(function(t) {
                return !t.isIgnored
            })
        }, f._layoutItems = function(t, e) {
            if (this._emitCompleteOnItems("layout", t), t && t.length) {
                var i = [];
                t.forEach(function(t) {
                    var n = this._getItemLayoutPosition(t);
                    n.item = t, n.isInstant = e || t.isLayoutInstant, i.push(n)
                }, this), this._processLayoutQueue(i)
            }
        }, f._getItemLayoutPosition = function() {
            return {
                x: 0,
                y: 0
            }
        }, f._processLayoutQueue = function(t) {
            this.updateStagger(), t.forEach(function(t, e) {
                this._positionItem(t.item, t.x, t.y, t.isInstant, e)
            }, this)
        }, f.updateStagger = function() {
            var t = this.options.stagger;
            return null === t || void 0 === t ? void(this.stagger = 0) : (this.stagger = a(t), this.stagger)
        }, f._positionItem = function(t, e, i, n, r) {
            n ? t.goTo(e, i) : (t.stagger(r * this.stagger), t.moveTo(e, i))
        }, f._postLayout = function() {
            this.resizeContainer()
        }, f.resizeContainer = function() {
            if (this._getOption("resizeContainer")) {
                var t = this._getContainerSize();
                t && (this._setContainerMeasure(t.width, !0), this._setContainerMeasure(t.height, !1))
            }
        }, f._getContainerSize = l, f._setContainerMeasure = function(t, e) {
            if (void 0 !== t) {
                var i = this.size;
                i.isBorderBox && (t += e ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), t = Math.max(t, 0), this.element.style[e ? "width" : "height"] = t + "px"
            }
        }, f._emitCompleteOnItems = function(t, e) {
            function i() {
                r.dispatchEvent(t + "Complete", null, [e])
            }

            function n() {
                ++o == s && i()
            }
            var r = this,
                s = e.length;
            if (!e || !s) return void i();
            var o = 0;
            e.forEach(function(e) {
                e.once(t, n)
            })
        }, f.dispatchEvent = function(t, e, i) {
            var n = e ? [e].concat(i) : i;
            if (this.emitEvent(t, n), u)
                if (this.$element = this.$element || u(this.element), e) {
                    var r = u.Event(e);
                    r.type = t, this.$element.trigger(r, i)
                } else this.$element.trigger(t, i)
        }, f.ignore = function(t) {
            var e = this.getItem(t);
            e && (e.isIgnored = !0)
        }, f.unignore = function(t) {
            var e = this.getItem(t);
            e && delete e.isIgnored
        }, f.stamp = function(t) {
            (t = this._find(t)) && (this.stamps = this.stamps.concat(t), t.forEach(this.ignore, this))
        }, f.unstamp = function(t) {
            (t = this._find(t)) && t.forEach(function(t) {
                n.removeFrom(this.stamps, t), this.unignore(t)
            }, this)
        }, f._find = function(t) {
            if (t) return "string" == typeof t && (t = this.element.querySelectorAll(t)), t = n.makeArray(t)
        }, f._manageStamps = function() {
            this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this))
        }, f._getBoundingRect = function() {
            var t = this.element.getBoundingClientRect(),
                e = this.size;
            this._boundingRect = {
                left: t.left + e.paddingLeft + e.borderLeftWidth,
                top: t.top + e.paddingTop + e.borderTopWidth,
                right: t.right - (e.paddingRight + e.borderRightWidth),
                bottom: t.bottom - (e.paddingBottom + e.borderBottomWidth)
            }
        }, f._manageStamp = l, f._getElementOffset = function(t) {
            var e = t.getBoundingClientRect(),
                n = this._boundingRect,
                r = i(t);
            return {
                left: e.left - n.left - r.marginLeft,
                top: e.top - n.top - r.marginTop,
                right: n.right - e.right - r.marginRight,
                bottom: n.bottom - e.bottom - r.marginBottom
            }
        }, f.handleEvent = n.handleEvent, f.bindResize = function() {
            t.addEventListener("resize", this), this.isResizeBound = !0
        }, f.unbindResize = function() {
            t.removeEventListener("resize", this), this.isResizeBound = !1
        }, f.onresize = function() {
            this.resize()
        }, n.debounceMethod(s, "onresize", 100), f.resize = function() {
            this.isResizeBound && this.needsResizeLayout() && this.layout()
        }, f.needsResizeLayout = function() {
            var t = i(this.element);
            return this.size && t && t.innerWidth !== this.size.innerWidth
        }, f.addItems = function(t) {
            var e = this._itemize(t);
            return e.length && (this.items = this.items.concat(e)), e
        }, f.appended = function(t) {
            var e = this.addItems(t);
            e.length && (this.layoutItems(e, !0), this.reveal(e))
        }, f.prepended = function(t) {
            var e = this._itemize(t);
            if (e.length) {
                var i = this.items.slice(0);
                this.items = e.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(e, !0), this.reveal(e), this.layoutItems(i)
            }
        }, f.reveal = function(t) {
            if (this._emitCompleteOnItems("reveal", t), t && t.length) {
                var e = this.updateStagger();
                t.forEach(function(t, i) {
                    t.stagger(i * e), t.reveal()
                })
            }
        }, f.hide = function(t) {
            if (this._emitCompleteOnItems("hide", t), t && t.length) {
                var e = this.updateStagger();
                t.forEach(function(t, i) {
                    t.stagger(i * e), t.hide()
                })
            }
        }, f.revealItemElements = function(t) {
            var e = this.getItems(t);
            this.reveal(e)
        }, f.hideItemElements = function(t) {
            var e = this.getItems(t);
            this.hide(e)
        }, f.getItem = function(t) {
            for (var e = 0; e < this.items.length; e++) {
                var i = this.items[e];
                if (i.element == t) return i
            }
        }, f.getItems = function(t) {
            t = n.makeArray(t);
            var e = [];
            return t.forEach(function(t) {
                var i = this.getItem(t);
                i && e.push(i)
            }, this), e
        }, f.remove = function(t) {
            var e = this.getItems(t);
            this._emitCompleteOnItems("remove", e), e && e.length && e.forEach(function(t) {
                t.remove(), n.removeFrom(this.items, t)
            }, this)
        }, f.destroy = function() {
            var t = this.element.style;
            t.height = "", t.position = "", t.width = "", this.items.forEach(function(t) {
                t.destroy()
            }), this.unbindResize();
            var e = this.element.outlayerGUID;
            delete d[e], delete this.element.outlayerGUID, u && u.removeData(this.element, this.constructor.namespace)
        }, s.data = function(t) {
            t = n.getQueryElement(t);
            var e = t && t.outlayerGUID;
            return e && d[e]
        }, s.create = function(t, e) {
            var i = o(s);
            return i.defaults = n.extend({}, s.defaults), n.extend(i.defaults, e), i.compatOptions = n.extend({}, s.compatOptions), i.namespace = t, i.data = s.data, i.Item = o(r), n.htmlInit(i, t), u && u.bridget && u.bridget(t, i), i
        };
        var g = {
            ms: 1,
            s: 1e3
        };
        return s.Item = r, s
    }),
    function(t, e) {
        "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size"], e) : "object" == typeof module && module.exports ? module.exports = e(require("outlayer"), require("get-size")) : t.Masonry = e(t.Outlayer, t.getSize)
    }(window, function(t, e) {
        var i = t.create("masonry");
        i.compatOptions.fitWidth = "isFitWidth";
        var n = i.prototype;
        return n._resetLayout = function() {
            this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
            for (var t = 0; t < this.cols; t++) this.colYs.push(0);
            this.maxY = 0, this.horizontalColIndex = 0
        }, n.measureColumns = function() {
            if (this.getContainerWidth(), !this.columnWidth) {
                var t = this.items[0],
                    i = t && t.element;
                this.columnWidth = i && e(i).outerWidth || this.containerWidth
            }
            var n = this.columnWidth += this.gutter,
                r = this.containerWidth + this.gutter,
                s = r / n,
                o = n - r % n,
                a = o && o < 1 ? "round" : "floor";
            s = Math[a](s), this.cols = Math.max(s, 1)
        }, n.getContainerWidth = function() {
            var t = this._getOption("fitWidth"),
                i = t ? this.element.parentNode : this.element,
                n = e(i);
            this.containerWidth = n && n.innerWidth
        }, n._getItemLayoutPosition = function(t) {
            t.getSize();
            var e = t.size.outerWidth % this.columnWidth,
                i = e && e < 1 ? "round" : "ceil",
                n = Math[i](t.size.outerWidth / this.columnWidth);
            n = Math.min(n, this.cols);
            for (var r = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition", s = this[r](n, t), o = {
                    x: this.columnWidth * s.col,
                    y: s.y
                }, a = s.y + t.size.outerHeight, h = n + s.col, u = s.col; u < h; u++) this.colYs[u] = a;
            return o
        }, n._getTopColPosition = function(t) {
            var e = this._getTopColGroup(t),
                i = Math.min.apply(Math, e);
            return {
                col: e.indexOf(i),
                y: i
            }
        }, n._getTopColGroup = function(t) {
            if (t < 2) return this.colYs;
            for (var e = [], i = this.cols + 1 - t, n = 0; n < i; n++) e[n] = this._getColGroupY(n, t);
            return e
        }, n._getColGroupY = function(t, e) {
            if (e < 2) return this.colYs[t];
            var i = this.colYs.slice(t, t + e);
            return Math.max.apply(Math, i)
        }, n._getHorizontalColPosition = function(t, e) {
            var i = this.horizontalColIndex % this.cols;
            i = t > 1 && i + t > this.cols ? 0 : i;
            var n = e.size.outerWidth && e.size.outerHeight;
            return this.horizontalColIndex = n ? i + t : this.horizontalColIndex, {
                col: i,
                y: this._getColGroupY(i, t)
            }
        }, n._manageStamp = function(t) {
            var i = e(t),
                n = this._getElementOffset(t),
                r = this._getOption("originLeft"),
                s = r ? n.left : n.right,
                o = s + i.outerWidth,
                a = Math.floor(s / this.columnWidth);
            a = Math.max(0, a);
            var h = Math.floor(o / this.columnWidth);
            h -= o % this.columnWidth ? 0 : 1, h = Math.min(this.cols - 1, h);
            for (var u = this._getOption("originTop"), l = (u ? n.top : n.bottom) + i.outerHeight, c = a; c <= h; c++) this.colYs[c] = Math.max(l, this.colYs[c])
        }, n._getContainerSize = function() {
            this.maxY = Math.max.apply(Math, this.colYs);
            var t = {
                height: this.maxY
            };
            return this._getOption("fitWidth") && (t.width = this._getContainerFitWidth()), t
        }, n._getContainerFitWidth = function() {
            for (var t = 0, e = this.cols; --e && 0 === this.colYs[e];) t++;
            return (this.cols - t) * this.columnWidth - this.gutter
        }, n.needsResizeLayout = function() {
            var t = this.containerWidth;
            return this.getContainerWidth(), t != this.containerWidth
        }, i
    }),
    function(t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? module.exports = e() : t.MediaBox = e()
    }(this, function() {
        "use strict";
        var t = function(e) {
            return this && this instanceof t ? !!e && (this.selector = e instanceof NodeList ? e : document.querySelectorAll(e), this.root = document.querySelector("body"), void this.run()) : new t(e)
        };
        return t.prototype = {
            run: function() {
                Array.prototype.forEach.call(this.selector, function(t) {
                    t.addEventListener("click", function(e) {
                        e.preventDefault();
                        var i = this.parseUrl(t.getAttribute("href"));
                        this.render(i), this.events()
                    }.bind(this), !1)
                }.bind(this)), this.root.addEventListener("keyup", function(t) {
                    27 === (t.keyCode || t.which) && this.close(this.root.querySelector(".mediabox-wrap"))
                }.bind(this), !1)
            },
            template: function(t, e) {
                var i;
                for (i in e) e.hasOwnProperty(i) && (t = t.replace(new RegExp("{" + i + "}", "g"), e[i]));
                return t
            },
            parseUrl: function(t) {
                var e, i = {};
                return (e = t.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/)) ? (i.provider = "youtube", i.id = e[2]) : (e = t.match(/https?:\/\/(?:www\.)?vimeo.com\/(?:channels\/|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|)(\d+)(?:$|\/|\?)/)) ? (i.provider = "vimeo", i.id = e[3]) : (i.provider = "Unknown", i.id = ""), i
            },
            render: function(t) {
                var e, i;
                if ("youtube" === t.provider) e = "https://www.youtube.com/embed/" + t.id;
                else {
                    if ("vimeo" !== t.provider) throw new Error("Invalid video URL");
                    e = "https://player.vimeo.com/video/" + t.id
                }
                i = this.template('<div class="mediabox-wrap" role="dialog" aria-hidden="false"><div class="mediabox-content" role="document" tabindex="0"><span class="mediabox-close" aria-label="close"></span><iframe src="{embed}?autoplay=1" frameborder="0" allowfullscreen></iframe></div></div>', {
                    embed: e
                }), this.root.insertAdjacentHTML("beforeend", i)
            },
            events: function() {
                var t = document.querySelector(".mediabox-wrap");
                t.addEventListener("click", function(e) {
                    (e.target && "SPAN" === e.target.nodeName && "mediabox-close" === e.target.className || "DIV" === e.target.nodeName && "mediabox-wrap" === e.target.className) && this.close(t)
                }.bind(this), !1)
            },
            close: function(t) {
                if (null === t) return !0;
                var e = null;
                e && clearTimeout(e), t.classList.add("mediabox-hide"), e = setTimeout(function() {
                    var t = document.querySelector(".mediabox-wrap");
                    null !== t && this.root.removeChild(t)
                }.bind(this), 500)
            }
        }, t
    }),
    function(t, e) {
        t.IS_TOUCH_DEVICE = function() {
            "use strict";
            try {
                return "ontouchstart" in window || navigator.maxTouchPoints
            } catch (t) {
                return !1
            }
        }()
    }(this), ResizeSensor = function(t, e) {
        function i() {
            this.q = [], this.add = function(t) {
                this.q.push(t)
            };
            var t, e;
            this.call = function() {
                for (t = 0, e = this.q.length; t < e; t++) this.q[t].call()
            }
        }

        function n(t, e) {
            return t.currentStyle ? t.currentStyle[e] : window.getComputedStyle ? window.getComputedStyle(t, null).getPropertyValue(e) : t.style[e]
        }

        function r(t, e) {
            if (t.resizedAttached) {
                if (t.resizedAttached) return void t.resizedAttached.add(e)
            } else t.resizedAttached = new i, t.resizedAttached.add(e);
            t.resizeSensor = document.createElement("div"), t.resizeSensor.className = "resize-sensor";
            var r = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;",
                s = "position: absolute; left: 0; top: 0;";
            t.resizeSensor.style.cssText = r, t.resizeSensor.innerHTML = '<div class="resize-sensor-expand" style="' + r + '"><div style="' + s + '"></div></div><div class="resize-sensor-shrink" style="' + r + '"><div style="' + s + ' width: 200%; height: 200%"></div></div>', t.appendChild(t.resizeSensor), {
                fixed: 1,
                absolute: 1
            }[n(t, "position")] || (t.style.position = "relative");
            var o, a, h = t.resizeSensor.childNodes[0],
                u = h.childNodes[0],
                l = t.resizeSensor.childNodes[1],
                c = (l.childNodes[0], function() {
                    u.style.width = h.offsetWidth + 10 + "px", u.style.height = h.offsetHeight + 10 + "px", h.scrollLeft = h.scrollWidth, h.scrollTop = h.scrollHeight, l.scrollLeft = l.scrollWidth, l.scrollTop = l.scrollHeight, o = t.offsetWidth, a = t.offsetHeight
                });
            c();
            var d = function() {
                    t.resizedAttached && t.resizedAttached.call()
                },
                f = function(t, e, i) {
                    t.attachEvent ? t.attachEvent("on" + e, i) : t.addEventListener(e, i)
                };
            f(h, "scroll", function() {
                (t.offsetWidth > o || t.offsetHeight > a) && d(), c()
            }), f(l, "scroll", function() {
                (t.offsetWidth < o || t.offsetHeight < a) && d(), c()
            })
        }
        if ("[object Array]" === Object.prototype.toString.call(t) || "undefined" != typeof jQuery && t instanceof jQuery || "undefined" != typeof Elements && t instanceof Elements)
            for (var s = 0, o = t.length; s < o; s++) r(t[s], e);
        else r(t, e);
        this.detach = function() {
            ResizeSensor.detach(t)
        }
    }, ResizeSensor.detach = function(t) {
        t.resizeSensor && (t.removeChild(t.resizeSensor), delete t.resizeSensor, delete t.resizedAttached)
    },
    function(t, e) {
        "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("Siema", [], e) : "object" == typeof exports ? exports.Siema = e() : t.Siema = e()
    }(this, function() {
        return function(t) {
            function e(n) {
                if (i[n]) return i[n].exports;
                var r = i[n] = {
                    i: n,
                    l: !1,
                    exports: {}
                };
                return t[n].call(r.exports, r, r.exports, e), r.l = !0, r.exports
            }
            var i = {};
            return e.m = t, e.c = i, e.i = function(t) {
                return t
            }, e.d = function(t, i, n) {
                e.o(t, i) || Object.defineProperty(t, i, {
                    configurable: !1,
                    enumerable: !0,
                    get: n
                })
            }, e.n = function(t) {
                var i = t && t.__esModule ? function() {
                    return t.default
                } : function() {
                    return t
                };
                return e.d(i, "a", i), i
            }, e.o = function(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, e.p = "", e(e.s = 0)
        }([function(t, e, i) {
            "use strict";

            function n(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                    return typeof t
                } : function(t) {
                    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                },
                s = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                o = function() {
                    function t(e) {
                        var i = this;
                        n(this, t), this.config = t.mergeSettings(e), this.selector = "string" == typeof this.config.selector ? document.querySelector(this.config.selector) : this.config.selector, this.selectorWidth = this.selector.offsetWidth, this.innerElements = [].slice.call(this.selector.children), this.currentSlide = this.config.startIndex, this.transformProperty = t.webkitOrNot(), ["resizeHandler", "touchstartHandler", "touchendHandler", "touchmoveHandler", "mousedownHandler", "mouseupHandler", "mouseleaveHandler", "mousemoveHandler"].forEach(function(t) {
                            i[t] = i[t].bind(i)
                        }), this.init()
                    }
                    return s(t, [{
                        key: "init",
                        value: function() {
                            if (window.addEventListener("resize", this.resizeHandler), this.config.draggable && (this.pointerDown = !1, this.drag = {
                                    startX: 0,
                                    endX: 0,
                                    startY: 0,
                                    letItGo: null
                                }, this.selector.addEventListener("touchstart", this.touchstartHandler), this.selector.addEventListener("touchend", this.touchendHandler), this.selector.addEventListener("touchmove", this.touchmoveHandler, {
                                    passive: !0
                                }), this.selector.addEventListener("mousedown", this.mousedownHandler), this.selector.addEventListener("mouseup", this.mouseupHandler), this.selector.addEventListener("mouseleave", this.mouseleaveHandler), this.selector.addEventListener("mousemove", this.mousemoveHandler)), null === this.selector) throw new Error("Something wrong with your selector ");
                            this.resolveSlidesNumber(), this.selector.style.overflow = "hidden", this.sliderFrame = document.createElement("div"), this.sliderFrame.style.width = this.selectorWidth / this.perPage * this.innerElements.length + "px", this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing, this.config.draggable && (this.selector.style.cursor = "-webkit-grab");
                            for (var t = document.createDocumentFragment(), e = 0; e < this.innerElements.length; e++) {
                                var i = document.createElement("div");
                                i.style.cssFloat = "left", i.style.float = "left", i.style.width = 100 / this.innerElements.length + "%", i.appendChild(this.innerElements[e]), t.appendChild(i)
                            }
                            this.sliderFrame.appendChild(t), this.selector.innerHTML = "", this.selector.appendChild(this.sliderFrame), this.slideToCurrent(), this.config.onInit.call(this)
                        }
                    }, {
                        key: "resolveSlidesNumber",
                        value: function() {
                            if ("number" == typeof this.config.perPage) this.perPage = this.config.perPage;
                            else if ("object" === r(this.config.perPage)) {
                                this.perPage = 1;
                                for (var t in this.config.perPage) window.innerWidth >= t && (this.perPage = this.config.perPage[t])
                            }
                        }
                    }, {
                        key: "prev",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                e = arguments[1];
                            if (!(this.innerElements.length <= this.perPage)) {
                                var i = this.currentSlide;
                                0 === this.currentSlide && this.config.loop ? this.currentSlide = this.innerElements.length - this.perPage : this.currentSlide = Math.max(this.currentSlide - t, 0), i !== this.currentSlide && (this.slideToCurrent(), this.config.onChange.call(this), e && e.call(this))
                            }
                        }
                    }, {
                        key: "next",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                e = arguments[1];
                            if (!(this.innerElements.length <= this.perPage)) {
                                var i = this.currentSlide;
                                this.currentSlide === this.innerElements.length - this.perPage && this.config.loop ? this.currentSlide = 0 : this.currentSlide = Math.min(this.currentSlide + t, this.innerElements.length - this.perPage), i !== this.currentSlide && (this.slideToCurrent(), this.config.onChange.call(this), e && e.call(this))
                            }
                        }
                    }, {
                        key: "goTo",
                        value: function(t, e) {
                            this.innerElements.length <= this.perPage || (this.currentSlide = Math.min(Math.max(t, 0), this.innerElements.length - this.perPage), this.slideToCurrent(), e && e.call(this))
                        }
                    }, {
                        key: "slideToCurrent",
                        value: function() {
                            this.sliderFrame.style[this.transformProperty] = "translate3d(-" + this.currentSlide * (this.selectorWidth / this.perPage) + "px, 0, 0)"
                        }
                    }, {
                        key: "updateAfterDrag",
                        value: function() {
                            var t = this.drag.endX - this.drag.startX,
                                e = Math.abs(t),
                                i = Math.ceil(e / (this.selectorWidth / this.perPage));
                            t > 0 && e > this.config.threshold && this.innerElements.length > this.perPage ? this.prev(i) : t < 0 && e > this.config.threshold && this.innerElements.length > this.perPage && this.next(i), this.slideToCurrent()
                        }
                    }, {
                        key: "resizeHandler",
                        value: function() {
                            this.resolveSlidesNumber(), this.selectorWidth = this.selector.offsetWidth, this.sliderFrame.style.width = this.selectorWidth / this.perPage * this.innerElements.length + "px", this.slideToCurrent()
                        }
                    }, {
                        key: "clearDrag",
                        value: function() {
                            this.drag = {
                                startX: 0,
                                endX: 0,
                                startY: 0,
                                letItGo: null
                            }
                        }
                    }, {
                        key: "touchstartHandler",
                        value: function(t) {
                            t.stopPropagation(), this.pointerDown = !0, this.drag.startX = t.touches[0].pageX, this.drag.startY = t.touches[0].pageY
                        }
                    }, {
                        key: "touchendHandler",
                        value: function(t) {
                            t.stopPropagation(), this.pointerDown = !1, this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing, this.drag.endX && this.updateAfterDrag(), this.clearDrag()
                        }
                    }, {
                        key: "touchmoveHandler",
                        value: function(t) {
                            t.stopPropagation(), null === this.drag.letItGo && (this.drag.letItGo = Math.abs(this.drag.startY - t.touches[0].pageY) < Math.abs(this.drag.startX - t.touches[0].pageX)), this.pointerDown && this.drag.letItGo && (this.drag.endX = t.touches[0].pageX, this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing, this.sliderFrame.style[this.transformProperty] = "translate3d(" + -1 * (this.currentSlide * (this.selectorWidth / this.perPage) + (this.drag.startX - this.drag.endX)) + "px, 0, 0)")
                        }
                    }, {
                        key: "mousedownHandler",
                        value: function(t) {
                            t.preventDefault(), t.stopPropagation(), this.pointerDown = !0, this.drag.startX = t.pageX
                        }
                    }, {
                        key: "mouseupHandler",
                        value: function(t) {
                            t.stopPropagation(), this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing, this.drag.endX && this.updateAfterDrag(), this.clearDrag()
                        }
                    }, {
                        key: "mousemoveHandler",
                        value: function(t) {
                            t.preventDefault(), this.pointerDown && (this.drag.endX = t.pageX, this.selector.style.cursor = "-webkit-grabbing", this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing, this.sliderFrame.style[this.transformProperty] = "translate3d(" + -1 * (this.currentSlide * (this.selectorWidth / this.perPage) + (this.drag.startX - this.drag.endX)) + "px, 0, 0)")
                        }
                    }, {
                        key: "mouseleaveHandler",
                        value: function(t) {
                            this.pointerDown && (this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.drag.endX = t.pageX, this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing, this.updateAfterDrag(), this.clearDrag())
                        }
                    }, {
                        key: "updateFrame",
                        value: function() {
                            this.sliderFrame = document.createElement("div"), this.sliderFrame.style.width = this.selectorWidth / this.perPage * this.innerElements.length + "px", this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing, this.config.draggable && (this.selector.style.cursor = "-webkit-grab");
                            for (var t = document.createDocumentFragment(), e = 0; e < this.innerElements.length; e++) {
                                var i = document.createElement("div");
                                i.style.cssFloat = "left", i.style.float = "left", i.style.width = 100 / this.innerElements.length + "%", i.appendChild(this.innerElements[e]), t.appendChild(i)
                            }
                            this.sliderFrame.appendChild(t), this.selector.innerHTML = "", this.selector.appendChild(this.sliderFrame), this.slideToCurrent()
                        }
                    }, {
                        key: "remove",
                        value: function(t, e) {
                            if (t < 0 || t > this.innerElements.length) throw new Error("Item to remove doesn't exist ");
                            this.innerElements.splice(t, 1), this.currentSlide = t < this.currentSlide ? this.currentSlide - 1 : this.currentSlide, this.updateFrame(), e && e.call(this)
                        }
                    }, {
                        key: "insert",
                        value: function(t, e, i) {
                            if (e < 0 || e > this.innerElements.length + 1) throw new Error("Unable to inset it at this index ");
                            if (-1 !== this.innerElements.indexOf(t)) throw new Error("The same item in a carousel? Really? Nope ");
                            this.innerElements.splice(e, 0, t), this.currentSlide = e <= this.currentSlide ? this.currentSlide + 1 : this.currentSlide, this.updateFrame(), i && i.call(this)
                        }
                    }, {
                        key: "prepend",
                        value: function(t, e) {
                            this.insert(t, 0), e && e.call(this)
                        }
                    }, {
                        key: "append",
                        value: function(t, e) {
                            this.insert(t, this.innerElements.length + 1), e && e.call(this)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                e = arguments[1];
                            if (window.removeEventListener("resize", this.resizeHandler), this.selector.style.cursor = "auto", this.selector.removeEventListener("touchstart", this.touchstartHandler), this.selector.removeEventListener("touchend", this.touchendHandler), this.selector.removeEventListener("touchmove", this.touchmoveHandler), this.selector.removeEventListener("mousedown", this.mousedownHandler), this.selector.removeEventListener("mouseup", this.mouseupHandler), this.selector.removeEventListener("mouseleave", this.mouseleaveHandler), this.selector.removeEventListener("mousemove", this.mousemoveHandler), t) {
                                for (var i = document.createDocumentFragment(), n = 0; n < this.innerElements.length; n++) i.appendChild(this.innerElements[n]);
                                this.selector.innerHTML = "", this.selector.appendChild(i), this.selector.removeAttribute("style")
                            }
                            e && e.call(this)
                        }
                    }], [{
                        key: "mergeSettings",
                        value: function(t) {
                            var e = {
                                    selector: ".siema",
                                    duration: 200,
                                    easing: "ease-out",
                                    perPage: 1,
                                    startIndex: 0,
                                    draggable: !0,
                                    threshold: 20,
                                    loop: !1,
                                    onInit: function() {},
                                    onChange: function() {}
                                },
                                i = t;
                            for (var n in i) e[n] = i[n];
                            return e
                        }
                    }, {
                        key: "webkitOrNot",
                        value: function() {
                            return "string" == typeof document.documentElement.style.transform ? "transform" : "WebkitTransform"
                        }
                    }]), t
                }();
            e.default = o, t.exports = e.default
        }])
    }),
    function(t, e) {
        var i = function(t, e) {
            "use strict";
            if (e.getElementsByClassName) {
                var i, n, r = e.documentElement,
                    s = t.Date,
                    o = t.HTMLPictureElement,
                    a = t.addEventListener,
                    h = t.setTimeout,
                    u = t.requestAnimationFrame || h,
                    l = t.requestIdleCallback,
                    c = /^picture$/i,
                    d = ["load", "error", "lazyincluded", "_lazyloaded"],
                    f = {},
                    g = Array.prototype.forEach,
                    p = function(t, e) {
                        return f[e] || (f[e] = new RegExp("(\\s|^)" + e + "(\\s|$)")), f[e].test(t.getAttribute("class") || "") && f[e]
                    },
                    v = function(t, e) {
                        p(t, e) || t.setAttribute("class", (t.getAttribute("class") || "").trim() + " " + e)
                    },
                    _ = function(t, e) {
                        var i;
                        (i = p(t, e)) && t.setAttribute("class", (t.getAttribute("class") || "").replace(i, " "))
                    },
                    m = function(t, e, i) {
                        var n = i ? "addEventListener" : "removeEventListener";
                        i && m(t, e), d.forEach(function(i) {
                            t[n](i, e)
                        })
                    },
                    y = function(t, n, r, s, o) {
                        var a = e.createEvent("CustomEvent");
                        return r || (r = {}), r.instance = i, a.initCustomEvent(n, !s, !o, r), t.dispatchEvent(a), a
                    },
                    w = function(e, i) {
                        var r;
                        !o && (r = t.picturefill || n.pf) ? r({
                            reevaluate: !0,
                            elements: [e]
                        }) : i && i.src && (e.src = i.src)
                    },
                    x = function(t, e) {
                        return (getComputedStyle(t, null) || {})[e]
                    },
                    b = function(t, e, i) {
                        for (i = i || t.offsetWidth; i < n.minSize && e && !t._lazysizesWidth;) i = e.offsetWidth, e = e.parentNode;
                        return i
                    },
                    S = function() {
                        var t, i, n = [],
                            r = [],
                            s = n,
                            o = function() {
                                var e = s;
                                for (s = n.length ? r : n, t = !0, i = !1; e.length;) e.shift()();
                                t = !1
                            },
                            a = function(n, r) {
                                t && !r ? n.apply(this, arguments) : (s.push(n), i || (i = !0, (e.hidden ? h : u)(o)))
                            };
                        return a._lsFlush = o, a
                    }(),
                    C = function(t, e) {
                        return e ? function() {
                            S(t)
                        } : function() {
                            var e = this,
                                i = arguments;
                            S(function() {
                                t.apply(e, i)
                            })
                        }
                    },
                    T = function(t) {
                        var e, i = 0,
                            n = 666,
                            r = function() {
                                e = !1, i = s.now(), t()
                            },
                            o = l ? function() {
                                l(r, {
                                    timeout: n
                                }), 666 !== n && (n = 666)
                            } : C(function() {
                                h(r)
                            }, !0);
                        return function(t) {
                            var r;
                            (t = !0 === t) && (n = 44), e || (e = !0, r = 125 - (s.now() - i), r < 0 && (r = 0), t || r < 9 && l ? o() : h(o, r))
                        }
                    },
                    E = function(t) {
                        var e, i, n = function() {
                                e = null, t()
                            },
                            r = function() {
                                var t = s.now() - i;
                                t < 99 ? h(r, 99 - t) : (l || n)(n)
                            };
                        return function() {
                            i = s.now(), e || (e = h(r, 99))
                        }
                    },
                    z = function() {
                        var i, o, u, l, d, f, b, z, I, A, P, M, O, L, N, F = /^img$/i,
                            D = /^iframe$/i,
                            R = "onscroll" in t && !/glebot/.test(navigator.userAgent),
                            B = 0,
                            j = 0,
                            q = -1,
                            H = function(t) {
                                j--, t && t.target && m(t.target, H), (!t || j < 0 || !t.target) && (j = 0)
                            },
                            W = function(t, i) {
                                var n, s = t,
                                    o = "hidden" == x(e.body, "visibility") || "hidden" != x(t, "visibility");
                                for (I -= i, M += i, A -= i, P += i; o && (s = s.offsetParent) && s != e.body && s != r;)(o = (x(s, "opacity") || 1) > 0) && "visible" != x(s, "overflow") && (n = s.getBoundingClientRect(), o = P > n.left && A < n.right && M > n.top - 1 && I < n.bottom + 1);
                                return o
                            },
                            V = function() {
                                var t, s, a, h, l, c, f, g, p;
                                if ((d = n.loadMode) && j < 8 && (t = i.length)) {
                                    s = 0, q++, null == L && ("expand" in n || (n.expand = r.clientHeight > 500 && r.clientWidth > 500 ? 500 : 370), O = n.expand, L = O * n.expFactor), B < L && j < 1 && q > 2 && d > 2 && !e.hidden ? (B = L, q = 0) : B = d > 1 && q > 1 && j < 6 ? O : 0;
                                    for (; s < t; s++)
                                        if (i[s] && !i[s]._lazyRace)
                                            if (R)
                                                if ((g = i[s].getAttribute("data-expand")) && (c = 1 * g) || (c = B), p !== c && (b = innerWidth + c * N, z = innerHeight + c, f = -1 * c, p = c), a = i[s].getBoundingClientRect(), (M = a.bottom) >= f && (I = a.top) <= z && (P = a.right) >= f * N && (A = a.left) <= b && (M || P || A || I) && (n.loadHidden || "hidden" != x(i[s], "visibility")) && (u && j < 3 && !g && (d < 3 || q < 4) || W(i[s], c))) {
                                                    if (Q(i[s]), l = !0, j > 9) break
                                                } else !l && u && !h && j < 4 && q < 4 && d > 2 && (o[0] || n.preloadAfterLoad) && (o[0] || !g && (M || P || A || I || "auto" != i[s].getAttribute(n.sizesAttr))) && (h = o[0] || i[s]);
                                    else Q(i[s]);
                                    h && !l && Q(h)
                                }
                            },
                            U = T(V),
                            Y = function(t) {
                                v(t.target, n.loadedClass), _(t.target, n.loadingClass), m(t.target, Z)
                            },
                            X = C(Y),
                            Z = function(t) {
                                X({
                                    target: t.target
                                })
                            },
                            G = function(t, e) {
                                try {
                                    t.contentWindow.location.replace(e)
                                } catch (i) {
                                    t.src = e
                                }
                            },
                            $ = function(t) {
                                var e, i = t.getAttribute(n.srcsetAttr);
                                (e = n.customMedia[t.getAttribute("data-media") || t.getAttribute("media")]) && t.setAttribute("media", e), i && t.setAttribute("srcset", i)
                            },
                            J = C(function(t, e, i, r, s) {
                                var o, a, u, d, f, p;
                                (f = y(t, "lazybeforeunveil", e)).defaultPrevented || (r && (i ? v(t, n.autosizesClass) : t.setAttribute("sizes", r)), a = t.getAttribute(n.srcsetAttr), o = t.getAttribute(n.srcAttr), s && (u = t.parentNode, d = u && c.test(u.nodeName || "")), p = e.firesLoad || "src" in t && (a || o || d), f = {
                                    target: t
                                }, p && (m(t, H, !0), clearTimeout(l), l = h(H, 2500), v(t, n.loadingClass), m(t, Z, !0)), d && g.call(u.getElementsByTagName("source"), $), a ? t.setAttribute("srcset", a) : o && !d && (D.test(t.nodeName) ? G(t, o) : t.src = o), s && (a || d) && w(t, {
                                    src: o
                                })), t._lazyRace && delete t._lazyRace, _(t, n.lazyClass), S(function() {
                                    (!p || t.complete && t.naturalWidth > 1) && (p ? H(f) : j--, Y(f))
                                }, !0)
                            }),
                            Q = function(t) {
                                var e, i = F.test(t.nodeName),
                                    r = i && (t.getAttribute(n.sizesAttr) || t.getAttribute("sizes")),
                                    s = "auto" == r;
                                (!s && u || !i || !t.src && !t.srcset || t.complete || p(t, n.errorClass)) && (e = y(t, "lazyunveilread").detail, s && k.updateElem(t, !0, t.offsetWidth), t._lazyRace = !0, j++, J(t, e, s, r, i))
                            },
                            K = function() {
                                if (!u) {
                                    if (s.now() - f < 999) return void h(K, 999);
                                    var t = E(function() {
                                        n.loadMode = 3, U()
                                    });
                                    u = !0, n.loadMode = 3, U(), a("scroll", function() {
                                        3 == n.loadMode && (n.loadMode = 2), t()
                                    }, !0)
                                }
                            };
                        return {
                            _: function() {
                                f = s.now(), i = e.getElementsByClassName(n.lazyClass), o = e.getElementsByClassName(n.lazyClass + " " + n.preloadClass), N = n.hFac, a("scroll", U, !0), a("resize", U, !0), t.MutationObserver ? new MutationObserver(U).observe(r, {
                                    childList: !0,
                                    subtree: !0,
                                    attributes: !0
                                }) : (r.addEventListener("DOMNodeInserted", U, !0), r.addEventListener("DOMAttrModified", U, !0), setInterval(U, 999)), a("hashchange", U, !0), ["focus", "mouseover", "click", "load", "transitionend", "animationend", "webkitAnimationEnd"].forEach(function(t) {
                                    e.addEventListener(t, U, !0)
                                }), /d$|^c/.test(e.readyState) ? K() : (a("load", K), e.addEventListener("DOMContentLoaded", U), h(K, 2e4)), i.length ? (V(), S._lsFlush()) : U()
                            },
                            checkElems: U,
                            unveil: Q
                        }
                    }(),
                    k = function() {
                        var t, i = C(function(t, e, i, n) {
                                var r, s, o;
                                if (t._lazysizesWidth = n, n += "px", t.setAttribute("sizes", n), c.test(e.nodeName || ""))
                                    for (r = e.getElementsByTagName("source"), s = 0, o = r.length; s < o; s++) r[s].setAttribute("sizes", n);
                                i.detail.dataAttr || w(t, i.detail)
                            }),
                            r = function(t, e, n) {
                                var r, s = t.parentNode;
                                s && (n = b(t, s, n), r = y(t, "lazybeforesizes", {
                                    width: n,
                                    dataAttr: !!e
                                }), r.defaultPrevented || (n = r.detail.width) && n !== t._lazysizesWidth && i(t, s, r, n))
                            },
                            s = function() {
                                var e, i = t.length;
                                if (i)
                                    for (e = 0; e < i; e++) r(t[e])
                            },
                            o = E(s);
                        return {
                            _: function() {
                                t = e.getElementsByClassName(n.autosizesClass), a("resize", o)
                            },
                            checkElems: o,
                            updateElem: r
                        }
                    }(),
                    I = function() {
                        I.i || (I.i = !0, k._(), z._())
                    };
                return function() {
                    var e, i = {
                        lazyClass: "lazyload",
                        loadedClass: "lazyloaded",
                        loadingClass: "lazyloading",
                        preloadClass: "lazypreload",
                        errorClass: "lazyerror",
                        autosizesClass: "lazyautosizes",
                        srcAttr: "data-src",
                        srcsetAttr: "data-srcset",
                        sizesAttr: "data-sizes",
                        minSize: 40,
                        customMedia: {},
                        init: !0,
                        expFactor: 1.5,
                        hFac: .8,
                        loadMode: 2,
                        loadHidden: !0
                    };
                    n = t.lazySizesConfig || t.lazysizesConfig || {};
                    for (e in i) e in n || (n[e] = i[e]);
                    t.lazySizesConfig = n, h(function() {
                        n.init && I()
                    })
                }(), i = {
                    cfg: n,
                    autoSizer: k,
                    loader: z,
                    init: I,
                    uP: w,
                    aC: v,
                    rC: _,
                    hC: p,
                    fire: y,
                    gW: b,
                    rAF: S
                }
            }
        }(t, t.document);
        t.lazySizes = i, "object" == typeof module && module.exports && (module.exports = i)
    }(window),
    function(t, e) {
        "use strict";

        function i(t, i) {
            if (!s[t]) {
                var n = e.createElement(i ? "link" : "script"),
                    r = e.getElementsByTagName("script")[0];
                i ? (n.rel = "stylesheet", n.href = t) : n.src = t, s[t] = !0, s[n.src || n.href] = !0, r.parentNode.insertBefore(n, r)
            }
        }
        var n, r, s = {};
        e.addEventListener && (r = /\(|\)|\s|'/, n = function(t, i) {
            var n = e.createElement("img");
            n.onload = function() {
                n.onload = null, n.onerror = null, n = null, i()
            }, n.onerror = n.onload, n.src = t, n && n.complete && n.onload && n.onload()
        }, addEventListener("lazybeforeunveil", function(t) {
            var e, s, o, a;
            t.defaultPrevented || ("none" == t.target.preload && (t.target.preload = "auto"), e = t.target.getAttribute("data-link"), e && i(e, !0), e = t.target.getAttribute("data-script"), e && i(e), e = t.target.getAttribute("data-require"), e && (lazySizes.cfg.requireJs ? lazySizes.cfg.requireJs([e]) : i(e)), o = t.target.getAttribute("data-bg"), o && (t.detail.firesLoad = !0, s = function() {
                t.target.style.backgroundImage = "url(" + (r.test(o) ? JSON.stringify(o) : o) + ")", t.detail.firesLoad = !1, lazySizes.fire(t.target, "_lazyloaded", {}, !0, !0)
            }, n(o, s)), (a = t.target.getAttribute("data-poster")) && (t.detail.firesLoad = !0, s = function() {
                t.target.poster = a, t.detail.firesLoad = !1, lazySizes.fire(t.target, "_lazyloaded", {}, !0, !0)
            }, n(a, s)))
        }, !1))
    }(window, document);